// Code generated by protoc-gen-go-pulsar. DO NOT EDIT.
package poolv1beta1

import (
	fmt "fmt"
	runtime "github.com/cosmos/cosmos-proto/runtime"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoiface "google.golang.org/protobuf/runtime/protoiface"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	io "io"
	reflect "reflect"
	sync "sync"
)

var (
	md_EventCreatePool                     protoreflect.MessageDescriptor
	fd_EventCreatePool_id                  protoreflect.FieldDescriptor
	fd_EventCreatePool_name                protoreflect.FieldDescriptor
	fd_EventCreatePool_runtime             protoreflect.FieldDescriptor
	fd_EventCreatePool_logo                protoreflect.FieldDescriptor
	fd_EventCreatePool_config              protoreflect.FieldDescriptor
	fd_EventCreatePool_start_key           protoreflect.FieldDescriptor
	fd_EventCreatePool_upload_interval     protoreflect.FieldDescriptor
	fd_EventCreatePool_operating_cost      protoreflect.FieldDescriptor
	fd_EventCreatePool_min_delegation      protoreflect.FieldDescriptor
	fd_EventCreatePool_max_bundle_size     protoreflect.FieldDescriptor
	fd_EventCreatePool_version             protoreflect.FieldDescriptor
	fd_EventCreatePool_binaries            protoreflect.FieldDescriptor
	fd_EventCreatePool_storage_provider_id protoreflect.FieldDescriptor
	fd_EventCreatePool_compression_id      protoreflect.FieldDescriptor
)

func init() {
	file_kyve_pool_v1beta1_events_proto_init()
	md_EventCreatePool = File_kyve_pool_v1beta1_events_proto.Messages().ByName("EventCreatePool")
	fd_EventCreatePool_id = md_EventCreatePool.Fields().ByName("id")
	fd_EventCreatePool_name = md_EventCreatePool.Fields().ByName("name")
	fd_EventCreatePool_runtime = md_EventCreatePool.Fields().ByName("runtime")
	fd_EventCreatePool_logo = md_EventCreatePool.Fields().ByName("logo")
	fd_EventCreatePool_config = md_EventCreatePool.Fields().ByName("config")
	fd_EventCreatePool_start_key = md_EventCreatePool.Fields().ByName("start_key")
	fd_EventCreatePool_upload_interval = md_EventCreatePool.Fields().ByName("upload_interval")
	fd_EventCreatePool_operating_cost = md_EventCreatePool.Fields().ByName("operating_cost")
	fd_EventCreatePool_min_delegation = md_EventCreatePool.Fields().ByName("min_delegation")
	fd_EventCreatePool_max_bundle_size = md_EventCreatePool.Fields().ByName("max_bundle_size")
	fd_EventCreatePool_version = md_EventCreatePool.Fields().ByName("version")
	fd_EventCreatePool_binaries = md_EventCreatePool.Fields().ByName("binaries")
	fd_EventCreatePool_storage_provider_id = md_EventCreatePool.Fields().ByName("storage_provider_id")
	fd_EventCreatePool_compression_id = md_EventCreatePool.Fields().ByName("compression_id")
}

var _ protoreflect.Message = (*fastReflection_EventCreatePool)(nil)

type fastReflection_EventCreatePool EventCreatePool

func (x *EventCreatePool) ProtoReflect() protoreflect.Message {
	return (*fastReflection_EventCreatePool)(x)
}

func (x *EventCreatePool) slowProtoReflect() protoreflect.Message {
	mi := &file_kyve_pool_v1beta1_events_proto_msgTypes[0]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_EventCreatePool_messageType fastReflection_EventCreatePool_messageType
var _ protoreflect.MessageType = fastReflection_EventCreatePool_messageType{}

type fastReflection_EventCreatePool_messageType struct{}

func (x fastReflection_EventCreatePool_messageType) Zero() protoreflect.Message {
	return (*fastReflection_EventCreatePool)(nil)
}
func (x fastReflection_EventCreatePool_messageType) New() protoreflect.Message {
	return new(fastReflection_EventCreatePool)
}
func (x fastReflection_EventCreatePool_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_EventCreatePool
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_EventCreatePool) Descriptor() protoreflect.MessageDescriptor {
	return md_EventCreatePool
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_EventCreatePool) Type() protoreflect.MessageType {
	return _fastReflection_EventCreatePool_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_EventCreatePool) New() protoreflect.Message {
	return new(fastReflection_EventCreatePool)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_EventCreatePool) Interface() protoreflect.ProtoMessage {
	return (*EventCreatePool)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_EventCreatePool) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.Id != uint64(0) {
		value := protoreflect.ValueOfUint64(x.Id)
		if !f(fd_EventCreatePool_id, value) {
			return
		}
	}
	if x.Name != "" {
		value := protoreflect.ValueOfString(x.Name)
		if !f(fd_EventCreatePool_name, value) {
			return
		}
	}
	if x.Runtime != "" {
		value := protoreflect.ValueOfString(x.Runtime)
		if !f(fd_EventCreatePool_runtime, value) {
			return
		}
	}
	if x.Logo != "" {
		value := protoreflect.ValueOfString(x.Logo)
		if !f(fd_EventCreatePool_logo, value) {
			return
		}
	}
	if x.Config != "" {
		value := protoreflect.ValueOfString(x.Config)
		if !f(fd_EventCreatePool_config, value) {
			return
		}
	}
	if x.StartKey != "" {
		value := protoreflect.ValueOfString(x.StartKey)
		if !f(fd_EventCreatePool_start_key, value) {
			return
		}
	}
	if x.UploadInterval != uint64(0) {
		value := protoreflect.ValueOfUint64(x.UploadInterval)
		if !f(fd_EventCreatePool_upload_interval, value) {
			return
		}
	}
	if x.OperatingCost != uint64(0) {
		value := protoreflect.ValueOfUint64(x.OperatingCost)
		if !f(fd_EventCreatePool_operating_cost, value) {
			return
		}
	}
	if x.MinDelegation != uint64(0) {
		value := protoreflect.ValueOfUint64(x.MinDelegation)
		if !f(fd_EventCreatePool_min_delegation, value) {
			return
		}
	}
	if x.MaxBundleSize != uint64(0) {
		value := protoreflect.ValueOfUint64(x.MaxBundleSize)
		if !f(fd_EventCreatePool_max_bundle_size, value) {
			return
		}
	}
	if x.Version != "" {
		value := protoreflect.ValueOfString(x.Version)
		if !f(fd_EventCreatePool_version, value) {
			return
		}
	}
	if x.Binaries != "" {
		value := protoreflect.ValueOfString(x.Binaries)
		if !f(fd_EventCreatePool_binaries, value) {
			return
		}
	}
	if x.StorageProviderId != uint32(0) {
		value := protoreflect.ValueOfUint32(x.StorageProviderId)
		if !f(fd_EventCreatePool_storage_provider_id, value) {
			return
		}
	}
	if x.CompressionId != uint32(0) {
		value := protoreflect.ValueOfUint32(x.CompressionId)
		if !f(fd_EventCreatePool_compression_id, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_EventCreatePool) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "kyve.pool.v1beta1.EventCreatePool.id":
		return x.Id != uint64(0)
	case "kyve.pool.v1beta1.EventCreatePool.name":
		return x.Name != ""
	case "kyve.pool.v1beta1.EventCreatePool.runtime":
		return x.Runtime != ""
	case "kyve.pool.v1beta1.EventCreatePool.logo":
		return x.Logo != ""
	case "kyve.pool.v1beta1.EventCreatePool.config":
		return x.Config != ""
	case "kyve.pool.v1beta1.EventCreatePool.start_key":
		return x.StartKey != ""
	case "kyve.pool.v1beta1.EventCreatePool.upload_interval":
		return x.UploadInterval != uint64(0)
	case "kyve.pool.v1beta1.EventCreatePool.operating_cost":
		return x.OperatingCost != uint64(0)
	case "kyve.pool.v1beta1.EventCreatePool.min_delegation":
		return x.MinDelegation != uint64(0)
	case "kyve.pool.v1beta1.EventCreatePool.max_bundle_size":
		return x.MaxBundleSize != uint64(0)
	case "kyve.pool.v1beta1.EventCreatePool.version":
		return x.Version != ""
	case "kyve.pool.v1beta1.EventCreatePool.binaries":
		return x.Binaries != ""
	case "kyve.pool.v1beta1.EventCreatePool.storage_provider_id":
		return x.StorageProviderId != uint32(0)
	case "kyve.pool.v1beta1.EventCreatePool.compression_id":
		return x.CompressionId != uint32(0)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: kyve.pool.v1beta1.EventCreatePool"))
		}
		panic(fmt.Errorf("message kyve.pool.v1beta1.EventCreatePool does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventCreatePool) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "kyve.pool.v1beta1.EventCreatePool.id":
		x.Id = uint64(0)
	case "kyve.pool.v1beta1.EventCreatePool.name":
		x.Name = ""
	case "kyve.pool.v1beta1.EventCreatePool.runtime":
		x.Runtime = ""
	case "kyve.pool.v1beta1.EventCreatePool.logo":
		x.Logo = ""
	case "kyve.pool.v1beta1.EventCreatePool.config":
		x.Config = ""
	case "kyve.pool.v1beta1.EventCreatePool.start_key":
		x.StartKey = ""
	case "kyve.pool.v1beta1.EventCreatePool.upload_interval":
		x.UploadInterval = uint64(0)
	case "kyve.pool.v1beta1.EventCreatePool.operating_cost":
		x.OperatingCost = uint64(0)
	case "kyve.pool.v1beta1.EventCreatePool.min_delegation":
		x.MinDelegation = uint64(0)
	case "kyve.pool.v1beta1.EventCreatePool.max_bundle_size":
		x.MaxBundleSize = uint64(0)
	case "kyve.pool.v1beta1.EventCreatePool.version":
		x.Version = ""
	case "kyve.pool.v1beta1.EventCreatePool.binaries":
		x.Binaries = ""
	case "kyve.pool.v1beta1.EventCreatePool.storage_provider_id":
		x.StorageProviderId = uint32(0)
	case "kyve.pool.v1beta1.EventCreatePool.compression_id":
		x.CompressionId = uint32(0)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: kyve.pool.v1beta1.EventCreatePool"))
		}
		panic(fmt.Errorf("message kyve.pool.v1beta1.EventCreatePool does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_EventCreatePool) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "kyve.pool.v1beta1.EventCreatePool.id":
		value := x.Id
		return protoreflect.ValueOfUint64(value)
	case "kyve.pool.v1beta1.EventCreatePool.name":
		value := x.Name
		return protoreflect.ValueOfString(value)
	case "kyve.pool.v1beta1.EventCreatePool.runtime":
		value := x.Runtime
		return protoreflect.ValueOfString(value)
	case "kyve.pool.v1beta1.EventCreatePool.logo":
		value := x.Logo
		return protoreflect.ValueOfString(value)
	case "kyve.pool.v1beta1.EventCreatePool.config":
		value := x.Config
		return protoreflect.ValueOfString(value)
	case "kyve.pool.v1beta1.EventCreatePool.start_key":
		value := x.StartKey
		return protoreflect.ValueOfString(value)
	case "kyve.pool.v1beta1.EventCreatePool.upload_interval":
		value := x.UploadInterval
		return protoreflect.ValueOfUint64(value)
	case "kyve.pool.v1beta1.EventCreatePool.operating_cost":
		value := x.OperatingCost
		return protoreflect.ValueOfUint64(value)
	case "kyve.pool.v1beta1.EventCreatePool.min_delegation":
		value := x.MinDelegation
		return protoreflect.ValueOfUint64(value)
	case "kyve.pool.v1beta1.EventCreatePool.max_bundle_size":
		value := x.MaxBundleSize
		return protoreflect.ValueOfUint64(value)
	case "kyve.pool.v1beta1.EventCreatePool.version":
		value := x.Version
		return protoreflect.ValueOfString(value)
	case "kyve.pool.v1beta1.EventCreatePool.binaries":
		value := x.Binaries
		return protoreflect.ValueOfString(value)
	case "kyve.pool.v1beta1.EventCreatePool.storage_provider_id":
		value := x.StorageProviderId
		return protoreflect.ValueOfUint32(value)
	case "kyve.pool.v1beta1.EventCreatePool.compression_id":
		value := x.CompressionId
		return protoreflect.ValueOfUint32(value)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: kyve.pool.v1beta1.EventCreatePool"))
		}
		panic(fmt.Errorf("message kyve.pool.v1beta1.EventCreatePool does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventCreatePool) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "kyve.pool.v1beta1.EventCreatePool.id":
		x.Id = value.Uint()
	case "kyve.pool.v1beta1.EventCreatePool.name":
		x.Name = value.Interface().(string)
	case "kyve.pool.v1beta1.EventCreatePool.runtime":
		x.Runtime = value.Interface().(string)
	case "kyve.pool.v1beta1.EventCreatePool.logo":
		x.Logo = value.Interface().(string)
	case "kyve.pool.v1beta1.EventCreatePool.config":
		x.Config = value.Interface().(string)
	case "kyve.pool.v1beta1.EventCreatePool.start_key":
		x.StartKey = value.Interface().(string)
	case "kyve.pool.v1beta1.EventCreatePool.upload_interval":
		x.UploadInterval = value.Uint()
	case "kyve.pool.v1beta1.EventCreatePool.operating_cost":
		x.OperatingCost = value.Uint()
	case "kyve.pool.v1beta1.EventCreatePool.min_delegation":
		x.MinDelegation = value.Uint()
	case "kyve.pool.v1beta1.EventCreatePool.max_bundle_size":
		x.MaxBundleSize = value.Uint()
	case "kyve.pool.v1beta1.EventCreatePool.version":
		x.Version = value.Interface().(string)
	case "kyve.pool.v1beta1.EventCreatePool.binaries":
		x.Binaries = value.Interface().(string)
	case "kyve.pool.v1beta1.EventCreatePool.storage_provider_id":
		x.StorageProviderId = uint32(value.Uint())
	case "kyve.pool.v1beta1.EventCreatePool.compression_id":
		x.CompressionId = uint32(value.Uint())
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: kyve.pool.v1beta1.EventCreatePool"))
		}
		panic(fmt.Errorf("message kyve.pool.v1beta1.EventCreatePool does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventCreatePool) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "kyve.pool.v1beta1.EventCreatePool.id":
		panic(fmt.Errorf("field id of message kyve.pool.v1beta1.EventCreatePool is not mutable"))
	case "kyve.pool.v1beta1.EventCreatePool.name":
		panic(fmt.Errorf("field name of message kyve.pool.v1beta1.EventCreatePool is not mutable"))
	case "kyve.pool.v1beta1.EventCreatePool.runtime":
		panic(fmt.Errorf("field runtime of message kyve.pool.v1beta1.EventCreatePool is not mutable"))
	case "kyve.pool.v1beta1.EventCreatePool.logo":
		panic(fmt.Errorf("field logo of message kyve.pool.v1beta1.EventCreatePool is not mutable"))
	case "kyve.pool.v1beta1.EventCreatePool.config":
		panic(fmt.Errorf("field config of message kyve.pool.v1beta1.EventCreatePool is not mutable"))
	case "kyve.pool.v1beta1.EventCreatePool.start_key":
		panic(fmt.Errorf("field start_key of message kyve.pool.v1beta1.EventCreatePool is not mutable"))
	case "kyve.pool.v1beta1.EventCreatePool.upload_interval":
		panic(fmt.Errorf("field upload_interval of message kyve.pool.v1beta1.EventCreatePool is not mutable"))
	case "kyve.pool.v1beta1.EventCreatePool.operating_cost":
		panic(fmt.Errorf("field operating_cost of message kyve.pool.v1beta1.EventCreatePool is not mutable"))
	case "kyve.pool.v1beta1.EventCreatePool.min_delegation":
		panic(fmt.Errorf("field min_delegation of message kyve.pool.v1beta1.EventCreatePool is not mutable"))
	case "kyve.pool.v1beta1.EventCreatePool.max_bundle_size":
		panic(fmt.Errorf("field max_bundle_size of message kyve.pool.v1beta1.EventCreatePool is not mutable"))
	case "kyve.pool.v1beta1.EventCreatePool.version":
		panic(fmt.Errorf("field version of message kyve.pool.v1beta1.EventCreatePool is not mutable"))
	case "kyve.pool.v1beta1.EventCreatePool.binaries":
		panic(fmt.Errorf("field binaries of message kyve.pool.v1beta1.EventCreatePool is not mutable"))
	case "kyve.pool.v1beta1.EventCreatePool.storage_provider_id":
		panic(fmt.Errorf("field storage_provider_id of message kyve.pool.v1beta1.EventCreatePool is not mutable"))
	case "kyve.pool.v1beta1.EventCreatePool.compression_id":
		panic(fmt.Errorf("field compression_id of message kyve.pool.v1beta1.EventCreatePool is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: kyve.pool.v1beta1.EventCreatePool"))
		}
		panic(fmt.Errorf("message kyve.pool.v1beta1.EventCreatePool does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_EventCreatePool) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "kyve.pool.v1beta1.EventCreatePool.id":
		return protoreflect.ValueOfUint64(uint64(0))
	case "kyve.pool.v1beta1.EventCreatePool.name":
		return protoreflect.ValueOfString("")
	case "kyve.pool.v1beta1.EventCreatePool.runtime":
		return protoreflect.ValueOfString("")
	case "kyve.pool.v1beta1.EventCreatePool.logo":
		return protoreflect.ValueOfString("")
	case "kyve.pool.v1beta1.EventCreatePool.config":
		return protoreflect.ValueOfString("")
	case "kyve.pool.v1beta1.EventCreatePool.start_key":
		return protoreflect.ValueOfString("")
	case "kyve.pool.v1beta1.EventCreatePool.upload_interval":
		return protoreflect.ValueOfUint64(uint64(0))
	case "kyve.pool.v1beta1.EventCreatePool.operating_cost":
		return protoreflect.ValueOfUint64(uint64(0))
	case "kyve.pool.v1beta1.EventCreatePool.min_delegation":
		return protoreflect.ValueOfUint64(uint64(0))
	case "kyve.pool.v1beta1.EventCreatePool.max_bundle_size":
		return protoreflect.ValueOfUint64(uint64(0))
	case "kyve.pool.v1beta1.EventCreatePool.version":
		return protoreflect.ValueOfString("")
	case "kyve.pool.v1beta1.EventCreatePool.binaries":
		return protoreflect.ValueOfString("")
	case "kyve.pool.v1beta1.EventCreatePool.storage_provider_id":
		return protoreflect.ValueOfUint32(uint32(0))
	case "kyve.pool.v1beta1.EventCreatePool.compression_id":
		return protoreflect.ValueOfUint32(uint32(0))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: kyve.pool.v1beta1.EventCreatePool"))
		}
		panic(fmt.Errorf("message kyve.pool.v1beta1.EventCreatePool does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_EventCreatePool) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in kyve.pool.v1beta1.EventCreatePool", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_EventCreatePool) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventCreatePool) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_EventCreatePool) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_EventCreatePool) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*EventCreatePool)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		if x.Id != 0 {
			n += 1 + runtime.Sov(uint64(x.Id))
		}
		l = len(x.Name)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.Runtime)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.Logo)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.Config)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.StartKey)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.UploadInterval != 0 {
			n += 1 + runtime.Sov(uint64(x.UploadInterval))
		}
		if x.OperatingCost != 0 {
			n += 1 + runtime.Sov(uint64(x.OperatingCost))
		}
		if x.MinDelegation != 0 {
			n += 1 + runtime.Sov(uint64(x.MinDelegation))
		}
		if x.MaxBundleSize != 0 {
			n += 1 + runtime.Sov(uint64(x.MaxBundleSize))
		}
		l = len(x.Version)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.Binaries)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.StorageProviderId != 0 {
			n += 1 + runtime.Sov(uint64(x.StorageProviderId))
		}
		if x.CompressionId != 0 {
			n += 1 + runtime.Sov(uint64(x.CompressionId))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*EventCreatePool)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if x.CompressionId != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.CompressionId))
			i--
			dAtA[i] = 0x70
		}
		if x.StorageProviderId != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.StorageProviderId))
			i--
			dAtA[i] = 0x68
		}
		if len(x.Binaries) > 0 {
			i -= len(x.Binaries)
			copy(dAtA[i:], x.Binaries)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Binaries)))
			i--
			dAtA[i] = 0x62
		}
		if len(x.Version) > 0 {
			i -= len(x.Version)
			copy(dAtA[i:], x.Version)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Version)))
			i--
			dAtA[i] = 0x5a
		}
		if x.MaxBundleSize != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.MaxBundleSize))
			i--
			dAtA[i] = 0x50
		}
		if x.MinDelegation != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.MinDelegation))
			i--
			dAtA[i] = 0x48
		}
		if x.OperatingCost != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.OperatingCost))
			i--
			dAtA[i] = 0x40
		}
		if x.UploadInterval != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.UploadInterval))
			i--
			dAtA[i] = 0x38
		}
		if len(x.StartKey) > 0 {
			i -= len(x.StartKey)
			copy(dAtA[i:], x.StartKey)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.StartKey)))
			i--
			dAtA[i] = 0x32
		}
		if len(x.Config) > 0 {
			i -= len(x.Config)
			copy(dAtA[i:], x.Config)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Config)))
			i--
			dAtA[i] = 0x2a
		}
		if len(x.Logo) > 0 {
			i -= len(x.Logo)
			copy(dAtA[i:], x.Logo)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Logo)))
			i--
			dAtA[i] = 0x22
		}
		if len(x.Runtime) > 0 {
			i -= len(x.Runtime)
			copy(dAtA[i:], x.Runtime)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Runtime)))
			i--
			dAtA[i] = 0x1a
		}
		if len(x.Name) > 0 {
			i -= len(x.Name)
			copy(dAtA[i:], x.Name)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Name)))
			i--
			dAtA[i] = 0x12
		}
		if x.Id != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.Id))
			i--
			dAtA[i] = 0x8
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*EventCreatePool)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: EventCreatePool: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: EventCreatePool: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
				}
				x.Id = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.Id |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Name = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 3:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Runtime", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Runtime = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 4:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Logo", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Logo = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 5:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Config", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Config = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 6:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field StartKey", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.StartKey = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 7:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field UploadInterval", wireType)
				}
				x.UploadInterval = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.UploadInterval |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 8:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field OperatingCost", wireType)
				}
				x.OperatingCost = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.OperatingCost |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 9:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field MinDelegation", wireType)
				}
				x.MinDelegation = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.MinDelegation |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 10:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field MaxBundleSize", wireType)
				}
				x.MaxBundleSize = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.MaxBundleSize |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 11:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Version = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 12:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Binaries", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Binaries = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 13:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field StorageProviderId", wireType)
				}
				x.StorageProviderId = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.StorageProviderId |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 14:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field CompressionId", wireType)
				}
				x.CompressionId = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.CompressionId |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_EventPoolEnabled    protoreflect.MessageDescriptor
	fd_EventPoolEnabled_id protoreflect.FieldDescriptor
)

func init() {
	file_kyve_pool_v1beta1_events_proto_init()
	md_EventPoolEnabled = File_kyve_pool_v1beta1_events_proto.Messages().ByName("EventPoolEnabled")
	fd_EventPoolEnabled_id = md_EventPoolEnabled.Fields().ByName("id")
}

var _ protoreflect.Message = (*fastReflection_EventPoolEnabled)(nil)

type fastReflection_EventPoolEnabled EventPoolEnabled

func (x *EventPoolEnabled) ProtoReflect() protoreflect.Message {
	return (*fastReflection_EventPoolEnabled)(x)
}

func (x *EventPoolEnabled) slowProtoReflect() protoreflect.Message {
	mi := &file_kyve_pool_v1beta1_events_proto_msgTypes[1]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_EventPoolEnabled_messageType fastReflection_EventPoolEnabled_messageType
var _ protoreflect.MessageType = fastReflection_EventPoolEnabled_messageType{}

type fastReflection_EventPoolEnabled_messageType struct{}

func (x fastReflection_EventPoolEnabled_messageType) Zero() protoreflect.Message {
	return (*fastReflection_EventPoolEnabled)(nil)
}
func (x fastReflection_EventPoolEnabled_messageType) New() protoreflect.Message {
	return new(fastReflection_EventPoolEnabled)
}
func (x fastReflection_EventPoolEnabled_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_EventPoolEnabled
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_EventPoolEnabled) Descriptor() protoreflect.MessageDescriptor {
	return md_EventPoolEnabled
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_EventPoolEnabled) Type() protoreflect.MessageType {
	return _fastReflection_EventPoolEnabled_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_EventPoolEnabled) New() protoreflect.Message {
	return new(fastReflection_EventPoolEnabled)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_EventPoolEnabled) Interface() protoreflect.ProtoMessage {
	return (*EventPoolEnabled)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_EventPoolEnabled) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.Id != uint64(0) {
		value := protoreflect.ValueOfUint64(x.Id)
		if !f(fd_EventPoolEnabled_id, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_EventPoolEnabled) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "kyve.pool.v1beta1.EventPoolEnabled.id":
		return x.Id != uint64(0)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: kyve.pool.v1beta1.EventPoolEnabled"))
		}
		panic(fmt.Errorf("message kyve.pool.v1beta1.EventPoolEnabled does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventPoolEnabled) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "kyve.pool.v1beta1.EventPoolEnabled.id":
		x.Id = uint64(0)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: kyve.pool.v1beta1.EventPoolEnabled"))
		}
		panic(fmt.Errorf("message kyve.pool.v1beta1.EventPoolEnabled does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_EventPoolEnabled) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "kyve.pool.v1beta1.EventPoolEnabled.id":
		value := x.Id
		return protoreflect.ValueOfUint64(value)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: kyve.pool.v1beta1.EventPoolEnabled"))
		}
		panic(fmt.Errorf("message kyve.pool.v1beta1.EventPoolEnabled does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventPoolEnabled) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "kyve.pool.v1beta1.EventPoolEnabled.id":
		x.Id = value.Uint()
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: kyve.pool.v1beta1.EventPoolEnabled"))
		}
		panic(fmt.Errorf("message kyve.pool.v1beta1.EventPoolEnabled does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventPoolEnabled) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "kyve.pool.v1beta1.EventPoolEnabled.id":
		panic(fmt.Errorf("field id of message kyve.pool.v1beta1.EventPoolEnabled is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: kyve.pool.v1beta1.EventPoolEnabled"))
		}
		panic(fmt.Errorf("message kyve.pool.v1beta1.EventPoolEnabled does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_EventPoolEnabled) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "kyve.pool.v1beta1.EventPoolEnabled.id":
		return protoreflect.ValueOfUint64(uint64(0))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: kyve.pool.v1beta1.EventPoolEnabled"))
		}
		panic(fmt.Errorf("message kyve.pool.v1beta1.EventPoolEnabled does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_EventPoolEnabled) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in kyve.pool.v1beta1.EventPoolEnabled", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_EventPoolEnabled) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventPoolEnabled) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_EventPoolEnabled) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_EventPoolEnabled) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*EventPoolEnabled)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		if x.Id != 0 {
			n += 1 + runtime.Sov(uint64(x.Id))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*EventPoolEnabled)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if x.Id != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.Id))
			i--
			dAtA[i] = 0x8
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*EventPoolEnabled)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: EventPoolEnabled: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: EventPoolEnabled: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
				}
				x.Id = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.Id |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_EventPoolDisabled    protoreflect.MessageDescriptor
	fd_EventPoolDisabled_id protoreflect.FieldDescriptor
)

func init() {
	file_kyve_pool_v1beta1_events_proto_init()
	md_EventPoolDisabled = File_kyve_pool_v1beta1_events_proto.Messages().ByName("EventPoolDisabled")
	fd_EventPoolDisabled_id = md_EventPoolDisabled.Fields().ByName("id")
}

var _ protoreflect.Message = (*fastReflection_EventPoolDisabled)(nil)

type fastReflection_EventPoolDisabled EventPoolDisabled

func (x *EventPoolDisabled) ProtoReflect() protoreflect.Message {
	return (*fastReflection_EventPoolDisabled)(x)
}

func (x *EventPoolDisabled) slowProtoReflect() protoreflect.Message {
	mi := &file_kyve_pool_v1beta1_events_proto_msgTypes[2]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_EventPoolDisabled_messageType fastReflection_EventPoolDisabled_messageType
var _ protoreflect.MessageType = fastReflection_EventPoolDisabled_messageType{}

type fastReflection_EventPoolDisabled_messageType struct{}

func (x fastReflection_EventPoolDisabled_messageType) Zero() protoreflect.Message {
	return (*fastReflection_EventPoolDisabled)(nil)
}
func (x fastReflection_EventPoolDisabled_messageType) New() protoreflect.Message {
	return new(fastReflection_EventPoolDisabled)
}
func (x fastReflection_EventPoolDisabled_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_EventPoolDisabled
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_EventPoolDisabled) Descriptor() protoreflect.MessageDescriptor {
	return md_EventPoolDisabled
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_EventPoolDisabled) Type() protoreflect.MessageType {
	return _fastReflection_EventPoolDisabled_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_EventPoolDisabled) New() protoreflect.Message {
	return new(fastReflection_EventPoolDisabled)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_EventPoolDisabled) Interface() protoreflect.ProtoMessage {
	return (*EventPoolDisabled)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_EventPoolDisabled) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.Id != uint64(0) {
		value := protoreflect.ValueOfUint64(x.Id)
		if !f(fd_EventPoolDisabled_id, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_EventPoolDisabled) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "kyve.pool.v1beta1.EventPoolDisabled.id":
		return x.Id != uint64(0)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: kyve.pool.v1beta1.EventPoolDisabled"))
		}
		panic(fmt.Errorf("message kyve.pool.v1beta1.EventPoolDisabled does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventPoolDisabled) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "kyve.pool.v1beta1.EventPoolDisabled.id":
		x.Id = uint64(0)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: kyve.pool.v1beta1.EventPoolDisabled"))
		}
		panic(fmt.Errorf("message kyve.pool.v1beta1.EventPoolDisabled does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_EventPoolDisabled) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "kyve.pool.v1beta1.EventPoolDisabled.id":
		value := x.Id
		return protoreflect.ValueOfUint64(value)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: kyve.pool.v1beta1.EventPoolDisabled"))
		}
		panic(fmt.Errorf("message kyve.pool.v1beta1.EventPoolDisabled does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventPoolDisabled) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "kyve.pool.v1beta1.EventPoolDisabled.id":
		x.Id = value.Uint()
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: kyve.pool.v1beta1.EventPoolDisabled"))
		}
		panic(fmt.Errorf("message kyve.pool.v1beta1.EventPoolDisabled does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventPoolDisabled) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "kyve.pool.v1beta1.EventPoolDisabled.id":
		panic(fmt.Errorf("field id of message kyve.pool.v1beta1.EventPoolDisabled is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: kyve.pool.v1beta1.EventPoolDisabled"))
		}
		panic(fmt.Errorf("message kyve.pool.v1beta1.EventPoolDisabled does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_EventPoolDisabled) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "kyve.pool.v1beta1.EventPoolDisabled.id":
		return protoreflect.ValueOfUint64(uint64(0))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: kyve.pool.v1beta1.EventPoolDisabled"))
		}
		panic(fmt.Errorf("message kyve.pool.v1beta1.EventPoolDisabled does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_EventPoolDisabled) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in kyve.pool.v1beta1.EventPoolDisabled", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_EventPoolDisabled) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventPoolDisabled) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_EventPoolDisabled) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_EventPoolDisabled) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*EventPoolDisabled)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		if x.Id != 0 {
			n += 1 + runtime.Sov(uint64(x.Id))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*EventPoolDisabled)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if x.Id != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.Id))
			i--
			dAtA[i] = 0x8
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*EventPoolDisabled)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: EventPoolDisabled: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: EventPoolDisabled: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
				}
				x.Id = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.Id |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var _ protoreflect.List = (*_EventRuntimeUpgradeScheduled_6_list)(nil)

type _EventRuntimeUpgradeScheduled_6_list struct {
	list *[]uint64
}

func (x *_EventRuntimeUpgradeScheduled_6_list) Len() int {
	if x.list == nil {
		return 0
	}
	return len(*x.list)
}

func (x *_EventRuntimeUpgradeScheduled_6_list) Get(i int) protoreflect.Value {
	return protoreflect.ValueOfUint64((*x.list)[i])
}

func (x *_EventRuntimeUpgradeScheduled_6_list) Set(i int, value protoreflect.Value) {
	valueUnwrapped := value.Uint()
	concreteValue := valueUnwrapped
	(*x.list)[i] = concreteValue
}

func (x *_EventRuntimeUpgradeScheduled_6_list) Append(value protoreflect.Value) {
	valueUnwrapped := value.Uint()
	concreteValue := valueUnwrapped
	*x.list = append(*x.list, concreteValue)
}

func (x *_EventRuntimeUpgradeScheduled_6_list) AppendMutable() protoreflect.Value {
	panic(fmt.Errorf("AppendMutable can not be called on message EventRuntimeUpgradeScheduled at list field AffectedPools as it is not of Message kind"))
}

func (x *_EventRuntimeUpgradeScheduled_6_list) Truncate(n int) {
	*x.list = (*x.list)[:n]
}

func (x *_EventRuntimeUpgradeScheduled_6_list) NewElement() protoreflect.Value {
	v := uint64(0)
	return protoreflect.ValueOfUint64(v)
}

func (x *_EventRuntimeUpgradeScheduled_6_list) IsValid() bool {
	return x.list != nil
}

var (
	md_EventRuntimeUpgradeScheduled                protoreflect.MessageDescriptor
	fd_EventRuntimeUpgradeScheduled_runtime        protoreflect.FieldDescriptor
	fd_EventRuntimeUpgradeScheduled_version        protoreflect.FieldDescriptor
	fd_EventRuntimeUpgradeScheduled_scheduled_at   protoreflect.FieldDescriptor
	fd_EventRuntimeUpgradeScheduled_duration       protoreflect.FieldDescriptor
	fd_EventRuntimeUpgradeScheduled_binaries       protoreflect.FieldDescriptor
	fd_EventRuntimeUpgradeScheduled_affected_pools protoreflect.FieldDescriptor
)

func init() {
	file_kyve_pool_v1beta1_events_proto_init()
	md_EventRuntimeUpgradeScheduled = File_kyve_pool_v1beta1_events_proto.Messages().ByName("EventRuntimeUpgradeScheduled")
	fd_EventRuntimeUpgradeScheduled_runtime = md_EventRuntimeUpgradeScheduled.Fields().ByName("runtime")
	fd_EventRuntimeUpgradeScheduled_version = md_EventRuntimeUpgradeScheduled.Fields().ByName("version")
	fd_EventRuntimeUpgradeScheduled_scheduled_at = md_EventRuntimeUpgradeScheduled.Fields().ByName("scheduled_at")
	fd_EventRuntimeUpgradeScheduled_duration = md_EventRuntimeUpgradeScheduled.Fields().ByName("duration")
	fd_EventRuntimeUpgradeScheduled_binaries = md_EventRuntimeUpgradeScheduled.Fields().ByName("binaries")
	fd_EventRuntimeUpgradeScheduled_affected_pools = md_EventRuntimeUpgradeScheduled.Fields().ByName("affected_pools")
}

var _ protoreflect.Message = (*fastReflection_EventRuntimeUpgradeScheduled)(nil)

type fastReflection_EventRuntimeUpgradeScheduled EventRuntimeUpgradeScheduled

func (x *EventRuntimeUpgradeScheduled) ProtoReflect() protoreflect.Message {
	return (*fastReflection_EventRuntimeUpgradeScheduled)(x)
}

func (x *EventRuntimeUpgradeScheduled) slowProtoReflect() protoreflect.Message {
	mi := &file_kyve_pool_v1beta1_events_proto_msgTypes[3]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_EventRuntimeUpgradeScheduled_messageType fastReflection_EventRuntimeUpgradeScheduled_messageType
var _ protoreflect.MessageType = fastReflection_EventRuntimeUpgradeScheduled_messageType{}

type fastReflection_EventRuntimeUpgradeScheduled_messageType struct{}

func (x fastReflection_EventRuntimeUpgradeScheduled_messageType) Zero() protoreflect.Message {
	return (*fastReflection_EventRuntimeUpgradeScheduled)(nil)
}
func (x fastReflection_EventRuntimeUpgradeScheduled_messageType) New() protoreflect.Message {
	return new(fastReflection_EventRuntimeUpgradeScheduled)
}
func (x fastReflection_EventRuntimeUpgradeScheduled_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_EventRuntimeUpgradeScheduled
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_EventRuntimeUpgradeScheduled) Descriptor() protoreflect.MessageDescriptor {
	return md_EventRuntimeUpgradeScheduled
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_EventRuntimeUpgradeScheduled) Type() protoreflect.MessageType {
	return _fastReflection_EventRuntimeUpgradeScheduled_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_EventRuntimeUpgradeScheduled) New() protoreflect.Message {
	return new(fastReflection_EventRuntimeUpgradeScheduled)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_EventRuntimeUpgradeScheduled) Interface() protoreflect.ProtoMessage {
	return (*EventRuntimeUpgradeScheduled)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_EventRuntimeUpgradeScheduled) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.Runtime != "" {
		value := protoreflect.ValueOfString(x.Runtime)
		if !f(fd_EventRuntimeUpgradeScheduled_runtime, value) {
			return
		}
	}
	if x.Version != "" {
		value := protoreflect.ValueOfString(x.Version)
		if !f(fd_EventRuntimeUpgradeScheduled_version, value) {
			return
		}
	}
	if x.ScheduledAt != uint64(0) {
		value := protoreflect.ValueOfUint64(x.ScheduledAt)
		if !f(fd_EventRuntimeUpgradeScheduled_scheduled_at, value) {
			return
		}
	}
	if x.Duration != uint64(0) {
		value := protoreflect.ValueOfUint64(x.Duration)
		if !f(fd_EventRuntimeUpgradeScheduled_duration, value) {
			return
		}
	}
	if x.Binaries != "" {
		value := protoreflect.ValueOfString(x.Binaries)
		if !f(fd_EventRuntimeUpgradeScheduled_binaries, value) {
			return
		}
	}
	if len(x.AffectedPools) != 0 {
		value := protoreflect.ValueOfList(&_EventRuntimeUpgradeScheduled_6_list{list: &x.AffectedPools})
		if !f(fd_EventRuntimeUpgradeScheduled_affected_pools, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_EventRuntimeUpgradeScheduled) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "kyve.pool.v1beta1.EventRuntimeUpgradeScheduled.runtime":
		return x.Runtime != ""
	case "kyve.pool.v1beta1.EventRuntimeUpgradeScheduled.version":
		return x.Version != ""
	case "kyve.pool.v1beta1.EventRuntimeUpgradeScheduled.scheduled_at":
		return x.ScheduledAt != uint64(0)
	case "kyve.pool.v1beta1.EventRuntimeUpgradeScheduled.duration":
		return x.Duration != uint64(0)
	case "kyve.pool.v1beta1.EventRuntimeUpgradeScheduled.binaries":
		return x.Binaries != ""
	case "kyve.pool.v1beta1.EventRuntimeUpgradeScheduled.affected_pools":
		return len(x.AffectedPools) != 0
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: kyve.pool.v1beta1.EventRuntimeUpgradeScheduled"))
		}
		panic(fmt.Errorf("message kyve.pool.v1beta1.EventRuntimeUpgradeScheduled does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventRuntimeUpgradeScheduled) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "kyve.pool.v1beta1.EventRuntimeUpgradeScheduled.runtime":
		x.Runtime = ""
	case "kyve.pool.v1beta1.EventRuntimeUpgradeScheduled.version":
		x.Version = ""
	case "kyve.pool.v1beta1.EventRuntimeUpgradeScheduled.scheduled_at":
		x.ScheduledAt = uint64(0)
	case "kyve.pool.v1beta1.EventRuntimeUpgradeScheduled.duration":
		x.Duration = uint64(0)
	case "kyve.pool.v1beta1.EventRuntimeUpgradeScheduled.binaries":
		x.Binaries = ""
	case "kyve.pool.v1beta1.EventRuntimeUpgradeScheduled.affected_pools":
		x.AffectedPools = nil
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: kyve.pool.v1beta1.EventRuntimeUpgradeScheduled"))
		}
		panic(fmt.Errorf("message kyve.pool.v1beta1.EventRuntimeUpgradeScheduled does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_EventRuntimeUpgradeScheduled) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "kyve.pool.v1beta1.EventRuntimeUpgradeScheduled.runtime":
		value := x.Runtime
		return protoreflect.ValueOfString(value)
	case "kyve.pool.v1beta1.EventRuntimeUpgradeScheduled.version":
		value := x.Version
		return protoreflect.ValueOfString(value)
	case "kyve.pool.v1beta1.EventRuntimeUpgradeScheduled.scheduled_at":
		value := x.ScheduledAt
		return protoreflect.ValueOfUint64(value)
	case "kyve.pool.v1beta1.EventRuntimeUpgradeScheduled.duration":
		value := x.Duration
		return protoreflect.ValueOfUint64(value)
	case "kyve.pool.v1beta1.EventRuntimeUpgradeScheduled.binaries":
		value := x.Binaries
		return protoreflect.ValueOfString(value)
	case "kyve.pool.v1beta1.EventRuntimeUpgradeScheduled.affected_pools":
		if len(x.AffectedPools) == 0 {
			return protoreflect.ValueOfList(&_EventRuntimeUpgradeScheduled_6_list{})
		}
		listValue := &_EventRuntimeUpgradeScheduled_6_list{list: &x.AffectedPools}
		return protoreflect.ValueOfList(listValue)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: kyve.pool.v1beta1.EventRuntimeUpgradeScheduled"))
		}
		panic(fmt.Errorf("message kyve.pool.v1beta1.EventRuntimeUpgradeScheduled does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventRuntimeUpgradeScheduled) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "kyve.pool.v1beta1.EventRuntimeUpgradeScheduled.runtime":
		x.Runtime = value.Interface().(string)
	case "kyve.pool.v1beta1.EventRuntimeUpgradeScheduled.version":
		x.Version = value.Interface().(string)
	case "kyve.pool.v1beta1.EventRuntimeUpgradeScheduled.scheduled_at":
		x.ScheduledAt = value.Uint()
	case "kyve.pool.v1beta1.EventRuntimeUpgradeScheduled.duration":
		x.Duration = value.Uint()
	case "kyve.pool.v1beta1.EventRuntimeUpgradeScheduled.binaries":
		x.Binaries = value.Interface().(string)
	case "kyve.pool.v1beta1.EventRuntimeUpgradeScheduled.affected_pools":
		lv := value.List()
		clv := lv.(*_EventRuntimeUpgradeScheduled_6_list)
		x.AffectedPools = *clv.list
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: kyve.pool.v1beta1.EventRuntimeUpgradeScheduled"))
		}
		panic(fmt.Errorf("message kyve.pool.v1beta1.EventRuntimeUpgradeScheduled does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventRuntimeUpgradeScheduled) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "kyve.pool.v1beta1.EventRuntimeUpgradeScheduled.affected_pools":
		if x.AffectedPools == nil {
			x.AffectedPools = []uint64{}
		}
		value := &_EventRuntimeUpgradeScheduled_6_list{list: &x.AffectedPools}
		return protoreflect.ValueOfList(value)
	case "kyve.pool.v1beta1.EventRuntimeUpgradeScheduled.runtime":
		panic(fmt.Errorf("field runtime of message kyve.pool.v1beta1.EventRuntimeUpgradeScheduled is not mutable"))
	case "kyve.pool.v1beta1.EventRuntimeUpgradeScheduled.version":
		panic(fmt.Errorf("field version of message kyve.pool.v1beta1.EventRuntimeUpgradeScheduled is not mutable"))
	case "kyve.pool.v1beta1.EventRuntimeUpgradeScheduled.scheduled_at":
		panic(fmt.Errorf("field scheduled_at of message kyve.pool.v1beta1.EventRuntimeUpgradeScheduled is not mutable"))
	case "kyve.pool.v1beta1.EventRuntimeUpgradeScheduled.duration":
		panic(fmt.Errorf("field duration of message kyve.pool.v1beta1.EventRuntimeUpgradeScheduled is not mutable"))
	case "kyve.pool.v1beta1.EventRuntimeUpgradeScheduled.binaries":
		panic(fmt.Errorf("field binaries of message kyve.pool.v1beta1.EventRuntimeUpgradeScheduled is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: kyve.pool.v1beta1.EventRuntimeUpgradeScheduled"))
		}
		panic(fmt.Errorf("message kyve.pool.v1beta1.EventRuntimeUpgradeScheduled does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_EventRuntimeUpgradeScheduled) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "kyve.pool.v1beta1.EventRuntimeUpgradeScheduled.runtime":
		return protoreflect.ValueOfString("")
	case "kyve.pool.v1beta1.EventRuntimeUpgradeScheduled.version":
		return protoreflect.ValueOfString("")
	case "kyve.pool.v1beta1.EventRuntimeUpgradeScheduled.scheduled_at":
		return protoreflect.ValueOfUint64(uint64(0))
	case "kyve.pool.v1beta1.EventRuntimeUpgradeScheduled.duration":
		return protoreflect.ValueOfUint64(uint64(0))
	case "kyve.pool.v1beta1.EventRuntimeUpgradeScheduled.binaries":
		return protoreflect.ValueOfString("")
	case "kyve.pool.v1beta1.EventRuntimeUpgradeScheduled.affected_pools":
		list := []uint64{}
		return protoreflect.ValueOfList(&_EventRuntimeUpgradeScheduled_6_list{list: &list})
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: kyve.pool.v1beta1.EventRuntimeUpgradeScheduled"))
		}
		panic(fmt.Errorf("message kyve.pool.v1beta1.EventRuntimeUpgradeScheduled does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_EventRuntimeUpgradeScheduled) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in kyve.pool.v1beta1.EventRuntimeUpgradeScheduled", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_EventRuntimeUpgradeScheduled) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventRuntimeUpgradeScheduled) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_EventRuntimeUpgradeScheduled) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_EventRuntimeUpgradeScheduled) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*EventRuntimeUpgradeScheduled)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		l = len(x.Runtime)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.Version)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.ScheduledAt != 0 {
			n += 1 + runtime.Sov(uint64(x.ScheduledAt))
		}
		if x.Duration != 0 {
			n += 1 + runtime.Sov(uint64(x.Duration))
		}
		l = len(x.Binaries)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if len(x.AffectedPools) > 0 {
			l = 0
			for _, e := range x.AffectedPools {
				l += runtime.Sov(uint64(e))
			}
			n += 1 + runtime.Sov(uint64(l)) + l
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*EventRuntimeUpgradeScheduled)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if len(x.AffectedPools) > 0 {
			var pksize2 int
			for _, num := range x.AffectedPools {
				pksize2 += runtime.Sov(uint64(num))
			}
			i -= pksize2
			j1 := i
			for _, num := range x.AffectedPools {
				for num >= 1<<7 {
					dAtA[j1] = uint8(uint64(num)&0x7f | 0x80)
					num >>= 7
					j1++
				}
				dAtA[j1] = uint8(num)
				j1++
			}
			i = runtime.EncodeVarint(dAtA, i, uint64(pksize2))
			i--
			dAtA[i] = 0x32
		}
		if len(x.Binaries) > 0 {
			i -= len(x.Binaries)
			copy(dAtA[i:], x.Binaries)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Binaries)))
			i--
			dAtA[i] = 0x2a
		}
		if x.Duration != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.Duration))
			i--
			dAtA[i] = 0x20
		}
		if x.ScheduledAt != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.ScheduledAt))
			i--
			dAtA[i] = 0x18
		}
		if len(x.Version) > 0 {
			i -= len(x.Version)
			copy(dAtA[i:], x.Version)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Version)))
			i--
			dAtA[i] = 0x12
		}
		if len(x.Runtime) > 0 {
			i -= len(x.Runtime)
			copy(dAtA[i:], x.Runtime)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Runtime)))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*EventRuntimeUpgradeScheduled)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: EventRuntimeUpgradeScheduled: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: EventRuntimeUpgradeScheduled: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Runtime", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Runtime = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Version = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 3:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field ScheduledAt", wireType)
				}
				x.ScheduledAt = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.ScheduledAt |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 4:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Duration", wireType)
				}
				x.Duration = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.Duration |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 5:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Binaries", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Binaries = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 6:
				if wireType == 0 {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
						}
						if iNdEx >= l {
							return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					x.AffectedPools = append(x.AffectedPools, v)
				} else if wireType == 2 {
					var packedLen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
						}
						if iNdEx >= l {
							return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						packedLen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if packedLen < 0 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
					}
					postIndex := iNdEx + packedLen
					if postIndex < 0 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
					}
					if postIndex > l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					var elementCount int
					var count int
					for _, integer := range dAtA[iNdEx:postIndex] {
						if integer < 128 {
							count++
						}
					}
					elementCount = count
					if elementCount != 0 && len(x.AffectedPools) == 0 {
						x.AffectedPools = make([]uint64, 0, elementCount)
					}
					for iNdEx < postIndex {
						var v uint64
						for shift := uint(0); ; shift += 7 {
							if shift >= 64 {
								return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
							}
							if iNdEx >= l {
								return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
							}
							b := dAtA[iNdEx]
							iNdEx++
							v |= uint64(b&0x7F) << shift
							if b < 0x80 {
								break
							}
						}
						x.AffectedPools = append(x.AffectedPools, v)
					}
				} else {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field AffectedPools", wireType)
				}
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var _ protoreflect.List = (*_EventRuntimeUpgradeCancelled_2_list)(nil)

type _EventRuntimeUpgradeCancelled_2_list struct {
	list *[]uint64
}

func (x *_EventRuntimeUpgradeCancelled_2_list) Len() int {
	if x.list == nil {
		return 0
	}
	return len(*x.list)
}

func (x *_EventRuntimeUpgradeCancelled_2_list) Get(i int) protoreflect.Value {
	return protoreflect.ValueOfUint64((*x.list)[i])
}

func (x *_EventRuntimeUpgradeCancelled_2_list) Set(i int, value protoreflect.Value) {
	valueUnwrapped := value.Uint()
	concreteValue := valueUnwrapped
	(*x.list)[i] = concreteValue
}

func (x *_EventRuntimeUpgradeCancelled_2_list) Append(value protoreflect.Value) {
	valueUnwrapped := value.Uint()
	concreteValue := valueUnwrapped
	*x.list = append(*x.list, concreteValue)
}

func (x *_EventRuntimeUpgradeCancelled_2_list) AppendMutable() protoreflect.Value {
	panic(fmt.Errorf("AppendMutable can not be called on message EventRuntimeUpgradeCancelled at list field AffectedPools as it is not of Message kind"))
}

func (x *_EventRuntimeUpgradeCancelled_2_list) Truncate(n int) {
	*x.list = (*x.list)[:n]
}

func (x *_EventRuntimeUpgradeCancelled_2_list) NewElement() protoreflect.Value {
	v := uint64(0)
	return protoreflect.ValueOfUint64(v)
}

func (x *_EventRuntimeUpgradeCancelled_2_list) IsValid() bool {
	return x.list != nil
}

var (
	md_EventRuntimeUpgradeCancelled                protoreflect.MessageDescriptor
	fd_EventRuntimeUpgradeCancelled_runtime        protoreflect.FieldDescriptor
	fd_EventRuntimeUpgradeCancelled_affected_pools protoreflect.FieldDescriptor
)

func init() {
	file_kyve_pool_v1beta1_events_proto_init()
	md_EventRuntimeUpgradeCancelled = File_kyve_pool_v1beta1_events_proto.Messages().ByName("EventRuntimeUpgradeCancelled")
	fd_EventRuntimeUpgradeCancelled_runtime = md_EventRuntimeUpgradeCancelled.Fields().ByName("runtime")
	fd_EventRuntimeUpgradeCancelled_affected_pools = md_EventRuntimeUpgradeCancelled.Fields().ByName("affected_pools")
}

var _ protoreflect.Message = (*fastReflection_EventRuntimeUpgradeCancelled)(nil)

type fastReflection_EventRuntimeUpgradeCancelled EventRuntimeUpgradeCancelled

func (x *EventRuntimeUpgradeCancelled) ProtoReflect() protoreflect.Message {
	return (*fastReflection_EventRuntimeUpgradeCancelled)(x)
}

func (x *EventRuntimeUpgradeCancelled) slowProtoReflect() protoreflect.Message {
	mi := &file_kyve_pool_v1beta1_events_proto_msgTypes[4]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_EventRuntimeUpgradeCancelled_messageType fastReflection_EventRuntimeUpgradeCancelled_messageType
var _ protoreflect.MessageType = fastReflection_EventRuntimeUpgradeCancelled_messageType{}

type fastReflection_EventRuntimeUpgradeCancelled_messageType struct{}

func (x fastReflection_EventRuntimeUpgradeCancelled_messageType) Zero() protoreflect.Message {
	return (*fastReflection_EventRuntimeUpgradeCancelled)(nil)
}
func (x fastReflection_EventRuntimeUpgradeCancelled_messageType) New() protoreflect.Message {
	return new(fastReflection_EventRuntimeUpgradeCancelled)
}
func (x fastReflection_EventRuntimeUpgradeCancelled_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_EventRuntimeUpgradeCancelled
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_EventRuntimeUpgradeCancelled) Descriptor() protoreflect.MessageDescriptor {
	return md_EventRuntimeUpgradeCancelled
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_EventRuntimeUpgradeCancelled) Type() protoreflect.MessageType {
	return _fastReflection_EventRuntimeUpgradeCancelled_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_EventRuntimeUpgradeCancelled) New() protoreflect.Message {
	return new(fastReflection_EventRuntimeUpgradeCancelled)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_EventRuntimeUpgradeCancelled) Interface() protoreflect.ProtoMessage {
	return (*EventRuntimeUpgradeCancelled)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_EventRuntimeUpgradeCancelled) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.Runtime != "" {
		value := protoreflect.ValueOfString(x.Runtime)
		if !f(fd_EventRuntimeUpgradeCancelled_runtime, value) {
			return
		}
	}
	if len(x.AffectedPools) != 0 {
		value := protoreflect.ValueOfList(&_EventRuntimeUpgradeCancelled_2_list{list: &x.AffectedPools})
		if !f(fd_EventRuntimeUpgradeCancelled_affected_pools, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_EventRuntimeUpgradeCancelled) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "kyve.pool.v1beta1.EventRuntimeUpgradeCancelled.runtime":
		return x.Runtime != ""
	case "kyve.pool.v1beta1.EventRuntimeUpgradeCancelled.affected_pools":
		return len(x.AffectedPools) != 0
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: kyve.pool.v1beta1.EventRuntimeUpgradeCancelled"))
		}
		panic(fmt.Errorf("message kyve.pool.v1beta1.EventRuntimeUpgradeCancelled does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventRuntimeUpgradeCancelled) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "kyve.pool.v1beta1.EventRuntimeUpgradeCancelled.runtime":
		x.Runtime = ""
	case "kyve.pool.v1beta1.EventRuntimeUpgradeCancelled.affected_pools":
		x.AffectedPools = nil
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: kyve.pool.v1beta1.EventRuntimeUpgradeCancelled"))
		}
		panic(fmt.Errorf("message kyve.pool.v1beta1.EventRuntimeUpgradeCancelled does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_EventRuntimeUpgradeCancelled) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "kyve.pool.v1beta1.EventRuntimeUpgradeCancelled.runtime":
		value := x.Runtime
		return protoreflect.ValueOfString(value)
	case "kyve.pool.v1beta1.EventRuntimeUpgradeCancelled.affected_pools":
		if len(x.AffectedPools) == 0 {
			return protoreflect.ValueOfList(&_EventRuntimeUpgradeCancelled_2_list{})
		}
		listValue := &_EventRuntimeUpgradeCancelled_2_list{list: &x.AffectedPools}
		return protoreflect.ValueOfList(listValue)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: kyve.pool.v1beta1.EventRuntimeUpgradeCancelled"))
		}
		panic(fmt.Errorf("message kyve.pool.v1beta1.EventRuntimeUpgradeCancelled does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventRuntimeUpgradeCancelled) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "kyve.pool.v1beta1.EventRuntimeUpgradeCancelled.runtime":
		x.Runtime = value.Interface().(string)
	case "kyve.pool.v1beta1.EventRuntimeUpgradeCancelled.affected_pools":
		lv := value.List()
		clv := lv.(*_EventRuntimeUpgradeCancelled_2_list)
		x.AffectedPools = *clv.list
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: kyve.pool.v1beta1.EventRuntimeUpgradeCancelled"))
		}
		panic(fmt.Errorf("message kyve.pool.v1beta1.EventRuntimeUpgradeCancelled does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventRuntimeUpgradeCancelled) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "kyve.pool.v1beta1.EventRuntimeUpgradeCancelled.affected_pools":
		if x.AffectedPools == nil {
			x.AffectedPools = []uint64{}
		}
		value := &_EventRuntimeUpgradeCancelled_2_list{list: &x.AffectedPools}
		return protoreflect.ValueOfList(value)
	case "kyve.pool.v1beta1.EventRuntimeUpgradeCancelled.runtime":
		panic(fmt.Errorf("field runtime of message kyve.pool.v1beta1.EventRuntimeUpgradeCancelled is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: kyve.pool.v1beta1.EventRuntimeUpgradeCancelled"))
		}
		panic(fmt.Errorf("message kyve.pool.v1beta1.EventRuntimeUpgradeCancelled does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_EventRuntimeUpgradeCancelled) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "kyve.pool.v1beta1.EventRuntimeUpgradeCancelled.runtime":
		return protoreflect.ValueOfString("")
	case "kyve.pool.v1beta1.EventRuntimeUpgradeCancelled.affected_pools":
		list := []uint64{}
		return protoreflect.ValueOfList(&_EventRuntimeUpgradeCancelled_2_list{list: &list})
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: kyve.pool.v1beta1.EventRuntimeUpgradeCancelled"))
		}
		panic(fmt.Errorf("message kyve.pool.v1beta1.EventRuntimeUpgradeCancelled does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_EventRuntimeUpgradeCancelled) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in kyve.pool.v1beta1.EventRuntimeUpgradeCancelled", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_EventRuntimeUpgradeCancelled) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventRuntimeUpgradeCancelled) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_EventRuntimeUpgradeCancelled) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_EventRuntimeUpgradeCancelled) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*EventRuntimeUpgradeCancelled)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		l = len(x.Runtime)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if len(x.AffectedPools) > 0 {
			l = 0
			for _, e := range x.AffectedPools {
				l += runtime.Sov(uint64(e))
			}
			n += 1 + runtime.Sov(uint64(l)) + l
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*EventRuntimeUpgradeCancelled)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if len(x.AffectedPools) > 0 {
			var pksize2 int
			for _, num := range x.AffectedPools {
				pksize2 += runtime.Sov(uint64(num))
			}
			i -= pksize2
			j1 := i
			for _, num := range x.AffectedPools {
				for num >= 1<<7 {
					dAtA[j1] = uint8(uint64(num)&0x7f | 0x80)
					num >>= 7
					j1++
				}
				dAtA[j1] = uint8(num)
				j1++
			}
			i = runtime.EncodeVarint(dAtA, i, uint64(pksize2))
			i--
			dAtA[i] = 0x12
		}
		if len(x.Runtime) > 0 {
			i -= len(x.Runtime)
			copy(dAtA[i:], x.Runtime)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Runtime)))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*EventRuntimeUpgradeCancelled)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: EventRuntimeUpgradeCancelled: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: EventRuntimeUpgradeCancelled: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Runtime", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Runtime = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 2:
				if wireType == 0 {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
						}
						if iNdEx >= l {
							return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					x.AffectedPools = append(x.AffectedPools, v)
				} else if wireType == 2 {
					var packedLen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
						}
						if iNdEx >= l {
							return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						packedLen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if packedLen < 0 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
					}
					postIndex := iNdEx + packedLen
					if postIndex < 0 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
					}
					if postIndex > l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					var elementCount int
					var count int
					for _, integer := range dAtA[iNdEx:postIndex] {
						if integer < 128 {
							count++
						}
					}
					elementCount = count
					if elementCount != 0 && len(x.AffectedPools) == 0 {
						x.AffectedPools = make([]uint64, 0, elementCount)
					}
					for iNdEx < postIndex {
						var v uint64
						for shift := uint(0); ; shift += 7 {
							if shift >= 64 {
								return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
							}
							if iNdEx >= l {
								return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
							}
							b := dAtA[iNdEx]
							iNdEx++
							v |= uint64(b&0x7F) << shift
							if b < 0x80 {
								break
							}
						}
						x.AffectedPools = append(x.AffectedPools, v)
					}
				} else {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field AffectedPools", wireType)
				}
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_EventPoolUpdated                     protoreflect.MessageDescriptor
	fd_EventPoolUpdated_id                  protoreflect.FieldDescriptor
	fd_EventPoolUpdated_raw_update_string   protoreflect.FieldDescriptor
	fd_EventPoolUpdated_name                protoreflect.FieldDescriptor
	fd_EventPoolUpdated_runtime             protoreflect.FieldDescriptor
	fd_EventPoolUpdated_logo                protoreflect.FieldDescriptor
	fd_EventPoolUpdated_config              protoreflect.FieldDescriptor
	fd_EventPoolUpdated_upload_interval     protoreflect.FieldDescriptor
	fd_EventPoolUpdated_operating_cost      protoreflect.FieldDescriptor
	fd_EventPoolUpdated_min_delegation      protoreflect.FieldDescriptor
	fd_EventPoolUpdated_max_bundle_size     protoreflect.FieldDescriptor
	fd_EventPoolUpdated_storage_provider_id protoreflect.FieldDescriptor
	fd_EventPoolUpdated_compression_id      protoreflect.FieldDescriptor
)

func init() {
	file_kyve_pool_v1beta1_events_proto_init()
	md_EventPoolUpdated = File_kyve_pool_v1beta1_events_proto.Messages().ByName("EventPoolUpdated")
	fd_EventPoolUpdated_id = md_EventPoolUpdated.Fields().ByName("id")
	fd_EventPoolUpdated_raw_update_string = md_EventPoolUpdated.Fields().ByName("raw_update_string")
	fd_EventPoolUpdated_name = md_EventPoolUpdated.Fields().ByName("name")
	fd_EventPoolUpdated_runtime = md_EventPoolUpdated.Fields().ByName("runtime")
	fd_EventPoolUpdated_logo = md_EventPoolUpdated.Fields().ByName("logo")
	fd_EventPoolUpdated_config = md_EventPoolUpdated.Fields().ByName("config")
	fd_EventPoolUpdated_upload_interval = md_EventPoolUpdated.Fields().ByName("upload_interval")
	fd_EventPoolUpdated_operating_cost = md_EventPoolUpdated.Fields().ByName("operating_cost")
	fd_EventPoolUpdated_min_delegation = md_EventPoolUpdated.Fields().ByName("min_delegation")
	fd_EventPoolUpdated_max_bundle_size = md_EventPoolUpdated.Fields().ByName("max_bundle_size")
	fd_EventPoolUpdated_storage_provider_id = md_EventPoolUpdated.Fields().ByName("storage_provider_id")
	fd_EventPoolUpdated_compression_id = md_EventPoolUpdated.Fields().ByName("compression_id")
}

var _ protoreflect.Message = (*fastReflection_EventPoolUpdated)(nil)

type fastReflection_EventPoolUpdated EventPoolUpdated

func (x *EventPoolUpdated) ProtoReflect() protoreflect.Message {
	return (*fastReflection_EventPoolUpdated)(x)
}

func (x *EventPoolUpdated) slowProtoReflect() protoreflect.Message {
	mi := &file_kyve_pool_v1beta1_events_proto_msgTypes[5]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_EventPoolUpdated_messageType fastReflection_EventPoolUpdated_messageType
var _ protoreflect.MessageType = fastReflection_EventPoolUpdated_messageType{}

type fastReflection_EventPoolUpdated_messageType struct{}

func (x fastReflection_EventPoolUpdated_messageType) Zero() protoreflect.Message {
	return (*fastReflection_EventPoolUpdated)(nil)
}
func (x fastReflection_EventPoolUpdated_messageType) New() protoreflect.Message {
	return new(fastReflection_EventPoolUpdated)
}
func (x fastReflection_EventPoolUpdated_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_EventPoolUpdated
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_EventPoolUpdated) Descriptor() protoreflect.MessageDescriptor {
	return md_EventPoolUpdated
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_EventPoolUpdated) Type() protoreflect.MessageType {
	return _fastReflection_EventPoolUpdated_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_EventPoolUpdated) New() protoreflect.Message {
	return new(fastReflection_EventPoolUpdated)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_EventPoolUpdated) Interface() protoreflect.ProtoMessage {
	return (*EventPoolUpdated)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_EventPoolUpdated) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.Id != uint64(0) {
		value := protoreflect.ValueOfUint64(x.Id)
		if !f(fd_EventPoolUpdated_id, value) {
			return
		}
	}
	if x.RawUpdateString != "" {
		value := protoreflect.ValueOfString(x.RawUpdateString)
		if !f(fd_EventPoolUpdated_raw_update_string, value) {
			return
		}
	}
	if x.Name != "" {
		value := protoreflect.ValueOfString(x.Name)
		if !f(fd_EventPoolUpdated_name, value) {
			return
		}
	}
	if x.Runtime != "" {
		value := protoreflect.ValueOfString(x.Runtime)
		if !f(fd_EventPoolUpdated_runtime, value) {
			return
		}
	}
	if x.Logo != "" {
		value := protoreflect.ValueOfString(x.Logo)
		if !f(fd_EventPoolUpdated_logo, value) {
			return
		}
	}
	if x.Config != "" {
		value := protoreflect.ValueOfString(x.Config)
		if !f(fd_EventPoolUpdated_config, value) {
			return
		}
	}
	if x.UploadInterval != uint64(0) {
		value := protoreflect.ValueOfUint64(x.UploadInterval)
		if !f(fd_EventPoolUpdated_upload_interval, value) {
			return
		}
	}
	if x.OperatingCost != uint64(0) {
		value := protoreflect.ValueOfUint64(x.OperatingCost)
		if !f(fd_EventPoolUpdated_operating_cost, value) {
			return
		}
	}
	if x.MinDelegation != uint64(0) {
		value := protoreflect.ValueOfUint64(x.MinDelegation)
		if !f(fd_EventPoolUpdated_min_delegation, value) {
			return
		}
	}
	if x.MaxBundleSize != uint64(0) {
		value := protoreflect.ValueOfUint64(x.MaxBundleSize)
		if !f(fd_EventPoolUpdated_max_bundle_size, value) {
			return
		}
	}
	if x.StorageProviderId != uint32(0) {
		value := protoreflect.ValueOfUint32(x.StorageProviderId)
		if !f(fd_EventPoolUpdated_storage_provider_id, value) {
			return
		}
	}
	if x.CompressionId != uint32(0) {
		value := protoreflect.ValueOfUint32(x.CompressionId)
		if !f(fd_EventPoolUpdated_compression_id, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_EventPoolUpdated) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "kyve.pool.v1beta1.EventPoolUpdated.id":
		return x.Id != uint64(0)
	case "kyve.pool.v1beta1.EventPoolUpdated.raw_update_string":
		return x.RawUpdateString != ""
	case "kyve.pool.v1beta1.EventPoolUpdated.name":
		return x.Name != ""
	case "kyve.pool.v1beta1.EventPoolUpdated.runtime":
		return x.Runtime != ""
	case "kyve.pool.v1beta1.EventPoolUpdated.logo":
		return x.Logo != ""
	case "kyve.pool.v1beta1.EventPoolUpdated.config":
		return x.Config != ""
	case "kyve.pool.v1beta1.EventPoolUpdated.upload_interval":
		return x.UploadInterval != uint64(0)
	case "kyve.pool.v1beta1.EventPoolUpdated.operating_cost":
		return x.OperatingCost != uint64(0)
	case "kyve.pool.v1beta1.EventPoolUpdated.min_delegation":
		return x.MinDelegation != uint64(0)
	case "kyve.pool.v1beta1.EventPoolUpdated.max_bundle_size":
		return x.MaxBundleSize != uint64(0)
	case "kyve.pool.v1beta1.EventPoolUpdated.storage_provider_id":
		return x.StorageProviderId != uint32(0)
	case "kyve.pool.v1beta1.EventPoolUpdated.compression_id":
		return x.CompressionId != uint32(0)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: kyve.pool.v1beta1.EventPoolUpdated"))
		}
		panic(fmt.Errorf("message kyve.pool.v1beta1.EventPoolUpdated does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventPoolUpdated) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "kyve.pool.v1beta1.EventPoolUpdated.id":
		x.Id = uint64(0)
	case "kyve.pool.v1beta1.EventPoolUpdated.raw_update_string":
		x.RawUpdateString = ""
	case "kyve.pool.v1beta1.EventPoolUpdated.name":
		x.Name = ""
	case "kyve.pool.v1beta1.EventPoolUpdated.runtime":
		x.Runtime = ""
	case "kyve.pool.v1beta1.EventPoolUpdated.logo":
		x.Logo = ""
	case "kyve.pool.v1beta1.EventPoolUpdated.config":
		x.Config = ""
	case "kyve.pool.v1beta1.EventPoolUpdated.upload_interval":
		x.UploadInterval = uint64(0)
	case "kyve.pool.v1beta1.EventPoolUpdated.operating_cost":
		x.OperatingCost = uint64(0)
	case "kyve.pool.v1beta1.EventPoolUpdated.min_delegation":
		x.MinDelegation = uint64(0)
	case "kyve.pool.v1beta1.EventPoolUpdated.max_bundle_size":
		x.MaxBundleSize = uint64(0)
	case "kyve.pool.v1beta1.EventPoolUpdated.storage_provider_id":
		x.StorageProviderId = uint32(0)
	case "kyve.pool.v1beta1.EventPoolUpdated.compression_id":
		x.CompressionId = uint32(0)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: kyve.pool.v1beta1.EventPoolUpdated"))
		}
		panic(fmt.Errorf("message kyve.pool.v1beta1.EventPoolUpdated does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_EventPoolUpdated) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "kyve.pool.v1beta1.EventPoolUpdated.id":
		value := x.Id
		return protoreflect.ValueOfUint64(value)
	case "kyve.pool.v1beta1.EventPoolUpdated.raw_update_string":
		value := x.RawUpdateString
		return protoreflect.ValueOfString(value)
	case "kyve.pool.v1beta1.EventPoolUpdated.name":
		value := x.Name
		return protoreflect.ValueOfString(value)
	case "kyve.pool.v1beta1.EventPoolUpdated.runtime":
		value := x.Runtime
		return protoreflect.ValueOfString(value)
	case "kyve.pool.v1beta1.EventPoolUpdated.logo":
		value := x.Logo
		return protoreflect.ValueOfString(value)
	case "kyve.pool.v1beta1.EventPoolUpdated.config":
		value := x.Config
		return protoreflect.ValueOfString(value)
	case "kyve.pool.v1beta1.EventPoolUpdated.upload_interval":
		value := x.UploadInterval
		return protoreflect.ValueOfUint64(value)
	case "kyve.pool.v1beta1.EventPoolUpdated.operating_cost":
		value := x.OperatingCost
		return protoreflect.ValueOfUint64(value)
	case "kyve.pool.v1beta1.EventPoolUpdated.min_delegation":
		value := x.MinDelegation
		return protoreflect.ValueOfUint64(value)
	case "kyve.pool.v1beta1.EventPoolUpdated.max_bundle_size":
		value := x.MaxBundleSize
		return protoreflect.ValueOfUint64(value)
	case "kyve.pool.v1beta1.EventPoolUpdated.storage_provider_id":
		value := x.StorageProviderId
		return protoreflect.ValueOfUint32(value)
	case "kyve.pool.v1beta1.EventPoolUpdated.compression_id":
		value := x.CompressionId
		return protoreflect.ValueOfUint32(value)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: kyve.pool.v1beta1.EventPoolUpdated"))
		}
		panic(fmt.Errorf("message kyve.pool.v1beta1.EventPoolUpdated does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventPoolUpdated) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "kyve.pool.v1beta1.EventPoolUpdated.id":
		x.Id = value.Uint()
	case "kyve.pool.v1beta1.EventPoolUpdated.raw_update_string":
		x.RawUpdateString = value.Interface().(string)
	case "kyve.pool.v1beta1.EventPoolUpdated.name":
		x.Name = value.Interface().(string)
	case "kyve.pool.v1beta1.EventPoolUpdated.runtime":
		x.Runtime = value.Interface().(string)
	case "kyve.pool.v1beta1.EventPoolUpdated.logo":
		x.Logo = value.Interface().(string)
	case "kyve.pool.v1beta1.EventPoolUpdated.config":
		x.Config = value.Interface().(string)
	case "kyve.pool.v1beta1.EventPoolUpdated.upload_interval":
		x.UploadInterval = value.Uint()
	case "kyve.pool.v1beta1.EventPoolUpdated.operating_cost":
		x.OperatingCost = value.Uint()
	case "kyve.pool.v1beta1.EventPoolUpdated.min_delegation":
		x.MinDelegation = value.Uint()
	case "kyve.pool.v1beta1.EventPoolUpdated.max_bundle_size":
		x.MaxBundleSize = value.Uint()
	case "kyve.pool.v1beta1.EventPoolUpdated.storage_provider_id":
		x.StorageProviderId = uint32(value.Uint())
	case "kyve.pool.v1beta1.EventPoolUpdated.compression_id":
		x.CompressionId = uint32(value.Uint())
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: kyve.pool.v1beta1.EventPoolUpdated"))
		}
		panic(fmt.Errorf("message kyve.pool.v1beta1.EventPoolUpdated does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventPoolUpdated) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "kyve.pool.v1beta1.EventPoolUpdated.id":
		panic(fmt.Errorf("field id of message kyve.pool.v1beta1.EventPoolUpdated is not mutable"))
	case "kyve.pool.v1beta1.EventPoolUpdated.raw_update_string":
		panic(fmt.Errorf("field raw_update_string of message kyve.pool.v1beta1.EventPoolUpdated is not mutable"))
	case "kyve.pool.v1beta1.EventPoolUpdated.name":
		panic(fmt.Errorf("field name of message kyve.pool.v1beta1.EventPoolUpdated is not mutable"))
	case "kyve.pool.v1beta1.EventPoolUpdated.runtime":
		panic(fmt.Errorf("field runtime of message kyve.pool.v1beta1.EventPoolUpdated is not mutable"))
	case "kyve.pool.v1beta1.EventPoolUpdated.logo":
		panic(fmt.Errorf("field logo of message kyve.pool.v1beta1.EventPoolUpdated is not mutable"))
	case "kyve.pool.v1beta1.EventPoolUpdated.config":
		panic(fmt.Errorf("field config of message kyve.pool.v1beta1.EventPoolUpdated is not mutable"))
	case "kyve.pool.v1beta1.EventPoolUpdated.upload_interval":
		panic(fmt.Errorf("field upload_interval of message kyve.pool.v1beta1.EventPoolUpdated is not mutable"))
	case "kyve.pool.v1beta1.EventPoolUpdated.operating_cost":
		panic(fmt.Errorf("field operating_cost of message kyve.pool.v1beta1.EventPoolUpdated is not mutable"))
	case "kyve.pool.v1beta1.EventPoolUpdated.min_delegation":
		panic(fmt.Errorf("field min_delegation of message kyve.pool.v1beta1.EventPoolUpdated is not mutable"))
	case "kyve.pool.v1beta1.EventPoolUpdated.max_bundle_size":
		panic(fmt.Errorf("field max_bundle_size of message kyve.pool.v1beta1.EventPoolUpdated is not mutable"))
	case "kyve.pool.v1beta1.EventPoolUpdated.storage_provider_id":
		panic(fmt.Errorf("field storage_provider_id of message kyve.pool.v1beta1.EventPoolUpdated is not mutable"))
	case "kyve.pool.v1beta1.EventPoolUpdated.compression_id":
		panic(fmt.Errorf("field compression_id of message kyve.pool.v1beta1.EventPoolUpdated is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: kyve.pool.v1beta1.EventPoolUpdated"))
		}
		panic(fmt.Errorf("message kyve.pool.v1beta1.EventPoolUpdated does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_EventPoolUpdated) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "kyve.pool.v1beta1.EventPoolUpdated.id":
		return protoreflect.ValueOfUint64(uint64(0))
	case "kyve.pool.v1beta1.EventPoolUpdated.raw_update_string":
		return protoreflect.ValueOfString("")
	case "kyve.pool.v1beta1.EventPoolUpdated.name":
		return protoreflect.ValueOfString("")
	case "kyve.pool.v1beta1.EventPoolUpdated.runtime":
		return protoreflect.ValueOfString("")
	case "kyve.pool.v1beta1.EventPoolUpdated.logo":
		return protoreflect.ValueOfString("")
	case "kyve.pool.v1beta1.EventPoolUpdated.config":
		return protoreflect.ValueOfString("")
	case "kyve.pool.v1beta1.EventPoolUpdated.upload_interval":
		return protoreflect.ValueOfUint64(uint64(0))
	case "kyve.pool.v1beta1.EventPoolUpdated.operating_cost":
		return protoreflect.ValueOfUint64(uint64(0))
	case "kyve.pool.v1beta1.EventPoolUpdated.min_delegation":
		return protoreflect.ValueOfUint64(uint64(0))
	case "kyve.pool.v1beta1.EventPoolUpdated.max_bundle_size":
		return protoreflect.ValueOfUint64(uint64(0))
	case "kyve.pool.v1beta1.EventPoolUpdated.storage_provider_id":
		return protoreflect.ValueOfUint32(uint32(0))
	case "kyve.pool.v1beta1.EventPoolUpdated.compression_id":
		return protoreflect.ValueOfUint32(uint32(0))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: kyve.pool.v1beta1.EventPoolUpdated"))
		}
		panic(fmt.Errorf("message kyve.pool.v1beta1.EventPoolUpdated does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_EventPoolUpdated) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in kyve.pool.v1beta1.EventPoolUpdated", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_EventPoolUpdated) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventPoolUpdated) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_EventPoolUpdated) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_EventPoolUpdated) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*EventPoolUpdated)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		if x.Id != 0 {
			n += 1 + runtime.Sov(uint64(x.Id))
		}
		l = len(x.RawUpdateString)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.Name)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.Runtime)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.Logo)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.Config)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.UploadInterval != 0 {
			n += 1 + runtime.Sov(uint64(x.UploadInterval))
		}
		if x.OperatingCost != 0 {
			n += 1 + runtime.Sov(uint64(x.OperatingCost))
		}
		if x.MinDelegation != 0 {
			n += 1 + runtime.Sov(uint64(x.MinDelegation))
		}
		if x.MaxBundleSize != 0 {
			n += 1 + runtime.Sov(uint64(x.MaxBundleSize))
		}
		if x.StorageProviderId != 0 {
			n += 1 + runtime.Sov(uint64(x.StorageProviderId))
		}
		if x.CompressionId != 0 {
			n += 1 + runtime.Sov(uint64(x.CompressionId))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*EventPoolUpdated)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if x.CompressionId != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.CompressionId))
			i--
			dAtA[i] = 0x60
		}
		if x.StorageProviderId != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.StorageProviderId))
			i--
			dAtA[i] = 0x58
		}
		if x.MaxBundleSize != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.MaxBundleSize))
			i--
			dAtA[i] = 0x50
		}
		if x.MinDelegation != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.MinDelegation))
			i--
			dAtA[i] = 0x48
		}
		if x.OperatingCost != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.OperatingCost))
			i--
			dAtA[i] = 0x40
		}
		if x.UploadInterval != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.UploadInterval))
			i--
			dAtA[i] = 0x38
		}
		if len(x.Config) > 0 {
			i -= len(x.Config)
			copy(dAtA[i:], x.Config)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Config)))
			i--
			dAtA[i] = 0x32
		}
		if len(x.Logo) > 0 {
			i -= len(x.Logo)
			copy(dAtA[i:], x.Logo)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Logo)))
			i--
			dAtA[i] = 0x2a
		}
		if len(x.Runtime) > 0 {
			i -= len(x.Runtime)
			copy(dAtA[i:], x.Runtime)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Runtime)))
			i--
			dAtA[i] = 0x22
		}
		if len(x.Name) > 0 {
			i -= len(x.Name)
			copy(dAtA[i:], x.Name)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Name)))
			i--
			dAtA[i] = 0x1a
		}
		if len(x.RawUpdateString) > 0 {
			i -= len(x.RawUpdateString)
			copy(dAtA[i:], x.RawUpdateString)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.RawUpdateString)))
			i--
			dAtA[i] = 0x12
		}
		if x.Id != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.Id))
			i--
			dAtA[i] = 0x8
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*EventPoolUpdated)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: EventPoolUpdated: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: EventPoolUpdated: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
				}
				x.Id = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.Id |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field RawUpdateString", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.RawUpdateString = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 3:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Name = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 4:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Runtime", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Runtime = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 5:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Logo", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Logo = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 6:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Config", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Config = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 7:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field UploadInterval", wireType)
				}
				x.UploadInterval = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.UploadInterval |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 8:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field OperatingCost", wireType)
				}
				x.OperatingCost = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.OperatingCost |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 9:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field MinDelegation", wireType)
				}
				x.MinDelegation = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.MinDelegation |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 10:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field MaxBundleSize", wireType)
				}
				x.MaxBundleSize = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.MaxBundleSize |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 11:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field StorageProviderId", wireType)
				}
				x.StorageProviderId = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.StorageProviderId |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 12:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field CompressionId", wireType)
				}
				x.CompressionId = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.CompressionId |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_EventFundPool         protoreflect.MessageDescriptor
	fd_EventFundPool_pool_id protoreflect.FieldDescriptor
	fd_EventFundPool_address protoreflect.FieldDescriptor
	fd_EventFundPool_amount  protoreflect.FieldDescriptor
)

func init() {
	file_kyve_pool_v1beta1_events_proto_init()
	md_EventFundPool = File_kyve_pool_v1beta1_events_proto.Messages().ByName("EventFundPool")
	fd_EventFundPool_pool_id = md_EventFundPool.Fields().ByName("pool_id")
	fd_EventFundPool_address = md_EventFundPool.Fields().ByName("address")
	fd_EventFundPool_amount = md_EventFundPool.Fields().ByName("amount")
}

var _ protoreflect.Message = (*fastReflection_EventFundPool)(nil)

type fastReflection_EventFundPool EventFundPool

func (x *EventFundPool) ProtoReflect() protoreflect.Message {
	return (*fastReflection_EventFundPool)(x)
}

func (x *EventFundPool) slowProtoReflect() protoreflect.Message {
	mi := &file_kyve_pool_v1beta1_events_proto_msgTypes[6]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_EventFundPool_messageType fastReflection_EventFundPool_messageType
var _ protoreflect.MessageType = fastReflection_EventFundPool_messageType{}

type fastReflection_EventFundPool_messageType struct{}

func (x fastReflection_EventFundPool_messageType) Zero() protoreflect.Message {
	return (*fastReflection_EventFundPool)(nil)
}
func (x fastReflection_EventFundPool_messageType) New() protoreflect.Message {
	return new(fastReflection_EventFundPool)
}
func (x fastReflection_EventFundPool_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_EventFundPool
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_EventFundPool) Descriptor() protoreflect.MessageDescriptor {
	return md_EventFundPool
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_EventFundPool) Type() protoreflect.MessageType {
	return _fastReflection_EventFundPool_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_EventFundPool) New() protoreflect.Message {
	return new(fastReflection_EventFundPool)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_EventFundPool) Interface() protoreflect.ProtoMessage {
	return (*EventFundPool)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_EventFundPool) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.PoolId != uint64(0) {
		value := protoreflect.ValueOfUint64(x.PoolId)
		if !f(fd_EventFundPool_pool_id, value) {
			return
		}
	}
	if x.Address != "" {
		value := protoreflect.ValueOfString(x.Address)
		if !f(fd_EventFundPool_address, value) {
			return
		}
	}
	if x.Amount != uint64(0) {
		value := protoreflect.ValueOfUint64(x.Amount)
		if !f(fd_EventFundPool_amount, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_EventFundPool) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "kyve.pool.v1beta1.EventFundPool.pool_id":
		return x.PoolId != uint64(0)
	case "kyve.pool.v1beta1.EventFundPool.address":
		return x.Address != ""
	case "kyve.pool.v1beta1.EventFundPool.amount":
		return x.Amount != uint64(0)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: kyve.pool.v1beta1.EventFundPool"))
		}
		panic(fmt.Errorf("message kyve.pool.v1beta1.EventFundPool does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventFundPool) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "kyve.pool.v1beta1.EventFundPool.pool_id":
		x.PoolId = uint64(0)
	case "kyve.pool.v1beta1.EventFundPool.address":
		x.Address = ""
	case "kyve.pool.v1beta1.EventFundPool.amount":
		x.Amount = uint64(0)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: kyve.pool.v1beta1.EventFundPool"))
		}
		panic(fmt.Errorf("message kyve.pool.v1beta1.EventFundPool does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_EventFundPool) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "kyve.pool.v1beta1.EventFundPool.pool_id":
		value := x.PoolId
		return protoreflect.ValueOfUint64(value)
	case "kyve.pool.v1beta1.EventFundPool.address":
		value := x.Address
		return protoreflect.ValueOfString(value)
	case "kyve.pool.v1beta1.EventFundPool.amount":
		value := x.Amount
		return protoreflect.ValueOfUint64(value)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: kyve.pool.v1beta1.EventFundPool"))
		}
		panic(fmt.Errorf("message kyve.pool.v1beta1.EventFundPool does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventFundPool) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "kyve.pool.v1beta1.EventFundPool.pool_id":
		x.PoolId = value.Uint()
	case "kyve.pool.v1beta1.EventFundPool.address":
		x.Address = value.Interface().(string)
	case "kyve.pool.v1beta1.EventFundPool.amount":
		x.Amount = value.Uint()
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: kyve.pool.v1beta1.EventFundPool"))
		}
		panic(fmt.Errorf("message kyve.pool.v1beta1.EventFundPool does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventFundPool) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "kyve.pool.v1beta1.EventFundPool.pool_id":
		panic(fmt.Errorf("field pool_id of message kyve.pool.v1beta1.EventFundPool is not mutable"))
	case "kyve.pool.v1beta1.EventFundPool.address":
		panic(fmt.Errorf("field address of message kyve.pool.v1beta1.EventFundPool is not mutable"))
	case "kyve.pool.v1beta1.EventFundPool.amount":
		panic(fmt.Errorf("field amount of message kyve.pool.v1beta1.EventFundPool is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: kyve.pool.v1beta1.EventFundPool"))
		}
		panic(fmt.Errorf("message kyve.pool.v1beta1.EventFundPool does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_EventFundPool) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "kyve.pool.v1beta1.EventFundPool.pool_id":
		return protoreflect.ValueOfUint64(uint64(0))
	case "kyve.pool.v1beta1.EventFundPool.address":
		return protoreflect.ValueOfString("")
	case "kyve.pool.v1beta1.EventFundPool.amount":
		return protoreflect.ValueOfUint64(uint64(0))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: kyve.pool.v1beta1.EventFundPool"))
		}
		panic(fmt.Errorf("message kyve.pool.v1beta1.EventFundPool does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_EventFundPool) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in kyve.pool.v1beta1.EventFundPool", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_EventFundPool) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventFundPool) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_EventFundPool) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_EventFundPool) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*EventFundPool)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		if x.PoolId != 0 {
			n += 1 + runtime.Sov(uint64(x.PoolId))
		}
		l = len(x.Address)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.Amount != 0 {
			n += 1 + runtime.Sov(uint64(x.Amount))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*EventFundPool)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if x.Amount != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.Amount))
			i--
			dAtA[i] = 0x18
		}
		if len(x.Address) > 0 {
			i -= len(x.Address)
			copy(dAtA[i:], x.Address)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Address)))
			i--
			dAtA[i] = 0x12
		}
		if x.PoolId != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.PoolId))
			i--
			dAtA[i] = 0x8
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*EventFundPool)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: EventFundPool: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: EventFundPool: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field PoolId", wireType)
				}
				x.PoolId = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.PoolId |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Address = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 3:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
				}
				x.Amount = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.Amount |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_EventDefundPool         protoreflect.MessageDescriptor
	fd_EventDefundPool_pool_id protoreflect.FieldDescriptor
	fd_EventDefundPool_address protoreflect.FieldDescriptor
	fd_EventDefundPool_amount  protoreflect.FieldDescriptor
)

func init() {
	file_kyve_pool_v1beta1_events_proto_init()
	md_EventDefundPool = File_kyve_pool_v1beta1_events_proto.Messages().ByName("EventDefundPool")
	fd_EventDefundPool_pool_id = md_EventDefundPool.Fields().ByName("pool_id")
	fd_EventDefundPool_address = md_EventDefundPool.Fields().ByName("address")
	fd_EventDefundPool_amount = md_EventDefundPool.Fields().ByName("amount")
}

var _ protoreflect.Message = (*fastReflection_EventDefundPool)(nil)

type fastReflection_EventDefundPool EventDefundPool

func (x *EventDefundPool) ProtoReflect() protoreflect.Message {
	return (*fastReflection_EventDefundPool)(x)
}

func (x *EventDefundPool) slowProtoReflect() protoreflect.Message {
	mi := &file_kyve_pool_v1beta1_events_proto_msgTypes[7]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_EventDefundPool_messageType fastReflection_EventDefundPool_messageType
var _ protoreflect.MessageType = fastReflection_EventDefundPool_messageType{}

type fastReflection_EventDefundPool_messageType struct{}

func (x fastReflection_EventDefundPool_messageType) Zero() protoreflect.Message {
	return (*fastReflection_EventDefundPool)(nil)
}
func (x fastReflection_EventDefundPool_messageType) New() protoreflect.Message {
	return new(fastReflection_EventDefundPool)
}
func (x fastReflection_EventDefundPool_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_EventDefundPool
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_EventDefundPool) Descriptor() protoreflect.MessageDescriptor {
	return md_EventDefundPool
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_EventDefundPool) Type() protoreflect.MessageType {
	return _fastReflection_EventDefundPool_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_EventDefundPool) New() protoreflect.Message {
	return new(fastReflection_EventDefundPool)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_EventDefundPool) Interface() protoreflect.ProtoMessage {
	return (*EventDefundPool)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_EventDefundPool) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.PoolId != uint64(0) {
		value := protoreflect.ValueOfUint64(x.PoolId)
		if !f(fd_EventDefundPool_pool_id, value) {
			return
		}
	}
	if x.Address != "" {
		value := protoreflect.ValueOfString(x.Address)
		if !f(fd_EventDefundPool_address, value) {
			return
		}
	}
	if x.Amount != uint64(0) {
		value := protoreflect.ValueOfUint64(x.Amount)
		if !f(fd_EventDefundPool_amount, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_EventDefundPool) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "kyve.pool.v1beta1.EventDefundPool.pool_id":
		return x.PoolId != uint64(0)
	case "kyve.pool.v1beta1.EventDefundPool.address":
		return x.Address != ""
	case "kyve.pool.v1beta1.EventDefundPool.amount":
		return x.Amount != uint64(0)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: kyve.pool.v1beta1.EventDefundPool"))
		}
		panic(fmt.Errorf("message kyve.pool.v1beta1.EventDefundPool does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventDefundPool) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "kyve.pool.v1beta1.EventDefundPool.pool_id":
		x.PoolId = uint64(0)
	case "kyve.pool.v1beta1.EventDefundPool.address":
		x.Address = ""
	case "kyve.pool.v1beta1.EventDefundPool.amount":
		x.Amount = uint64(0)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: kyve.pool.v1beta1.EventDefundPool"))
		}
		panic(fmt.Errorf("message kyve.pool.v1beta1.EventDefundPool does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_EventDefundPool) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "kyve.pool.v1beta1.EventDefundPool.pool_id":
		value := x.PoolId
		return protoreflect.ValueOfUint64(value)
	case "kyve.pool.v1beta1.EventDefundPool.address":
		value := x.Address
		return protoreflect.ValueOfString(value)
	case "kyve.pool.v1beta1.EventDefundPool.amount":
		value := x.Amount
		return protoreflect.ValueOfUint64(value)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: kyve.pool.v1beta1.EventDefundPool"))
		}
		panic(fmt.Errorf("message kyve.pool.v1beta1.EventDefundPool does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventDefundPool) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "kyve.pool.v1beta1.EventDefundPool.pool_id":
		x.PoolId = value.Uint()
	case "kyve.pool.v1beta1.EventDefundPool.address":
		x.Address = value.Interface().(string)
	case "kyve.pool.v1beta1.EventDefundPool.amount":
		x.Amount = value.Uint()
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: kyve.pool.v1beta1.EventDefundPool"))
		}
		panic(fmt.Errorf("message kyve.pool.v1beta1.EventDefundPool does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventDefundPool) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "kyve.pool.v1beta1.EventDefundPool.pool_id":
		panic(fmt.Errorf("field pool_id of message kyve.pool.v1beta1.EventDefundPool is not mutable"))
	case "kyve.pool.v1beta1.EventDefundPool.address":
		panic(fmt.Errorf("field address of message kyve.pool.v1beta1.EventDefundPool is not mutable"))
	case "kyve.pool.v1beta1.EventDefundPool.amount":
		panic(fmt.Errorf("field amount of message kyve.pool.v1beta1.EventDefundPool is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: kyve.pool.v1beta1.EventDefundPool"))
		}
		panic(fmt.Errorf("message kyve.pool.v1beta1.EventDefundPool does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_EventDefundPool) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "kyve.pool.v1beta1.EventDefundPool.pool_id":
		return protoreflect.ValueOfUint64(uint64(0))
	case "kyve.pool.v1beta1.EventDefundPool.address":
		return protoreflect.ValueOfString("")
	case "kyve.pool.v1beta1.EventDefundPool.amount":
		return protoreflect.ValueOfUint64(uint64(0))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: kyve.pool.v1beta1.EventDefundPool"))
		}
		panic(fmt.Errorf("message kyve.pool.v1beta1.EventDefundPool does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_EventDefundPool) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in kyve.pool.v1beta1.EventDefundPool", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_EventDefundPool) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventDefundPool) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_EventDefundPool) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_EventDefundPool) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*EventDefundPool)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		if x.PoolId != 0 {
			n += 1 + runtime.Sov(uint64(x.PoolId))
		}
		l = len(x.Address)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.Amount != 0 {
			n += 1 + runtime.Sov(uint64(x.Amount))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*EventDefundPool)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if x.Amount != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.Amount))
			i--
			dAtA[i] = 0x18
		}
		if len(x.Address) > 0 {
			i -= len(x.Address)
			copy(dAtA[i:], x.Address)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Address)))
			i--
			dAtA[i] = 0x12
		}
		if x.PoolId != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.PoolId))
			i--
			dAtA[i] = 0x8
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*EventDefundPool)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: EventDefundPool: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: EventDefundPool: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field PoolId", wireType)
				}
				x.PoolId = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.PoolId |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Address = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 3:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
				}
				x.Amount = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.Amount |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_EventPoolFundsSlashed         protoreflect.MessageDescriptor
	fd_EventPoolFundsSlashed_pool_id protoreflect.FieldDescriptor
	fd_EventPoolFundsSlashed_address protoreflect.FieldDescriptor
	fd_EventPoolFundsSlashed_amount  protoreflect.FieldDescriptor
)

func init() {
	file_kyve_pool_v1beta1_events_proto_init()
	md_EventPoolFundsSlashed = File_kyve_pool_v1beta1_events_proto.Messages().ByName("EventPoolFundsSlashed")
	fd_EventPoolFundsSlashed_pool_id = md_EventPoolFundsSlashed.Fields().ByName("pool_id")
	fd_EventPoolFundsSlashed_address = md_EventPoolFundsSlashed.Fields().ByName("address")
	fd_EventPoolFundsSlashed_amount = md_EventPoolFundsSlashed.Fields().ByName("amount")
}

var _ protoreflect.Message = (*fastReflection_EventPoolFundsSlashed)(nil)

type fastReflection_EventPoolFundsSlashed EventPoolFundsSlashed

func (x *EventPoolFundsSlashed) ProtoReflect() protoreflect.Message {
	return (*fastReflection_EventPoolFundsSlashed)(x)
}

func (x *EventPoolFundsSlashed) slowProtoReflect() protoreflect.Message {
	mi := &file_kyve_pool_v1beta1_events_proto_msgTypes[8]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_EventPoolFundsSlashed_messageType fastReflection_EventPoolFundsSlashed_messageType
var _ protoreflect.MessageType = fastReflection_EventPoolFundsSlashed_messageType{}

type fastReflection_EventPoolFundsSlashed_messageType struct{}

func (x fastReflection_EventPoolFundsSlashed_messageType) Zero() protoreflect.Message {
	return (*fastReflection_EventPoolFundsSlashed)(nil)
}
func (x fastReflection_EventPoolFundsSlashed_messageType) New() protoreflect.Message {
	return new(fastReflection_EventPoolFundsSlashed)
}
func (x fastReflection_EventPoolFundsSlashed_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_EventPoolFundsSlashed
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_EventPoolFundsSlashed) Descriptor() protoreflect.MessageDescriptor {
	return md_EventPoolFundsSlashed
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_EventPoolFundsSlashed) Type() protoreflect.MessageType {
	return _fastReflection_EventPoolFundsSlashed_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_EventPoolFundsSlashed) New() protoreflect.Message {
	return new(fastReflection_EventPoolFundsSlashed)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_EventPoolFundsSlashed) Interface() protoreflect.ProtoMessage {
	return (*EventPoolFundsSlashed)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_EventPoolFundsSlashed) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.PoolId != uint64(0) {
		value := protoreflect.ValueOfUint64(x.PoolId)
		if !f(fd_EventPoolFundsSlashed_pool_id, value) {
			return
		}
	}
	if x.Address != "" {
		value := protoreflect.ValueOfString(x.Address)
		if !f(fd_EventPoolFundsSlashed_address, value) {
			return
		}
	}
	if x.Amount != uint64(0) {
		value := protoreflect.ValueOfUint64(x.Amount)
		if !f(fd_EventPoolFundsSlashed_amount, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_EventPoolFundsSlashed) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "kyve.pool.v1beta1.EventPoolFundsSlashed.pool_id":
		return x.PoolId != uint64(0)
	case "kyve.pool.v1beta1.EventPoolFundsSlashed.address":
		return x.Address != ""
	case "kyve.pool.v1beta1.EventPoolFundsSlashed.amount":
		return x.Amount != uint64(0)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: kyve.pool.v1beta1.EventPoolFundsSlashed"))
		}
		panic(fmt.Errorf("message kyve.pool.v1beta1.EventPoolFundsSlashed does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventPoolFundsSlashed) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "kyve.pool.v1beta1.EventPoolFundsSlashed.pool_id":
		x.PoolId = uint64(0)
	case "kyve.pool.v1beta1.EventPoolFundsSlashed.address":
		x.Address = ""
	case "kyve.pool.v1beta1.EventPoolFundsSlashed.amount":
		x.Amount = uint64(0)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: kyve.pool.v1beta1.EventPoolFundsSlashed"))
		}
		panic(fmt.Errorf("message kyve.pool.v1beta1.EventPoolFundsSlashed does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_EventPoolFundsSlashed) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "kyve.pool.v1beta1.EventPoolFundsSlashed.pool_id":
		value := x.PoolId
		return protoreflect.ValueOfUint64(value)
	case "kyve.pool.v1beta1.EventPoolFundsSlashed.address":
		value := x.Address
		return protoreflect.ValueOfString(value)
	case "kyve.pool.v1beta1.EventPoolFundsSlashed.amount":
		value := x.Amount
		return protoreflect.ValueOfUint64(value)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: kyve.pool.v1beta1.EventPoolFundsSlashed"))
		}
		panic(fmt.Errorf("message kyve.pool.v1beta1.EventPoolFundsSlashed does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventPoolFundsSlashed) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "kyve.pool.v1beta1.EventPoolFundsSlashed.pool_id":
		x.PoolId = value.Uint()
	case "kyve.pool.v1beta1.EventPoolFundsSlashed.address":
		x.Address = value.Interface().(string)
	case "kyve.pool.v1beta1.EventPoolFundsSlashed.amount":
		x.Amount = value.Uint()
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: kyve.pool.v1beta1.EventPoolFundsSlashed"))
		}
		panic(fmt.Errorf("message kyve.pool.v1beta1.EventPoolFundsSlashed does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventPoolFundsSlashed) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "kyve.pool.v1beta1.EventPoolFundsSlashed.pool_id":
		panic(fmt.Errorf("field pool_id of message kyve.pool.v1beta1.EventPoolFundsSlashed is not mutable"))
	case "kyve.pool.v1beta1.EventPoolFundsSlashed.address":
		panic(fmt.Errorf("field address of message kyve.pool.v1beta1.EventPoolFundsSlashed is not mutable"))
	case "kyve.pool.v1beta1.EventPoolFundsSlashed.amount":
		panic(fmt.Errorf("field amount of message kyve.pool.v1beta1.EventPoolFundsSlashed is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: kyve.pool.v1beta1.EventPoolFundsSlashed"))
		}
		panic(fmt.Errorf("message kyve.pool.v1beta1.EventPoolFundsSlashed does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_EventPoolFundsSlashed) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "kyve.pool.v1beta1.EventPoolFundsSlashed.pool_id":
		return protoreflect.ValueOfUint64(uint64(0))
	case "kyve.pool.v1beta1.EventPoolFundsSlashed.address":
		return protoreflect.ValueOfString("")
	case "kyve.pool.v1beta1.EventPoolFundsSlashed.amount":
		return protoreflect.ValueOfUint64(uint64(0))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: kyve.pool.v1beta1.EventPoolFundsSlashed"))
		}
		panic(fmt.Errorf("message kyve.pool.v1beta1.EventPoolFundsSlashed does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_EventPoolFundsSlashed) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in kyve.pool.v1beta1.EventPoolFundsSlashed", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_EventPoolFundsSlashed) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventPoolFundsSlashed) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_EventPoolFundsSlashed) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_EventPoolFundsSlashed) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*EventPoolFundsSlashed)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		if x.PoolId != 0 {
			n += 1 + runtime.Sov(uint64(x.PoolId))
		}
		l = len(x.Address)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.Amount != 0 {
			n += 1 + runtime.Sov(uint64(x.Amount))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*EventPoolFundsSlashed)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if x.Amount != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.Amount))
			i--
			dAtA[i] = 0x18
		}
		if len(x.Address) > 0 {
			i -= len(x.Address)
			copy(dAtA[i:], x.Address)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Address)))
			i--
			dAtA[i] = 0x12
		}
		if x.PoolId != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.PoolId))
			i--
			dAtA[i] = 0x8
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*EventPoolFundsSlashed)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: EventPoolFundsSlashed: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: EventPoolFundsSlashed: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field PoolId", wireType)
				}
				x.PoolId = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.PoolId |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Address = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 3:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
				}
				x.Amount = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.Amount |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_EventPoolOutOfFunds         protoreflect.MessageDescriptor
	fd_EventPoolOutOfFunds_pool_id protoreflect.FieldDescriptor
)

func init() {
	file_kyve_pool_v1beta1_events_proto_init()
	md_EventPoolOutOfFunds = File_kyve_pool_v1beta1_events_proto.Messages().ByName("EventPoolOutOfFunds")
	fd_EventPoolOutOfFunds_pool_id = md_EventPoolOutOfFunds.Fields().ByName("pool_id")
}

var _ protoreflect.Message = (*fastReflection_EventPoolOutOfFunds)(nil)

type fastReflection_EventPoolOutOfFunds EventPoolOutOfFunds

func (x *EventPoolOutOfFunds) ProtoReflect() protoreflect.Message {
	return (*fastReflection_EventPoolOutOfFunds)(x)
}

func (x *EventPoolOutOfFunds) slowProtoReflect() protoreflect.Message {
	mi := &file_kyve_pool_v1beta1_events_proto_msgTypes[9]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_EventPoolOutOfFunds_messageType fastReflection_EventPoolOutOfFunds_messageType
var _ protoreflect.MessageType = fastReflection_EventPoolOutOfFunds_messageType{}

type fastReflection_EventPoolOutOfFunds_messageType struct{}

func (x fastReflection_EventPoolOutOfFunds_messageType) Zero() protoreflect.Message {
	return (*fastReflection_EventPoolOutOfFunds)(nil)
}
func (x fastReflection_EventPoolOutOfFunds_messageType) New() protoreflect.Message {
	return new(fastReflection_EventPoolOutOfFunds)
}
func (x fastReflection_EventPoolOutOfFunds_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_EventPoolOutOfFunds
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_EventPoolOutOfFunds) Descriptor() protoreflect.MessageDescriptor {
	return md_EventPoolOutOfFunds
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_EventPoolOutOfFunds) Type() protoreflect.MessageType {
	return _fastReflection_EventPoolOutOfFunds_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_EventPoolOutOfFunds) New() protoreflect.Message {
	return new(fastReflection_EventPoolOutOfFunds)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_EventPoolOutOfFunds) Interface() protoreflect.ProtoMessage {
	return (*EventPoolOutOfFunds)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_EventPoolOutOfFunds) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.PoolId != uint64(0) {
		value := protoreflect.ValueOfUint64(x.PoolId)
		if !f(fd_EventPoolOutOfFunds_pool_id, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_EventPoolOutOfFunds) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "kyve.pool.v1beta1.EventPoolOutOfFunds.pool_id":
		return x.PoolId != uint64(0)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: kyve.pool.v1beta1.EventPoolOutOfFunds"))
		}
		panic(fmt.Errorf("message kyve.pool.v1beta1.EventPoolOutOfFunds does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventPoolOutOfFunds) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "kyve.pool.v1beta1.EventPoolOutOfFunds.pool_id":
		x.PoolId = uint64(0)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: kyve.pool.v1beta1.EventPoolOutOfFunds"))
		}
		panic(fmt.Errorf("message kyve.pool.v1beta1.EventPoolOutOfFunds does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_EventPoolOutOfFunds) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "kyve.pool.v1beta1.EventPoolOutOfFunds.pool_id":
		value := x.PoolId
		return protoreflect.ValueOfUint64(value)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: kyve.pool.v1beta1.EventPoolOutOfFunds"))
		}
		panic(fmt.Errorf("message kyve.pool.v1beta1.EventPoolOutOfFunds does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventPoolOutOfFunds) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "kyve.pool.v1beta1.EventPoolOutOfFunds.pool_id":
		x.PoolId = value.Uint()
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: kyve.pool.v1beta1.EventPoolOutOfFunds"))
		}
		panic(fmt.Errorf("message kyve.pool.v1beta1.EventPoolOutOfFunds does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventPoolOutOfFunds) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "kyve.pool.v1beta1.EventPoolOutOfFunds.pool_id":
		panic(fmt.Errorf("field pool_id of message kyve.pool.v1beta1.EventPoolOutOfFunds is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: kyve.pool.v1beta1.EventPoolOutOfFunds"))
		}
		panic(fmt.Errorf("message kyve.pool.v1beta1.EventPoolOutOfFunds does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_EventPoolOutOfFunds) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "kyve.pool.v1beta1.EventPoolOutOfFunds.pool_id":
		return protoreflect.ValueOfUint64(uint64(0))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: kyve.pool.v1beta1.EventPoolOutOfFunds"))
		}
		panic(fmt.Errorf("message kyve.pool.v1beta1.EventPoolOutOfFunds does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_EventPoolOutOfFunds) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in kyve.pool.v1beta1.EventPoolOutOfFunds", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_EventPoolOutOfFunds) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventPoolOutOfFunds) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_EventPoolOutOfFunds) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_EventPoolOutOfFunds) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*EventPoolOutOfFunds)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		if x.PoolId != 0 {
			n += 1 + runtime.Sov(uint64(x.PoolId))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*EventPoolOutOfFunds)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if x.PoolId != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.PoolId))
			i--
			dAtA[i] = 0x8
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*EventPoolOutOfFunds)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: EventPoolOutOfFunds: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: EventPoolOutOfFunds: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field PoolId", wireType)
				}
				x.PoolId = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.PoolId |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.27.0
// 	protoc        (unknown)
// source: kyve/pool/v1beta1/events.proto

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// EventCreatePool ...
// emitted_by: EndBlock(gov)
type EventCreatePool struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// id is the unique ID of the pool.
	Id uint64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	// name is the human readable name of the pool
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	// runtime is the runtime name of the pool
	Runtime string `protobuf:"bytes,3,opt,name=runtime,proto3" json:"runtime,omitempty"`
	// logo is the logo url of the pool
	Logo string `protobuf:"bytes,4,opt,name=logo,proto3" json:"logo,omitempty"`
	// config is either a json stringified config or an
	// external link pointing to the config
	Config string `protobuf:"bytes,5,opt,name=config,proto3" json:"config,omitempty"`
	// start_key is the first key the pool should start
	// indexing
	StartKey string `protobuf:"bytes,6,opt,name=start_key,json=startKey,proto3" json:"start_key,omitempty"`
	// upload_interval is the interval the pool should validate
	// bundles with
	UploadInterval uint64 `protobuf:"varint,7,opt,name=upload_interval,json=uploadInterval,proto3" json:"upload_interval,omitempty"`
	// operating_cost is the fixed cost which gets paid out
	// to every successful uploader
	OperatingCost uint64 `protobuf:"varint,8,opt,name=operating_cost,json=operatingCost,proto3" json:"operating_cost,omitempty"`
	// min_delegation is the minimum amount of $KYVE the pool has
	// to have in order to produce bundles
	MinDelegation uint64 `protobuf:"varint,9,opt,name=min_delegation,json=minDelegation,proto3" json:"min_delegation,omitempty"`
	// max_bundle_size is the max size a data bundle can have
	// (amount of data items)
	MaxBundleSize uint64 `protobuf:"varint,10,opt,name=max_bundle_size,json=maxBundleSize,proto3" json:"max_bundle_size,omitempty"`
	// version is the current version of the protocol nodes
	Version string `protobuf:"bytes,11,opt,name=version,proto3" json:"version,omitempty"`
	// binaries points to the current binaries of the protocol node
	Binaries string `protobuf:"bytes,12,opt,name=binaries,proto3" json:"binaries,omitempty"`
	// storage_provider_id is the unique id of the storage provider
	// the pool is archiving the data on
	StorageProviderId uint32 `protobuf:"varint,13,opt,name=storage_provider_id,json=storageProviderId,proto3" json:"storage_provider_id,omitempty"`
	// compression_id is the unique id of the compression type the bundles
	// get compressed with
	CompressionId uint32 `protobuf:"varint,14,opt,name=compression_id,json=compressionId,proto3" json:"compression_id,omitempty"`
}

func (x *EventCreatePool) Reset() {
	*x = EventCreatePool{}
	if protoimpl.UnsafeEnabled {
		mi := &file_kyve_pool_v1beta1_events_proto_msgTypes[0]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *EventCreatePool) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EventCreatePool) ProtoMessage() {}

// Deprecated: Use EventCreatePool.ProtoReflect.Descriptor instead.
func (*EventCreatePool) Descriptor() ([]byte, []int) {
	return file_kyve_pool_v1beta1_events_proto_rawDescGZIP(), []int{0}
}

func (x *EventCreatePool) GetId() uint64 {
	if x != nil {
		return x.Id
	}
	return 0
}

func (x *EventCreatePool) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *EventCreatePool) GetRuntime() string {
	if x != nil {
		return x.Runtime
	}
	return ""
}

func (x *EventCreatePool) GetLogo() string {
	if x != nil {
		return x.Logo
	}
	return ""
}

func (x *EventCreatePool) GetConfig() string {
	if x != nil {
		return x.Config
	}
	return ""
}

func (x *EventCreatePool) GetStartKey() string {
	if x != nil {
		return x.StartKey
	}
	return ""
}

func (x *EventCreatePool) GetUploadInterval() uint64 {
	if x != nil {
		return x.UploadInterval
	}
	return 0
}

func (x *EventCreatePool) GetOperatingCost() uint64 {
	if x != nil {
		return x.OperatingCost
	}
	return 0
}

func (x *EventCreatePool) GetMinDelegation() uint64 {
	if x != nil {
		return x.MinDelegation
	}
	return 0
}

func (x *EventCreatePool) GetMaxBundleSize() uint64 {
	if x != nil {
		return x.MaxBundleSize
	}
	return 0
}

func (x *EventCreatePool) GetVersion() string {
	if x != nil {
		return x.Version
	}
	return ""
}

func (x *EventCreatePool) GetBinaries() string {
	if x != nil {
		return x.Binaries
	}
	return ""
}

func (x *EventCreatePool) GetStorageProviderId() uint32 {
	if x != nil {
		return x.StorageProviderId
	}
	return 0
}

func (x *EventCreatePool) GetCompressionId() uint32 {
	if x != nil {
		return x.CompressionId
	}
	return 0
}

// EventPoolEnabled ...
// emitted_by: EndBlock(gov)
type EventPoolEnabled struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// id is the unique ID of the affected pool.
	Id uint64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
}

func (x *EventPoolEnabled) Reset() {
	*x = EventPoolEnabled{}
	if protoimpl.UnsafeEnabled {
		mi := &file_kyve_pool_v1beta1_events_proto_msgTypes[1]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *EventPoolEnabled) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EventPoolEnabled) ProtoMessage() {}

// Deprecated: Use EventPoolEnabled.ProtoReflect.Descriptor instead.
func (*EventPoolEnabled) Descriptor() ([]byte, []int) {
	return file_kyve_pool_v1beta1_events_proto_rawDescGZIP(), []int{1}
}

func (x *EventPoolEnabled) GetId() uint64 {
	if x != nil {
		return x.Id
	}
	return 0
}

// EventPoolDisabled ...
// emitted_by: EndBlock(gov)
type EventPoolDisabled struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// id is the unique ID of the affected pool.
	Id uint64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
}

func (x *EventPoolDisabled) Reset() {
	*x = EventPoolDisabled{}
	if protoimpl.UnsafeEnabled {
		mi := &file_kyve_pool_v1beta1_events_proto_msgTypes[2]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *EventPoolDisabled) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EventPoolDisabled) ProtoMessage() {}

// Deprecated: Use EventPoolDisabled.ProtoReflect.Descriptor instead.
func (*EventPoolDisabled) Descriptor() ([]byte, []int) {
	return file_kyve_pool_v1beta1_events_proto_rawDescGZIP(), []int{2}
}

func (x *EventPoolDisabled) GetId() uint64 {
	if x != nil {
		return x.Id
	}
	return 0
}

// EventRuntimeUpgradeScheduled ...
// emitted_by: EndBlock(gov)
type EventRuntimeUpgradeScheduled struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// runtime is the name of the runtime that will be upgraded.
	Runtime string `protobuf:"bytes,1,opt,name=runtime,proto3" json:"runtime,omitempty"`
	// version is the new version that the runtime will be upgraded to.
	Version string `protobuf:"bytes,2,opt,name=version,proto3" json:"version,omitempty"`
	// scheduled_at is the time in UNIX seconds when the upgrade will occur.
	ScheduledAt uint64 `protobuf:"varint,3,opt,name=scheduled_at,json=scheduledAt,proto3" json:"scheduled_at,omitempty"`
	// duration is the amount of seconds the pool will be paused after the
	// scheduled time is reached. This will give node operators time to upgrade
	// their node.
	Duration uint64 `protobuf:"varint,4,opt,name=duration,proto3" json:"duration,omitempty"`
	// binaries contain download links for prebuilt binaries (in JSON format).
	Binaries string `protobuf:"bytes,5,opt,name=binaries,proto3" json:"binaries,omitempty"`
	// affected_pools contains all IDs of pools that will be affected by this runtime upgrade.
	AffectedPools []uint64 `protobuf:"varint,6,rep,packed,name=affected_pools,json=affectedPools,proto3" json:"affected_pools,omitempty"`
}

func (x *EventRuntimeUpgradeScheduled) Reset() {
	*x = EventRuntimeUpgradeScheduled{}
	if protoimpl.UnsafeEnabled {
		mi := &file_kyve_pool_v1beta1_events_proto_msgTypes[3]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *EventRuntimeUpgradeScheduled) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EventRuntimeUpgradeScheduled) ProtoMessage() {}

// Deprecated: Use EventRuntimeUpgradeScheduled.ProtoReflect.Descriptor instead.
func (*EventRuntimeUpgradeScheduled) Descriptor() ([]byte, []int) {
	return file_kyve_pool_v1beta1_events_proto_rawDescGZIP(), []int{3}
}

func (x *EventRuntimeUpgradeScheduled) GetRuntime() string {
	if x != nil {
		return x.Runtime
	}
	return ""
}

func (x *EventRuntimeUpgradeScheduled) GetVersion() string {
	if x != nil {
		return x.Version
	}
	return ""
}

func (x *EventRuntimeUpgradeScheduled) GetScheduledAt() uint64 {
	if x != nil {
		return x.ScheduledAt
	}
	return 0
}

func (x *EventRuntimeUpgradeScheduled) GetDuration() uint64 {
	if x != nil {
		return x.Duration
	}
	return 0
}

func (x *EventRuntimeUpgradeScheduled) GetBinaries() string {
	if x != nil {
		return x.Binaries
	}
	return ""
}

func (x *EventRuntimeUpgradeScheduled) GetAffectedPools() []uint64 {
	if x != nil {
		return x.AffectedPools
	}
	return nil
}

// EventRuntimeUpgradeCancelled ...
// emitted_by: EndBlock(gov)
type EventRuntimeUpgradeCancelled struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// runtime is the name of the runtime that will be upgraded.
	Runtime string `protobuf:"bytes,1,opt,name=runtime,proto3" json:"runtime,omitempty"`
	// affected_pools contains all IDs of pools that are affected by the
	// cancellation of this runtime upgrade.
	AffectedPools []uint64 `protobuf:"varint,2,rep,packed,name=affected_pools,json=affectedPools,proto3" json:"affected_pools,omitempty"`
}

func (x *EventRuntimeUpgradeCancelled) Reset() {
	*x = EventRuntimeUpgradeCancelled{}
	if protoimpl.UnsafeEnabled {
		mi := &file_kyve_pool_v1beta1_events_proto_msgTypes[4]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *EventRuntimeUpgradeCancelled) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EventRuntimeUpgradeCancelled) ProtoMessage() {}

// Deprecated: Use EventRuntimeUpgradeCancelled.ProtoReflect.Descriptor instead.
func (*EventRuntimeUpgradeCancelled) Descriptor() ([]byte, []int) {
	return file_kyve_pool_v1beta1_events_proto_rawDescGZIP(), []int{4}
}

func (x *EventRuntimeUpgradeCancelled) GetRuntime() string {
	if x != nil {
		return x.Runtime
	}
	return ""
}

func (x *EventRuntimeUpgradeCancelled) GetAffectedPools() []uint64 {
	if x != nil {
		return x.AffectedPools
	}
	return nil
}

// EventPoolUpdated ...
// emitted_by: EndBlock(gov)
type EventPoolUpdated struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// id is the unique ID of the pool.
	Id uint64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	// raw update string
	RawUpdateString string `protobuf:"bytes,2,opt,name=raw_update_string,json=rawUpdateString,proto3" json:"raw_update_string,omitempty"`
	// name is the human readable name of the pool
	Name string `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
	// runtime is the runtime name of the pool
	Runtime string `protobuf:"bytes,4,opt,name=runtime,proto3" json:"runtime,omitempty"`
	// logo is the logo url of the pool
	Logo string `protobuf:"bytes,5,opt,name=logo,proto3" json:"logo,omitempty"`
	// config is either a json stringified config or an
	// external link pointing to the config
	Config string `protobuf:"bytes,6,opt,name=config,proto3" json:"config,omitempty"`
	// upload_interval is the interval the pool should validate
	// bundles with
	UploadInterval uint64 `protobuf:"varint,7,opt,name=upload_interval,json=uploadInterval,proto3" json:"upload_interval,omitempty"`
	// operating_cost is the fixed cost which gets paid out
	// to every successful uploader
	OperatingCost uint64 `protobuf:"varint,8,opt,name=operating_cost,json=operatingCost,proto3" json:"operating_cost,omitempty"`
	// min_delegation is the minimum amount of $KYVE the pool has
	// to have in order to produce bundles
	MinDelegation uint64 `protobuf:"varint,9,opt,name=min_delegation,json=minDelegation,proto3" json:"min_delegation,omitempty"`
	// max_bundle_size is the max size a data bundle can have
	// (amount of data items)
	MaxBundleSize uint64 `protobuf:"varint,10,opt,name=max_bundle_size,json=maxBundleSize,proto3" json:"max_bundle_size,omitempty"`
	// storage_provider_id is the unique id of the storage provider
	// the pool is archiving the data on
	StorageProviderId uint32 `protobuf:"varint,11,opt,name=storage_provider_id,json=storageProviderId,proto3" json:"storage_provider_id,omitempty"`
	// compression_id is the unique id of the compression type the bundles
	// get compressed with
	CompressionId uint32 `protobuf:"varint,12,opt,name=compression_id,json=compressionId,proto3" json:"compression_id,omitempty"`
}

func (x *EventPoolUpdated) Reset() {
	*x = EventPoolUpdated{}
	if protoimpl.UnsafeEnabled {
		mi := &file_kyve_pool_v1beta1_events_proto_msgTypes[5]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *EventPoolUpdated) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EventPoolUpdated) ProtoMessage() {}

// Deprecated: Use EventPoolUpdated.ProtoReflect.Descriptor instead.
func (*EventPoolUpdated) Descriptor() ([]byte, []int) {
	return file_kyve_pool_v1beta1_events_proto_rawDescGZIP(), []int{5}
}

func (x *EventPoolUpdated) GetId() uint64 {
	if x != nil {
		return x.Id
	}
	return 0
}

func (x *EventPoolUpdated) GetRawUpdateString() string {
	if x != nil {
		return x.RawUpdateString
	}
	return ""
}

func (x *EventPoolUpdated) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *EventPoolUpdated) GetRuntime() string {
	if x != nil {
		return x.Runtime
	}
	return ""
}

func (x *EventPoolUpdated) GetLogo() string {
	if x != nil {
		return x.Logo
	}
	return ""
}

func (x *EventPoolUpdated) GetConfig() string {
	if x != nil {
		return x.Config
	}
	return ""
}

func (x *EventPoolUpdated) GetUploadInterval() uint64 {
	if x != nil {
		return x.UploadInterval
	}
	return 0
}

func (x *EventPoolUpdated) GetOperatingCost() uint64 {
	if x != nil {
		return x.OperatingCost
	}
	return 0
}

func (x *EventPoolUpdated) GetMinDelegation() uint64 {
	if x != nil {
		return x.MinDelegation
	}
	return 0
}

func (x *EventPoolUpdated) GetMaxBundleSize() uint64 {
	if x != nil {
		return x.MaxBundleSize
	}
	return 0
}

func (x *EventPoolUpdated) GetStorageProviderId() uint32 {
	if x != nil {
		return x.StorageProviderId
	}
	return 0
}

func (x *EventPoolUpdated) GetCompressionId() uint32 {
	if x != nil {
		return x.CompressionId
	}
	return 0
}

// EventFundPool is an event emitted when a pool is funded.
// emitted_by: MsgFundPool
type EventFundPool struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// pool_id is the unique ID of the pool.
	PoolId uint64 `protobuf:"varint,1,opt,name=pool_id,json=poolId,proto3" json:"pool_id,omitempty"`
	// address is the account address of the pool funder.
	Address string `protobuf:"bytes,2,opt,name=address,proto3" json:"address,omitempty"`
	// amount is the amount in ukyve the funder has funded
	Amount uint64 `protobuf:"varint,3,opt,name=amount,proto3" json:"amount,omitempty"`
}

func (x *EventFundPool) Reset() {
	*x = EventFundPool{}
	if protoimpl.UnsafeEnabled {
		mi := &file_kyve_pool_v1beta1_events_proto_msgTypes[6]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *EventFundPool) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EventFundPool) ProtoMessage() {}

// Deprecated: Use EventFundPool.ProtoReflect.Descriptor instead.
func (*EventFundPool) Descriptor() ([]byte, []int) {
	return file_kyve_pool_v1beta1_events_proto_rawDescGZIP(), []int{6}
}

func (x *EventFundPool) GetPoolId() uint64 {
	if x != nil {
		return x.PoolId
	}
	return 0
}

func (x *EventFundPool) GetAddress() string {
	if x != nil {
		return x.Address
	}
	return ""
}

func (x *EventFundPool) GetAmount() uint64 {
	if x != nil {
		return x.Amount
	}
	return 0
}

// EventDefundPool is an event emitted when a pool is defunded.
// emitted_by: MsgDefundPool
type EventDefundPool struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// pool_id is the unique ID of the pool.
	PoolId uint64 `protobuf:"varint,1,opt,name=pool_id,json=poolId,proto3" json:"pool_id,omitempty"`
	// address is the account address of the pool funder.
	Address string `protobuf:"bytes,2,opt,name=address,proto3" json:"address,omitempty"`
	// amount is the amount in ukyve the funder has defunded
	Amount uint64 `protobuf:"varint,3,opt,name=amount,proto3" json:"amount,omitempty"`
}

func (x *EventDefundPool) Reset() {
	*x = EventDefundPool{}
	if protoimpl.UnsafeEnabled {
		mi := &file_kyve_pool_v1beta1_events_proto_msgTypes[7]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *EventDefundPool) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EventDefundPool) ProtoMessage() {}

// Deprecated: Use EventDefundPool.ProtoReflect.Descriptor instead.
func (*EventDefundPool) Descriptor() ([]byte, []int) {
	return file_kyve_pool_v1beta1_events_proto_rawDescGZIP(), []int{7}
}

func (x *EventDefundPool) GetPoolId() uint64 {
	if x != nil {
		return x.PoolId
	}
	return 0
}

func (x *EventDefundPool) GetAddress() string {
	if x != nil {
		return x.Address
	}
	return ""
}

func (x *EventDefundPool) GetAmount() uint64 {
	if x != nil {
		return x.Amount
	}
	return 0
}

// EventDefundPool is an event emitted when a pool is defunded.
// emitted_by: MsgSubmitBundleProposal
type EventPoolFundsSlashed struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// pool_id is the unique ID of the pool.
	PoolId uint64 `protobuf:"varint,1,opt,name=pool_id,json=poolId,proto3" json:"pool_id,omitempty"`
	// address is the account address of the pool funder.
	Address string `protobuf:"bytes,2,opt,name=address,proto3" json:"address,omitempty"`
	// amount is the amount in ukyve the validator has lost due to the slash
	Amount uint64 `protobuf:"varint,3,opt,name=amount,proto3" json:"amount,omitempty"`
}

func (x *EventPoolFundsSlashed) Reset() {
	*x = EventPoolFundsSlashed{}
	if protoimpl.UnsafeEnabled {
		mi := &file_kyve_pool_v1beta1_events_proto_msgTypes[8]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *EventPoolFundsSlashed) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EventPoolFundsSlashed) ProtoMessage() {}

// Deprecated: Use EventPoolFundsSlashed.ProtoReflect.Descriptor instead.
func (*EventPoolFundsSlashed) Descriptor() ([]byte, []int) {
	return file_kyve_pool_v1beta1_events_proto_rawDescGZIP(), []int{8}
}

func (x *EventPoolFundsSlashed) GetPoolId() uint64 {
	if x != nil {
		return x.PoolId
	}
	return 0
}

func (x *EventPoolFundsSlashed) GetAddress() string {
	if x != nil {
		return x.Address
	}
	return ""
}

func (x *EventPoolFundsSlashed) GetAmount() uint64 {
	if x != nil {
		return x.Amount
	}
	return 0
}

// EventPoolOutOfFunds is an event emitted when a pool has run out of funds
// emitted_by: MsgSubmitBundleProposal
type EventPoolOutOfFunds struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// pool_id is the unique ID of the pool.
	PoolId uint64 `protobuf:"varint,1,opt,name=pool_id,json=poolId,proto3" json:"pool_id,omitempty"`
}

func (x *EventPoolOutOfFunds) Reset() {
	*x = EventPoolOutOfFunds{}
	if protoimpl.UnsafeEnabled {
		mi := &file_kyve_pool_v1beta1_events_proto_msgTypes[9]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *EventPoolOutOfFunds) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EventPoolOutOfFunds) ProtoMessage() {}

// Deprecated: Use EventPoolOutOfFunds.ProtoReflect.Descriptor instead.
func (*EventPoolOutOfFunds) Descriptor() ([]byte, []int) {
	return file_kyve_pool_v1beta1_events_proto_rawDescGZIP(), []int{9}
}

func (x *EventPoolOutOfFunds) GetPoolId() uint64 {
	if x != nil {
		return x.PoolId
	}
	return 0
}

var File_kyve_pool_v1beta1_events_proto protoreflect.FileDescriptor

var file_kyve_pool_v1beta1_events_proto_rawDesc = []byte{
	0x0a, 0x1e, 0x6b, 0x79, 0x76, 0x65, 0x2f, 0x70, 0x6f, 0x6f, 0x6c, 0x2f, 0x76, 0x31, 0x62, 0x65,
	0x74, 0x61, 0x31, 0x2f, 0x65, 0x76, 0x65, 0x6e, 0x74, 0x73, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f,
	0x12, 0x11, 0x6b, 0x79, 0x76, 0x65, 0x2e, 0x70, 0x6f, 0x6f, 0x6c, 0x2e, 0x76, 0x31, 0x62, 0x65,
	0x74, 0x61, 0x31, 0x22, 0xc4, 0x03, 0x0a, 0x0f, 0x45, 0x76, 0x65, 0x6e, 0x74, 0x43, 0x72, 0x65,
	0x61, 0x74, 0x65, 0x50, 0x6f, 0x6f, 0x6c, 0x12, 0x0e, 0x0a, 0x02, 0x69, 0x64, 0x18, 0x01, 0x20,
	0x01, 0x28, 0x04, 0x52, 0x02, 0x69, 0x64, 0x12, 0x12, 0x0a, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x18,
	0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x12, 0x18, 0x0a, 0x07, 0x72,
	0x75, 0x6e, 0x74, 0x69, 0x6d, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x72, 0x75,
	0x6e, 0x74, 0x69, 0x6d, 0x65, 0x12, 0x12, 0x0a, 0x04, 0x6c, 0x6f, 0x67, 0x6f, 0x18, 0x04, 0x20,
	0x01, 0x28, 0x09, 0x52, 0x04, 0x6c, 0x6f, 0x67, 0x6f, 0x12, 0x16, 0x0a, 0x06, 0x63, 0x6f, 0x6e,
	0x66, 0x69, 0x67, 0x18, 0x05, 0x20, 0x01, 0x28, 0x09, 0x52, 0x06, 0x63, 0x6f, 0x6e, 0x66, 0x69,
	0x67, 0x12, 0x1b, 0x0a, 0x09, 0x73, 0x74, 0x61, 0x72, 0x74, 0x5f, 0x6b, 0x65, 0x79, 0x18, 0x06,
	0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x73, 0x74, 0x61, 0x72, 0x74, 0x4b, 0x65, 0x79, 0x12, 0x27,
	0x0a, 0x0f, 0x75, 0x70, 0x6c, 0x6f, 0x61, 0x64, 0x5f, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x76, 0x61,
	0x6c, 0x18, 0x07, 0x20, 0x01, 0x28, 0x04, 0x52, 0x0e, 0x75, 0x70, 0x6c, 0x6f, 0x61, 0x64, 0x49,
	0x6e, 0x74, 0x65, 0x72, 0x76, 0x61, 0x6c, 0x12, 0x25, 0x0a, 0x0e, 0x6f, 0x70, 0x65, 0x72, 0x61,
	0x74, 0x69, 0x6e, 0x67, 0x5f, 0x63, 0x6f, 0x73, 0x74, 0x18, 0x08, 0x20, 0x01, 0x28, 0x04, 0x52,
	0x0d, 0x6f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6e, 0x67, 0x43, 0x6f, 0x73, 0x74, 0x12, 0x25,
	0x0a, 0x0e, 0x6d, 0x69, 0x6e, 0x5f, 0x64, 0x65, 0x6c, 0x65, 0x67, 0x61, 0x74, 0x69, 0x6f, 0x6e,
	0x18, 0x09, 0x20, 0x01, 0x28, 0x04, 0x52, 0x0d, 0x6d, 0x69, 0x6e, 0x44, 0x65, 0x6c, 0x65, 0x67,
	0x61, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x26, 0x0a, 0x0f, 0x6d, 0x61, 0x78, 0x5f, 0x62, 0x75, 0x6e,
	0x64, 0x6c, 0x65, 0x5f, 0x73, 0x69, 0x7a, 0x65, 0x18, 0x0a, 0x20, 0x01, 0x28, 0x04, 0x52, 0x0d,
	0x6d, 0x61, 0x78, 0x42, 0x75, 0x6e, 0x64, 0x6c, 0x65, 0x53, 0x69, 0x7a, 0x65, 0x12, 0x18, 0x0a,
	0x07, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x18, 0x0b, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07,
	0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x12, 0x1a, 0x0a, 0x08, 0x62, 0x69, 0x6e, 0x61, 0x72,
	0x69, 0x65, 0x73, 0x18, 0x0c, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x62, 0x69, 0x6e, 0x61, 0x72,
	0x69, 0x65, 0x73, 0x12, 0x2e, 0x0a, 0x13, 0x73, 0x74, 0x6f, 0x72, 0x61, 0x67, 0x65, 0x5f, 0x70,
	0x72, 0x6f, 0x76, 0x69, 0x64, 0x65, 0x72, 0x5f, 0x69, 0x64, 0x18, 0x0d, 0x20, 0x01, 0x28, 0x0d,
	0x52, 0x11, 0x73, 0x74, 0x6f, 0x72, 0x61, 0x67, 0x65, 0x50, 0x72, 0x6f, 0x76, 0x69, 0x64, 0x65,
	0x72, 0x49, 0x64, 0x12, 0x25, 0x0a, 0x0e, 0x63, 0x6f, 0x6d, 0x70, 0x72, 0x65, 0x73, 0x73, 0x69,
	0x6f, 0x6e, 0x5f, 0x69, 0x64, 0x18, 0x0e, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x0d, 0x63, 0x6f, 0x6d,
	0x70, 0x72, 0x65, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x49, 0x64, 0x22, 0x22, 0x0a, 0x10, 0x45, 0x76,
	0x65, 0x6e, 0x74, 0x50, 0x6f, 0x6f, 0x6c, 0x45, 0x6e, 0x61, 0x62, 0x6c, 0x65, 0x64, 0x12, 0x0e,
	0x0a, 0x02, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x04, 0x52, 0x02, 0x69, 0x64, 0x22, 0x23,
	0x0a, 0x11, 0x45, 0x76, 0x65, 0x6e, 0x74, 0x50, 0x6f, 0x6f, 0x6c, 0x44, 0x69, 0x73, 0x61, 0x62,
	0x6c, 0x65, 0x64, 0x12, 0x0e, 0x0a, 0x02, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x04, 0x52,
	0x02, 0x69, 0x64, 0x22, 0xd4, 0x01, 0x0a, 0x1c, 0x45, 0x76, 0x65, 0x6e, 0x74, 0x52, 0x75, 0x6e,
	0x74, 0x69, 0x6d, 0x65, 0x55, 0x70, 0x67, 0x72, 0x61, 0x64, 0x65, 0x53, 0x63, 0x68, 0x65, 0x64,
	0x75, 0x6c, 0x65, 0x64, 0x12, 0x18, 0x0a, 0x07, 0x72, 0x75, 0x6e, 0x74, 0x69, 0x6d, 0x65, 0x18,
	0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x72, 0x75, 0x6e, 0x74, 0x69, 0x6d, 0x65, 0x12, 0x18,
	0x0a, 0x07, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52,
	0x07, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x12, 0x21, 0x0a, 0x0c, 0x73, 0x63, 0x68, 0x65,
	0x64, 0x75, 0x6c, 0x65, 0x64, 0x5f, 0x61, 0x74, 0x18, 0x03, 0x20, 0x01, 0x28, 0x04, 0x52, 0x0b,
	0x73, 0x63, 0x68, 0x65, 0x64, 0x75, 0x6c, 0x65, 0x64, 0x41, 0x74, 0x12, 0x1a, 0x0a, 0x08, 0x64,
	0x75, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x04, 0x20, 0x01, 0x28, 0x04, 0x52, 0x08, 0x64,
	0x75, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x1a, 0x0a, 0x08, 0x62, 0x69, 0x6e, 0x61, 0x72,
	0x69, 0x65, 0x73, 0x18, 0x05, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x62, 0x69, 0x6e, 0x61, 0x72,
	0x69, 0x65, 0x73, 0x12, 0x25, 0x0a, 0x0e, 0x61, 0x66, 0x66, 0x65, 0x63, 0x74, 0x65, 0x64, 0x5f,
	0x70, 0x6f, 0x6f, 0x6c, 0x73, 0x18, 0x06, 0x20, 0x03, 0x28, 0x04, 0x52, 0x0d, 0x61, 0x66, 0x66,
	0x65, 0x63, 0x74, 0x65, 0x64, 0x50, 0x6f, 0x6f, 0x6c, 0x73, 0x22, 0x5f, 0x0a, 0x1c, 0x45, 0x76,
	0x65, 0x6e, 0x74, 0x52, 0x75, 0x6e, 0x74, 0x69, 0x6d, 0x65, 0x55, 0x70, 0x67, 0x72, 0x61, 0x64,
	0x65, 0x43, 0x61, 0x6e, 0x63, 0x65, 0x6c, 0x6c, 0x65, 0x64, 0x12, 0x18, 0x0a, 0x07, 0x72, 0x75,
	0x6e, 0x74, 0x69, 0x6d, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x72, 0x75, 0x6e,
	0x74, 0x69, 0x6d, 0x65, 0x12, 0x25, 0x0a, 0x0e, 0x61, 0x66, 0x66, 0x65, 0x63, 0x74, 0x65, 0x64,
	0x5f, 0x70, 0x6f, 0x6f, 0x6c, 0x73, 0x18, 0x02, 0x20, 0x03, 0x28, 0x04, 0x52, 0x0d, 0x61, 0x66,
	0x66, 0x65, 0x63, 0x74, 0x65, 0x64, 0x50, 0x6f, 0x6f, 0x6c, 0x73, 0x22, 0x9e, 0x03, 0x0a, 0x10,
	0x45, 0x76, 0x65, 0x6e, 0x74, 0x50, 0x6f, 0x6f, 0x6c, 0x55, 0x70, 0x64, 0x61, 0x74, 0x65, 0x64,
	0x12, 0x0e, 0x0a, 0x02, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x04, 0x52, 0x02, 0x69, 0x64,
	0x12, 0x2a, 0x0a, 0x11, 0x72, 0x61, 0x77, 0x5f, 0x75, 0x70, 0x64, 0x61, 0x74, 0x65, 0x5f, 0x73,
	0x74, 0x72, 0x69, 0x6e, 0x67, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0f, 0x72, 0x61, 0x77,
	0x55, 0x70, 0x64, 0x61, 0x74, 0x65, 0x53, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x12, 0x12, 0x0a, 0x04,
	0x6e, 0x61, 0x6d, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x6e, 0x61, 0x6d, 0x65,
	0x12, 0x18, 0x0a, 0x07, 0x72, 0x75, 0x6e, 0x74, 0x69, 0x6d, 0x65, 0x18, 0x04, 0x20, 0x01, 0x28,
	0x09, 0x52, 0x07, 0x72, 0x75, 0x6e, 0x74, 0x69, 0x6d, 0x65, 0x12, 0x12, 0x0a, 0x04, 0x6c, 0x6f,
	0x67, 0x6f, 0x18, 0x05, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x6c, 0x6f, 0x67, 0x6f, 0x12, 0x16,
	0x0a, 0x06, 0x63, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x18, 0x06, 0x20, 0x01, 0x28, 0x09, 0x52, 0x06,
	0x63, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x12, 0x27, 0x0a, 0x0f, 0x75, 0x70, 0x6c, 0x6f, 0x61, 0x64,
	0x5f, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x76, 0x61, 0x6c, 0x18, 0x07, 0x20, 0x01, 0x28, 0x04, 0x52,
	0x0e, 0x75, 0x70, 0x6c, 0x6f, 0x61, 0x64, 0x49, 0x6e, 0x74, 0x65, 0x72, 0x76, 0x61, 0x6c, 0x12,
	0x25, 0x0a, 0x0e, 0x6f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6e, 0x67, 0x5f, 0x63, 0x6f, 0x73,
	0x74, 0x18, 0x08, 0x20, 0x01, 0x28, 0x04, 0x52, 0x0d, 0x6f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69,
	0x6e, 0x67, 0x43, 0x6f, 0x73, 0x74, 0x12, 0x25, 0x0a, 0x0e, 0x6d, 0x69, 0x6e, 0x5f, 0x64, 0x65,
	0x6c, 0x65, 0x67, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x09, 0x20, 0x01, 0x28, 0x04, 0x52, 0x0d,
	0x6d, 0x69, 0x6e, 0x44, 0x65, 0x6c, 0x65, 0x67, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x26, 0x0a,
	0x0f, 0x6d, 0x61, 0x78, 0x5f, 0x62, 0x75, 0x6e, 0x64, 0x6c, 0x65, 0x5f, 0x73, 0x69, 0x7a, 0x65,
	0x18, 0x0a, 0x20, 0x01, 0x28, 0x04, 0x52, 0x0d, 0x6d, 0x61, 0x78, 0x42, 0x75, 0x6e, 0x64, 0x6c,
	0x65, 0x53, 0x69, 0x7a, 0x65, 0x12, 0x2e, 0x0a, 0x13, 0x73, 0x74, 0x6f, 0x72, 0x61, 0x67, 0x65,
	0x5f, 0x70, 0x72, 0x6f, 0x76, 0x69, 0x64, 0x65, 0x72, 0x5f, 0x69, 0x64, 0x18, 0x0b, 0x20, 0x01,
	0x28, 0x0d, 0x52, 0x11, 0x73, 0x74, 0x6f, 0x72, 0x61, 0x67, 0x65, 0x50, 0x72, 0x6f, 0x76, 0x69,
	0x64, 0x65, 0x72, 0x49, 0x64, 0x12, 0x25, 0x0a, 0x0e, 0x63, 0x6f, 0x6d, 0x70, 0x72, 0x65, 0x73,
	0x73, 0x69, 0x6f, 0x6e, 0x5f, 0x69, 0x64, 0x18, 0x0c, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x0d, 0x63,
	0x6f, 0x6d, 0x70, 0x72, 0x65, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x49, 0x64, 0x22, 0x5a, 0x0a, 0x0d,
	0x45, 0x76, 0x65, 0x6e, 0x74, 0x46, 0x75, 0x6e, 0x64, 0x50, 0x6f, 0x6f, 0x6c, 0x12, 0x17, 0x0a,
	0x07, 0x70, 0x6f, 0x6f, 0x6c, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x04, 0x52, 0x06,
	0x70, 0x6f, 0x6f, 0x6c, 0x49, 0x64, 0x12, 0x18, 0x0a, 0x07, 0x61, 0x64, 0x64, 0x72, 0x65, 0x73,
	0x73, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x61, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73,
	0x12, 0x16, 0x0a, 0x06, 0x61, 0x6d, 0x6f, 0x75, 0x6e, 0x74, 0x18, 0x03, 0x20, 0x01, 0x28, 0x04,
	0x52, 0x06, 0x61, 0x6d, 0x6f, 0x75, 0x6e, 0x74, 0x22, 0x5c, 0x0a, 0x0f, 0x45, 0x76, 0x65, 0x6e,
	0x74, 0x44, 0x65, 0x66, 0x75, 0x6e, 0x64, 0x50, 0x6f, 0x6f, 0x6c, 0x12, 0x17, 0x0a, 0x07, 0x70,
	0x6f, 0x6f, 0x6c, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x04, 0x52, 0x06, 0x70, 0x6f,
	0x6f, 0x6c, 0x49, 0x64, 0x12, 0x18, 0x0a, 0x07, 0x61, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x18,
	0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x61, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x12, 0x16,
	0x0a, 0x06, 0x61, 0x6d, 0x6f, 0x75, 0x6e, 0x74, 0x18, 0x03, 0x20, 0x01, 0x28, 0x04, 0x52, 0x06,
	0x61, 0x6d, 0x6f, 0x75, 0x6e, 0x74, 0x22, 0x62, 0x0a, 0x15, 0x45, 0x76, 0x65, 0x6e, 0x74, 0x50,
	0x6f, 0x6f, 0x6c, 0x46, 0x75, 0x6e, 0x64, 0x73, 0x53, 0x6c, 0x61, 0x73, 0x68, 0x65, 0x64, 0x12,
	0x17, 0x0a, 0x07, 0x70, 0x6f, 0x6f, 0x6c, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x04,
	0x52, 0x06, 0x70, 0x6f, 0x6f, 0x6c, 0x49, 0x64, 0x12, 0x18, 0x0a, 0x07, 0x61, 0x64, 0x64, 0x72,
	0x65, 0x73, 0x73, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x61, 0x64, 0x64, 0x72, 0x65,
	0x73, 0x73, 0x12, 0x16, 0x0a, 0x06, 0x61, 0x6d, 0x6f, 0x75, 0x6e, 0x74, 0x18, 0x03, 0x20, 0x01,
	0x28, 0x04, 0x52, 0x06, 0x61, 0x6d, 0x6f, 0x75, 0x6e, 0x74, 0x22, 0x2e, 0x0a, 0x13, 0x45, 0x76,
	0x65, 0x6e, 0x74, 0x50, 0x6f, 0x6f, 0x6c, 0x4f, 0x75, 0x74, 0x4f, 0x66, 0x46, 0x75, 0x6e, 0x64,
	0x73, 0x12, 0x17, 0x0a, 0x07, 0x70, 0x6f, 0x6f, 0x6c, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01,
	0x28, 0x04, 0x52, 0x06, 0x70, 0x6f, 0x6f, 0x6c, 0x49, 0x64, 0x42, 0xcd, 0x01, 0x0a, 0x15, 0x63,
	0x6f, 0x6d, 0x2e, 0x6b, 0x79, 0x76, 0x65, 0x2e, 0x70, 0x6f, 0x6f, 0x6c, 0x2e, 0x76, 0x31, 0x62,
	0x65, 0x74, 0x61, 0x31, 0x42, 0x0b, 0x45, 0x76, 0x65, 0x6e, 0x74, 0x73, 0x50, 0x72, 0x6f, 0x74,
	0x6f, 0x50, 0x01, 0x5a, 0x41, 0x67, 0x69, 0x74, 0x68, 0x75, 0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f,
	0x4b, 0x59, 0x56, 0x45, 0x4e, 0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b, 0x2f, 0x63, 0x68, 0x61, 0x69,
	0x6e, 0x2f, 0x70, 0x75, 0x6c, 0x73, 0x61, 0x72, 0x2f, 0x6b, 0x79, 0x76, 0x65, 0x2f, 0x70, 0x6f,
	0x6f, 0x6c, 0x2f, 0x76, 0x31, 0x62, 0x65, 0x74, 0x61, 0x31, 0x3b, 0x70, 0x6f, 0x6f, 0x6c, 0x76,
	0x31, 0x62, 0x65, 0x74, 0x61, 0x31, 0xa2, 0x02, 0x03, 0x4b, 0x50, 0x58, 0xaa, 0x02, 0x11, 0x4b,
	0x79, 0x76, 0x65, 0x2e, 0x50, 0x6f, 0x6f, 0x6c, 0x2e, 0x56, 0x31, 0x62, 0x65, 0x74, 0x61, 0x31,
	0xca, 0x02, 0x11, 0x4b, 0x79, 0x76, 0x65, 0x5c, 0x50, 0x6f, 0x6f, 0x6c, 0x5c, 0x56, 0x31, 0x62,
	0x65, 0x74, 0x61, 0x31, 0xe2, 0x02, 0x1d, 0x4b, 0x79, 0x76, 0x65, 0x5c, 0x50, 0x6f, 0x6f, 0x6c,
	0x5c, 0x56, 0x31, 0x62, 0x65, 0x74, 0x61, 0x31, 0x5c, 0x47, 0x50, 0x42, 0x4d, 0x65, 0x74, 0x61,
	0x64, 0x61, 0x74, 0x61, 0xea, 0x02, 0x13, 0x4b, 0x79, 0x76, 0x65, 0x3a, 0x3a, 0x50, 0x6f, 0x6f,
	0x6c, 0x3a, 0x3a, 0x56, 0x31, 0x62, 0x65, 0x74, 0x61, 0x31, 0x62, 0x06, 0x70, 0x72, 0x6f, 0x74,
	0x6f, 0x33,
}

var (
	file_kyve_pool_v1beta1_events_proto_rawDescOnce sync.Once
	file_kyve_pool_v1beta1_events_proto_rawDescData = file_kyve_pool_v1beta1_events_proto_rawDesc
)

func file_kyve_pool_v1beta1_events_proto_rawDescGZIP() []byte {
	file_kyve_pool_v1beta1_events_proto_rawDescOnce.Do(func() {
		file_kyve_pool_v1beta1_events_proto_rawDescData = protoimpl.X.CompressGZIP(file_kyve_pool_v1beta1_events_proto_rawDescData)
	})
	return file_kyve_pool_v1beta1_events_proto_rawDescData
}

var file_kyve_pool_v1beta1_events_proto_msgTypes = make([]protoimpl.MessageInfo, 10)
var file_kyve_pool_v1beta1_events_proto_goTypes = []interface{}{
	(*EventCreatePool)(nil),              // 0: kyve.pool.v1beta1.EventCreatePool
	(*EventPoolEnabled)(nil),             // 1: kyve.pool.v1beta1.EventPoolEnabled
	(*EventPoolDisabled)(nil),            // 2: kyve.pool.v1beta1.EventPoolDisabled
	(*EventRuntimeUpgradeScheduled)(nil), // 3: kyve.pool.v1beta1.EventRuntimeUpgradeScheduled
	(*EventRuntimeUpgradeCancelled)(nil), // 4: kyve.pool.v1beta1.EventRuntimeUpgradeCancelled
	(*EventPoolUpdated)(nil),             // 5: kyve.pool.v1beta1.EventPoolUpdated
	(*EventFundPool)(nil),                // 6: kyve.pool.v1beta1.EventFundPool
	(*EventDefundPool)(nil),              // 7: kyve.pool.v1beta1.EventDefundPool
	(*EventPoolFundsSlashed)(nil),        // 8: kyve.pool.v1beta1.EventPoolFundsSlashed
	(*EventPoolOutOfFunds)(nil),          // 9: kyve.pool.v1beta1.EventPoolOutOfFunds
}
var file_kyve_pool_v1beta1_events_proto_depIdxs = []int32{
	0, // [0:0] is the sub-list for method output_type
	0, // [0:0] is the sub-list for method input_type
	0, // [0:0] is the sub-list for extension type_name
	0, // [0:0] is the sub-list for extension extendee
	0, // [0:0] is the sub-list for field type_name
}

func init() { file_kyve_pool_v1beta1_events_proto_init() }
func file_kyve_pool_v1beta1_events_proto_init() {
	if File_kyve_pool_v1beta1_events_proto != nil {
		return
	}
	if !protoimpl.UnsafeEnabled {
		file_kyve_pool_v1beta1_events_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*EventCreatePool); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_kyve_pool_v1beta1_events_proto_msgTypes[1].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*EventPoolEnabled); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_kyve_pool_v1beta1_events_proto_msgTypes[2].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*EventPoolDisabled); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_kyve_pool_v1beta1_events_proto_msgTypes[3].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*EventRuntimeUpgradeScheduled); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_kyve_pool_v1beta1_events_proto_msgTypes[4].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*EventRuntimeUpgradeCancelled); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_kyve_pool_v1beta1_events_proto_msgTypes[5].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*EventPoolUpdated); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_kyve_pool_v1beta1_events_proto_msgTypes[6].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*EventFundPool); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_kyve_pool_v1beta1_events_proto_msgTypes[7].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*EventDefundPool); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_kyve_pool_v1beta1_events_proto_msgTypes[8].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*EventPoolFundsSlashed); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_kyve_pool_v1beta1_events_proto_msgTypes[9].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*EventPoolOutOfFunds); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: file_kyve_pool_v1beta1_events_proto_rawDesc,
			NumEnums:      0,
			NumMessages:   10,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_kyve_pool_v1beta1_events_proto_goTypes,
		DependencyIndexes: file_kyve_pool_v1beta1_events_proto_depIdxs,
		MessageInfos:      file_kyve_pool_v1beta1_events_proto_msgTypes,
	}.Build()
	File_kyve_pool_v1beta1_events_proto = out.File
	file_kyve_pool_v1beta1_events_proto_rawDesc = nil
	file_kyve_pool_v1beta1_events_proto_goTypes = nil
	file_kyve_pool_v1beta1_events_proto_depIdxs = nil
}
