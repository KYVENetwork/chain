// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package queryv1beta1

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// QueryBundlesClient is the client API for QueryBundles service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type QueryBundlesClient interface {
	// FinalizedBundles ...
	FinalizedBundlesQuery(ctx context.Context, in *QueryFinalizedBundlesRequest, opts ...grpc.CallOption) (*QueryFinalizedBundlesResponse, error)
	// FinalizedBundle ...
	FinalizedBundleQuery(ctx context.Context, in *QueryFinalizedBundleRequest, opts ...grpc.CallOption) (*FinalizedBundle, error)
	// CurrentVoteStatus ...
	CurrentVoteStatus(ctx context.Context, in *QueryCurrentVoteStatusRequest, opts ...grpc.CallOption) (*QueryCurrentVoteStatusResponse, error)
	// CanValidate ...
	CanValidate(ctx context.Context, in *QueryCanValidateRequest, opts ...grpc.CallOption) (*QueryCanValidateResponse, error)
	// CanPropose ...
	CanPropose(ctx context.Context, in *QueryCanProposeRequest, opts ...grpc.CallOption) (*QueryCanProposeResponse, error)
	// CanVote checks if voter on pool can still vote for the given bundle
	CanVote(ctx context.Context, in *QueryCanVoteRequest, opts ...grpc.CallOption) (*QueryCanVoteResponse, error)
}

type queryBundlesClient struct {
	cc grpc.ClientConnInterface
}

func NewQueryBundlesClient(cc grpc.ClientConnInterface) QueryBundlesClient {
	return &queryBundlesClient{cc}
}

func (c *queryBundlesClient) FinalizedBundlesQuery(ctx context.Context, in *QueryFinalizedBundlesRequest, opts ...grpc.CallOption) (*QueryFinalizedBundlesResponse, error) {
	out := new(QueryFinalizedBundlesResponse)
	err := c.cc.Invoke(ctx, "/kyve.query.v1beta1.QueryBundles/FinalizedBundlesQuery", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryBundlesClient) FinalizedBundleQuery(ctx context.Context, in *QueryFinalizedBundleRequest, opts ...grpc.CallOption) (*FinalizedBundle, error) {
	out := new(FinalizedBundle)
	err := c.cc.Invoke(ctx, "/kyve.query.v1beta1.QueryBundles/FinalizedBundleQuery", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryBundlesClient) CurrentVoteStatus(ctx context.Context, in *QueryCurrentVoteStatusRequest, opts ...grpc.CallOption) (*QueryCurrentVoteStatusResponse, error) {
	out := new(QueryCurrentVoteStatusResponse)
	err := c.cc.Invoke(ctx, "/kyve.query.v1beta1.QueryBundles/CurrentVoteStatus", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryBundlesClient) CanValidate(ctx context.Context, in *QueryCanValidateRequest, opts ...grpc.CallOption) (*QueryCanValidateResponse, error) {
	out := new(QueryCanValidateResponse)
	err := c.cc.Invoke(ctx, "/kyve.query.v1beta1.QueryBundles/CanValidate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryBundlesClient) CanPropose(ctx context.Context, in *QueryCanProposeRequest, opts ...grpc.CallOption) (*QueryCanProposeResponse, error) {
	out := new(QueryCanProposeResponse)
	err := c.cc.Invoke(ctx, "/kyve.query.v1beta1.QueryBundles/CanPropose", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryBundlesClient) CanVote(ctx context.Context, in *QueryCanVoteRequest, opts ...grpc.CallOption) (*QueryCanVoteResponse, error) {
	out := new(QueryCanVoteResponse)
	err := c.cc.Invoke(ctx, "/kyve.query.v1beta1.QueryBundles/CanVote", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// QueryBundlesServer is the server API for QueryBundles service.
// All implementations must embed UnimplementedQueryBundlesServer
// for forward compatibility
type QueryBundlesServer interface {
	// FinalizedBundles ...
	FinalizedBundlesQuery(context.Context, *QueryFinalizedBundlesRequest) (*QueryFinalizedBundlesResponse, error)
	// FinalizedBundle ...
	FinalizedBundleQuery(context.Context, *QueryFinalizedBundleRequest) (*FinalizedBundle, error)
	// CurrentVoteStatus ...
	CurrentVoteStatus(context.Context, *QueryCurrentVoteStatusRequest) (*QueryCurrentVoteStatusResponse, error)
	// CanValidate ...
	CanValidate(context.Context, *QueryCanValidateRequest) (*QueryCanValidateResponse, error)
	// CanPropose ...
	CanPropose(context.Context, *QueryCanProposeRequest) (*QueryCanProposeResponse, error)
	// CanVote checks if voter on pool can still vote for the given bundle
	CanVote(context.Context, *QueryCanVoteRequest) (*QueryCanVoteResponse, error)
	mustEmbedUnimplementedQueryBundlesServer()
}

// UnimplementedQueryBundlesServer must be embedded to have forward compatible implementations.
type UnimplementedQueryBundlesServer struct {
}

func (UnimplementedQueryBundlesServer) FinalizedBundlesQuery(context.Context, *QueryFinalizedBundlesRequest) (*QueryFinalizedBundlesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FinalizedBundlesQuery not implemented")
}
func (UnimplementedQueryBundlesServer) FinalizedBundleQuery(context.Context, *QueryFinalizedBundleRequest) (*FinalizedBundle, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FinalizedBundleQuery not implemented")
}
func (UnimplementedQueryBundlesServer) CurrentVoteStatus(context.Context, *QueryCurrentVoteStatusRequest) (*QueryCurrentVoteStatusResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CurrentVoteStatus not implemented")
}
func (UnimplementedQueryBundlesServer) CanValidate(context.Context, *QueryCanValidateRequest) (*QueryCanValidateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CanValidate not implemented")
}
func (UnimplementedQueryBundlesServer) CanPropose(context.Context, *QueryCanProposeRequest) (*QueryCanProposeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CanPropose not implemented")
}
func (UnimplementedQueryBundlesServer) CanVote(context.Context, *QueryCanVoteRequest) (*QueryCanVoteResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CanVote not implemented")
}
func (UnimplementedQueryBundlesServer) mustEmbedUnimplementedQueryBundlesServer() {}

// UnsafeQueryBundlesServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to QueryBundlesServer will
// result in compilation errors.
type UnsafeQueryBundlesServer interface {
	mustEmbedUnimplementedQueryBundlesServer()
}

func RegisterQueryBundlesServer(s grpc.ServiceRegistrar, srv QueryBundlesServer) {
	s.RegisterService(&QueryBundles_ServiceDesc, srv)
}

func _QueryBundles_FinalizedBundlesQuery_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryFinalizedBundlesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryBundlesServer).FinalizedBundlesQuery(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kyve.query.v1beta1.QueryBundles/FinalizedBundlesQuery",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryBundlesServer).FinalizedBundlesQuery(ctx, req.(*QueryFinalizedBundlesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _QueryBundles_FinalizedBundleQuery_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryFinalizedBundleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryBundlesServer).FinalizedBundleQuery(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kyve.query.v1beta1.QueryBundles/FinalizedBundleQuery",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryBundlesServer).FinalizedBundleQuery(ctx, req.(*QueryFinalizedBundleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _QueryBundles_CurrentVoteStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryCurrentVoteStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryBundlesServer).CurrentVoteStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kyve.query.v1beta1.QueryBundles/CurrentVoteStatus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryBundlesServer).CurrentVoteStatus(ctx, req.(*QueryCurrentVoteStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _QueryBundles_CanValidate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryCanValidateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryBundlesServer).CanValidate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kyve.query.v1beta1.QueryBundles/CanValidate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryBundlesServer).CanValidate(ctx, req.(*QueryCanValidateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _QueryBundles_CanPropose_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryCanProposeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryBundlesServer).CanPropose(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kyve.query.v1beta1.QueryBundles/CanPropose",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryBundlesServer).CanPropose(ctx, req.(*QueryCanProposeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _QueryBundles_CanVote_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryCanVoteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryBundlesServer).CanVote(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kyve.query.v1beta1.QueryBundles/CanVote",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryBundlesServer).CanVote(ctx, req.(*QueryCanVoteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// QueryBundles_ServiceDesc is the grpc.ServiceDesc for QueryBundles service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var QueryBundles_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "kyve.query.v1beta1.QueryBundles",
	HandlerType: (*QueryBundlesServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "FinalizedBundlesQuery",
			Handler:    _QueryBundles_FinalizedBundlesQuery_Handler,
		},
		{
			MethodName: "FinalizedBundleQuery",
			Handler:    _QueryBundles_FinalizedBundleQuery_Handler,
		},
		{
			MethodName: "CurrentVoteStatus",
			Handler:    _QueryBundles_CurrentVoteStatus_Handler,
		},
		{
			MethodName: "CanValidate",
			Handler:    _QueryBundles_CanValidate_Handler,
		},
		{
			MethodName: "CanPropose",
			Handler:    _QueryBundles_CanPropose_Handler,
		},
		{
			MethodName: "CanVote",
			Handler:    _QueryBundles_CanVote_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "kyve/query/v1beta1/bundles.proto",
}
