// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: kyve/bundles/v1beta1/bundles.proto

package types

import (
	fmt "fmt"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// BundleStatus represents the status of an evaluated bundle
// proposal.
type BundleStatus int32

const (
	// BUNDLE_STATUS_UNSPECIFIED ...
	BUNDLE_STATUS_UNSPECIFIED BundleStatus = 0
	// BUNDLE_STATUS_VALID ...
	BUNDLE_STATUS_VALID BundleStatus = 1
	// BUNDLE_STATUS_INVALID ...
	BUNDLE_STATUS_INVALID BundleStatus = 2
	// BUNDLE_STATUS_NO_FUNDS ...
	BUNDLE_STATUS_NO_FUNDS BundleStatus = 3
	// BUNDLE_STATUS_NO_QUORUM ...
	BUNDLE_STATUS_NO_QUORUM BundleStatus = 4
	// BUNDLE_STATUS_DISABLED  ...
	BUNDLE_STATUS_DISABLED BundleStatus = 5
)

var BundleStatus_name = map[int32]string{
	0: "BUNDLE_STATUS_UNSPECIFIED",
	1: "BUNDLE_STATUS_VALID",
	2: "BUNDLE_STATUS_INVALID",
	3: "BUNDLE_STATUS_NO_FUNDS",
	4: "BUNDLE_STATUS_NO_QUORUM",
	5: "BUNDLE_STATUS_DISABLED",
}

var BundleStatus_value = map[string]int32{
	"BUNDLE_STATUS_UNSPECIFIED": 0,
	"BUNDLE_STATUS_VALID":       1,
	"BUNDLE_STATUS_INVALID":     2,
	"BUNDLE_STATUS_NO_FUNDS":    3,
	"BUNDLE_STATUS_NO_QUORUM":   4,
	"BUNDLE_STATUS_DISABLED":    5,
}

func (x BundleStatus) String() string {
	return proto.EnumName(BundleStatus_name, int32(x))
}

func (BundleStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_889cf76d77a4de2b, []int{0}
}

// BundleProposal represents the current bundle proposal
// of a storage pool
type BundleProposal struct {
	// pool_id is the id of the pool for which this proposal is for
	PoolId uint64 `protobuf:"varint,1,opt,name=pool_id,json=poolId,proto3" json:"pool_id,omitempty"`
	// storage_id is the id with which the data can be retrieved from
	StorageId string `protobuf:"bytes,2,opt,name=storage_id,json=storageId,proto3" json:"storage_id,omitempty"`
	// uploader is the address of the staker who submitted the current proposal
	Uploader string `protobuf:"bytes,3,opt,name=uploader,proto3" json:"uploader,omitempty"`
	// next_uploader is the address of the staker who should upload the next proposal
	NextUploader string `protobuf:"bytes,4,opt,name=next_uploader,json=nextUploader,proto3" json:"next_uploader,omitempty"`
	// data_size the size of the data in bytes
	DataSize uint64 `protobuf:"varint,5,opt,name=data_size,json=dataSize,proto3" json:"data_size,omitempty"`
	// bundle_size the size of the bundle (amount of data items)
	BundleSize uint64 `protobuf:"varint,6,opt,name=bundle_size,json=bundleSize,proto3" json:"bundle_size,omitempty"`
	// to_key the key of the last data item in the bundle proposal
	ToKey string `protobuf:"bytes,7,opt,name=to_key,json=toKey,proto3" json:"to_key,omitempty"`
	// bundle_summary a string summary of the current proposal
	BundleSummary string `protobuf:"bytes,8,opt,name=bundle_summary,json=bundleSummary,proto3" json:"bundle_summary,omitempty"`
	// data_hash a sha256 hash of the raw compressed data
	DataHash string `protobuf:"bytes,9,opt,name=data_hash,json=dataHash,proto3" json:"data_hash,omitempty"`
	// updated_at the last time this proposal was edited
	UpdatedAt uint64 `protobuf:"varint,10,opt,name=updated_at,json=updatedAt,proto3" json:"updated_at,omitempty"`
	// voters_valid list of all stakers who voted in favor for current proposal
	VotersValid []string `protobuf:"bytes,11,rep,name=voters_valid,json=votersValid,proto3" json:"voters_valid,omitempty"`
	// voters_invalid list of all stakers who voted against for current proposal
	VotersInvalid []string `protobuf:"bytes,12,rep,name=voters_invalid,json=votersInvalid,proto3" json:"voters_invalid,omitempty"`
	// voters_abstain list of all stakers who voted abstain for current proposal
	VotersAbstain []string `protobuf:"bytes,13,rep,name=voters_abstain,json=votersAbstain,proto3" json:"voters_abstain,omitempty"`
	// from_key the key of the first data item in the bundle proposal
	FromKey string `protobuf:"bytes,14,opt,name=from_key,json=fromKey,proto3" json:"from_key,omitempty"`
	// storage_provider_id the id of the storage provider where the bundle is stored
	StorageProviderId uint32 `protobuf:"varint,15,opt,name=storage_provider_id,json=storageProviderId,proto3" json:"storage_provider_id,omitempty"`
	// compression_id the id of the compression type with which the data was compressed
	CompressionId uint32 `protobuf:"varint,16,opt,name=compression_id,json=compressionId,proto3" json:"compression_id,omitempty"`
}

func (m *BundleProposal) Reset()         { *m = BundleProposal{} }
func (m *BundleProposal) String() string { return proto.CompactTextString(m) }
func (*BundleProposal) ProtoMessage()    {}
func (*BundleProposal) Descriptor() ([]byte, []int) {
	return fileDescriptor_889cf76d77a4de2b, []int{0}
}
func (m *BundleProposal) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BundleProposal) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BundleProposal.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BundleProposal) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BundleProposal.Merge(m, src)
}
func (m *BundleProposal) XXX_Size() int {
	return m.Size()
}
func (m *BundleProposal) XXX_DiscardUnknown() {
	xxx_messageInfo_BundleProposal.DiscardUnknown(m)
}

var xxx_messageInfo_BundleProposal proto.InternalMessageInfo

func (m *BundleProposal) GetPoolId() uint64 {
	if m != nil {
		return m.PoolId
	}
	return 0
}

func (m *BundleProposal) GetStorageId() string {
	if m != nil {
		return m.StorageId
	}
	return ""
}

func (m *BundleProposal) GetUploader() string {
	if m != nil {
		return m.Uploader
	}
	return ""
}

func (m *BundleProposal) GetNextUploader() string {
	if m != nil {
		return m.NextUploader
	}
	return ""
}

func (m *BundleProposal) GetDataSize() uint64 {
	if m != nil {
		return m.DataSize
	}
	return 0
}

func (m *BundleProposal) GetBundleSize() uint64 {
	if m != nil {
		return m.BundleSize
	}
	return 0
}

func (m *BundleProposal) GetToKey() string {
	if m != nil {
		return m.ToKey
	}
	return ""
}

func (m *BundleProposal) GetBundleSummary() string {
	if m != nil {
		return m.BundleSummary
	}
	return ""
}

func (m *BundleProposal) GetDataHash() string {
	if m != nil {
		return m.DataHash
	}
	return ""
}

func (m *BundleProposal) GetUpdatedAt() uint64 {
	if m != nil {
		return m.UpdatedAt
	}
	return 0
}

func (m *BundleProposal) GetVotersValid() []string {
	if m != nil {
		return m.VotersValid
	}
	return nil
}

func (m *BundleProposal) GetVotersInvalid() []string {
	if m != nil {
		return m.VotersInvalid
	}
	return nil
}

func (m *BundleProposal) GetVotersAbstain() []string {
	if m != nil {
		return m.VotersAbstain
	}
	return nil
}

func (m *BundleProposal) GetFromKey() string {
	if m != nil {
		return m.FromKey
	}
	return ""
}

func (m *BundleProposal) GetStorageProviderId() uint32 {
	if m != nil {
		return m.StorageProviderId
	}
	return 0
}

func (m *BundleProposal) GetCompressionId() uint32 {
	if m != nil {
		return m.CompressionId
	}
	return 0
}

// FinalizedBundle represents a bundle proposal where the majority
// agreed on its validity
type FinalizedBundle struct {
	// pool_id is the id of the pool for which this proposal is for
	PoolId uint64 `protobuf:"varint,1,opt,name=pool_id,json=poolId,proto3" json:"pool_id,omitempty"`
	// id is a unique identifier for each finalized bundle in a pool
	Id uint64 `protobuf:"varint,2,opt,name=id,proto3" json:"id,omitempty"`
	// storage_id is the id with which the data can be retrieved from
	StorageId string `protobuf:"bytes,3,opt,name=storage_id,json=storageId,proto3" json:"storage_id,omitempty"`
	// uploader is the address of the staker who submitted this bundle
	Uploader string `protobuf:"bytes,4,opt,name=uploader,proto3" json:"uploader,omitempty"`
	// from_index is the index from where the bundle starts (inclusive)
	FromIndex uint64 `protobuf:"varint,5,opt,name=from_index,json=fromIndex,proto3" json:"from_index,omitempty"`
	// to_index is the index to which the bundle goes (exclusive)
	ToIndex uint64 `protobuf:"varint,6,opt,name=to_index,json=toIndex,proto3" json:"to_index,omitempty"`
	// to_key the key of the last data item in the bundle proposal
	ToKey string `protobuf:"bytes,7,opt,name=to_key,json=toKey,proto3" json:"to_key,omitempty"`
	// bundle_summary a string summary of the current proposal
	BundleSummary string `protobuf:"bytes,8,opt,name=bundle_summary,json=bundleSummary,proto3" json:"bundle_summary,omitempty"`
	// data_hash a sha256 hash of the raw compressed data
	DataHash string `protobuf:"bytes,9,opt,name=data_hash,json=dataHash,proto3" json:"data_hash,omitempty"`
	// finalized_at contains details of the block that finalized this bundle.
	FinalizedAt *FinalizedAt `protobuf:"bytes,10,opt,name=finalized_at,json=finalizedAt,proto3" json:"finalized_at,omitempty"`
	// from_key the key of the first data item in the bundle proposal
	FromKey string `protobuf:"bytes,11,opt,name=from_key,json=fromKey,proto3" json:"from_key,omitempty"`
	// storage_provider_id the id of the storage provider where the bundle is stored
	StorageProviderId uint32 `protobuf:"varint,12,opt,name=storage_provider_id,json=storageProviderId,proto3" json:"storage_provider_id,omitempty"`
	// compression_id the id of the compression type with which the data was compressed
	CompressionId uint32 `protobuf:"varint,13,opt,name=compression_id,json=compressionId,proto3" json:"compression_id,omitempty"`
}

func (m *FinalizedBundle) Reset()         { *m = FinalizedBundle{} }
func (m *FinalizedBundle) String() string { return proto.CompactTextString(m) }
func (*FinalizedBundle) ProtoMessage()    {}
func (*FinalizedBundle) Descriptor() ([]byte, []int) {
	return fileDescriptor_889cf76d77a4de2b, []int{1}
}
func (m *FinalizedBundle) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FinalizedBundle) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FinalizedBundle.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FinalizedBundle) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FinalizedBundle.Merge(m, src)
}
func (m *FinalizedBundle) XXX_Size() int {
	return m.Size()
}
func (m *FinalizedBundle) XXX_DiscardUnknown() {
	xxx_messageInfo_FinalizedBundle.DiscardUnknown(m)
}

var xxx_messageInfo_FinalizedBundle proto.InternalMessageInfo

func (m *FinalizedBundle) GetPoolId() uint64 {
	if m != nil {
		return m.PoolId
	}
	return 0
}

func (m *FinalizedBundle) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *FinalizedBundle) GetStorageId() string {
	if m != nil {
		return m.StorageId
	}
	return ""
}

func (m *FinalizedBundle) GetUploader() string {
	if m != nil {
		return m.Uploader
	}
	return ""
}

func (m *FinalizedBundle) GetFromIndex() uint64 {
	if m != nil {
		return m.FromIndex
	}
	return 0
}

func (m *FinalizedBundle) GetToIndex() uint64 {
	if m != nil {
		return m.ToIndex
	}
	return 0
}

func (m *FinalizedBundle) GetToKey() string {
	if m != nil {
		return m.ToKey
	}
	return ""
}

func (m *FinalizedBundle) GetBundleSummary() string {
	if m != nil {
		return m.BundleSummary
	}
	return ""
}

func (m *FinalizedBundle) GetDataHash() string {
	if m != nil {
		return m.DataHash
	}
	return ""
}

func (m *FinalizedBundle) GetFinalizedAt() *FinalizedAt {
	if m != nil {
		return m.FinalizedAt
	}
	return nil
}

func (m *FinalizedBundle) GetFromKey() string {
	if m != nil {
		return m.FromKey
	}
	return ""
}

func (m *FinalizedBundle) GetStorageProviderId() uint32 {
	if m != nil {
		return m.StorageProviderId
	}
	return 0
}

func (m *FinalizedBundle) GetCompressionId() uint32 {
	if m != nil {
		return m.CompressionId
	}
	return 0
}

// FinalizedAt ...
type FinalizedAt struct {
	// height ...
	Height uint64 `protobuf:"varint,1,opt,name=height,proto3" json:"height,omitempty"`
	// timestamp ...
	Timestamp uint64 `protobuf:"varint,2,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
}

func (m *FinalizedAt) Reset()         { *m = FinalizedAt{} }
func (m *FinalizedAt) String() string { return proto.CompactTextString(m) }
func (*FinalizedAt) ProtoMessage()    {}
func (*FinalizedAt) Descriptor() ([]byte, []int) {
	return fileDescriptor_889cf76d77a4de2b, []int{2}
}
func (m *FinalizedAt) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FinalizedAt) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FinalizedAt.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FinalizedAt) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FinalizedAt.Merge(m, src)
}
func (m *FinalizedAt) XXX_Size() int {
	return m.Size()
}
func (m *FinalizedAt) XXX_DiscardUnknown() {
	xxx_messageInfo_FinalizedAt.DiscardUnknown(m)
}

var xxx_messageInfo_FinalizedAt proto.InternalMessageInfo

func (m *FinalizedAt) GetHeight() uint64 {
	if m != nil {
		return m.Height
	}
	return 0
}

func (m *FinalizedAt) GetTimestamp() uint64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

// RoundRobinSingleValidatorProgress ...
type RoundRobinSingleValidatorProgress struct {
	// address ...
	Address string `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
	// progress ...
	Progress int64 `protobuf:"varint,2,opt,name=progress,proto3" json:"progress,omitempty"`
}

func (m *RoundRobinSingleValidatorProgress) Reset()         { *m = RoundRobinSingleValidatorProgress{} }
func (m *RoundRobinSingleValidatorProgress) String() string { return proto.CompactTextString(m) }
func (*RoundRobinSingleValidatorProgress) ProtoMessage()    {}
func (*RoundRobinSingleValidatorProgress) Descriptor() ([]byte, []int) {
	return fileDescriptor_889cf76d77a4de2b, []int{3}
}
func (m *RoundRobinSingleValidatorProgress) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RoundRobinSingleValidatorProgress) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RoundRobinSingleValidatorProgress.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RoundRobinSingleValidatorProgress) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RoundRobinSingleValidatorProgress.Merge(m, src)
}
func (m *RoundRobinSingleValidatorProgress) XXX_Size() int {
	return m.Size()
}
func (m *RoundRobinSingleValidatorProgress) XXX_DiscardUnknown() {
	xxx_messageInfo_RoundRobinSingleValidatorProgress.DiscardUnknown(m)
}

var xxx_messageInfo_RoundRobinSingleValidatorProgress proto.InternalMessageInfo

func (m *RoundRobinSingleValidatorProgress) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *RoundRobinSingleValidatorProgress) GetProgress() int64 {
	if m != nil {
		return m.Progress
	}
	return 0
}

// RoundRobinProgress ...
type RoundRobinProgress struct {
	// pool_id ...
	PoolId uint64 `protobuf:"varint,1,opt,name=pool_id,json=poolId,proto3" json:"pool_id,omitempty"`
	// progress_list ...
	ProgressList []*RoundRobinSingleValidatorProgress `protobuf:"bytes,2,rep,name=progress_list,json=progressList,proto3" json:"progress_list,omitempty"`
}

func (m *RoundRobinProgress) Reset()         { *m = RoundRobinProgress{} }
func (m *RoundRobinProgress) String() string { return proto.CompactTextString(m) }
func (*RoundRobinProgress) ProtoMessage()    {}
func (*RoundRobinProgress) Descriptor() ([]byte, []int) {
	return fileDescriptor_889cf76d77a4de2b, []int{4}
}
func (m *RoundRobinProgress) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RoundRobinProgress) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RoundRobinProgress.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RoundRobinProgress) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RoundRobinProgress.Merge(m, src)
}
func (m *RoundRobinProgress) XXX_Size() int {
	return m.Size()
}
func (m *RoundRobinProgress) XXX_DiscardUnknown() {
	xxx_messageInfo_RoundRobinProgress.DiscardUnknown(m)
}

var xxx_messageInfo_RoundRobinProgress proto.InternalMessageInfo

func (m *RoundRobinProgress) GetPoolId() uint64 {
	if m != nil {
		return m.PoolId
	}
	return 0
}

func (m *RoundRobinProgress) GetProgressList() []*RoundRobinSingleValidatorProgress {
	if m != nil {
		return m.ProgressList
	}
	return nil
}

func init() {
	proto.RegisterEnum("kyve.bundles.v1beta1.BundleStatus", BundleStatus_name, BundleStatus_value)
	proto.RegisterType((*BundleProposal)(nil), "kyve.bundles.v1beta1.BundleProposal")
	proto.RegisterType((*FinalizedBundle)(nil), "kyve.bundles.v1beta1.FinalizedBundle")
	proto.RegisterType((*FinalizedAt)(nil), "kyve.bundles.v1beta1.FinalizedAt")
	proto.RegisterType((*RoundRobinSingleValidatorProgress)(nil), "kyve.bundles.v1beta1.RoundRobinSingleValidatorProgress")
	proto.RegisterType((*RoundRobinProgress)(nil), "kyve.bundles.v1beta1.RoundRobinProgress")
}

func init() {
	proto.RegisterFile("kyve/bundles/v1beta1/bundles.proto", fileDescriptor_889cf76d77a4de2b)
}

var fileDescriptor_889cf76d77a4de2b = []byte{
	// 800 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x55, 0xcf, 0x6f, 0xe2, 0x46,
	0x14, 0xc6, 0x40, 0x20, 0x7e, 0xc6, 0x59, 0x3a, 0xfb, 0x23, 0x4e, 0xb6, 0xa1, 0x84, 0xaa, 0x12,
	0xaa, 0x2a, 0xd0, 0x6e, 0x0f, 0x3d, 0x93, 0x85, 0xa8, 0xd6, 0xa6, 0x6c, 0x6a, 0x2f, 0x91, 0xb6,
	0xaa, 0x64, 0x0d, 0x99, 0x09, 0x8c, 0x62, 0x3c, 0x96, 0x3d, 0xd0, 0x90, 0xbf, 0xa0, 0x52, 0x2f,
	0xfd, 0x1f, 0xda, 0x3f, 0xa3, 0xa7, 0x9e, 0x7a, 0xdc, 0x63, 0x8f, 0x55, 0xf2, 0x8f, 0x54, 0x33,
	0x63, 0x93, 0xb0, 0x9b, 0x6d, 0x73, 0xd9, 0x1b, 0xef, 0xfb, 0xbe, 0x79, 0xf3, 0xde, 0x7c, 0x1f,
	0x32, 0xb4, 0xce, 0x97, 0x0b, 0xda, 0x1d, 0xcf, 0x23, 0x12, 0xd2, 0xb4, 0xbb, 0x78, 0x36, 0xa6,
	0x02, 0x3f, 0xcb, 0xeb, 0x4e, 0x9c, 0x70, 0xc1, 0xd1, 0x23, 0xa9, 0xe9, 0xe4, 0x58, 0xa6, 0xd9,
	0x7d, 0x34, 0xe1, 0x13, 0xae, 0x04, 0x5d, 0xf9, 0x4b, 0x6b, 0x5b, 0xbf, 0x97, 0x61, 0xeb, 0x40,
	0x29, 0x8f, 0x13, 0x1e, 0xf3, 0x14, 0x87, 0x68, 0x1b, 0xaa, 0x31, 0xe7, 0x61, 0xc0, 0x88, 0x63,
	0x34, 0x8d, 0x76, 0xd9, 0xab, 0xc8, 0xd2, 0x25, 0x68, 0x0f, 0x20, 0x15, 0x3c, 0xc1, 0x13, 0x2a,
	0xb9, 0x62, 0xd3, 0x68, 0x9b, 0x9e, 0x99, 0x21, 0x2e, 0x41, 0xbb, 0xb0, 0x39, 0x8f, 0x43, 0x8e,
	0x09, 0x4d, 0x9c, 0x92, 0x22, 0x57, 0x35, 0xfa, 0x1c, 0xec, 0x88, 0x5e, 0x88, 0x60, 0x25, 0x28,
	0x2b, 0x41, 0x4d, 0x82, 0xa3, 0x5c, 0xf4, 0x14, 0x4c, 0x82, 0x05, 0x0e, 0x52, 0x76, 0x49, 0x9d,
	0x0d, 0x75, 0xf5, 0xa6, 0x04, 0x7c, 0x76, 0x49, 0xd1, 0x67, 0x60, 0xe9, 0x8d, 0x34, 0x5d, 0x51,
	0x34, 0x68, 0x48, 0x09, 0x1e, 0x43, 0x45, 0xf0, 0xe0, 0x9c, 0x2e, 0x9d, 0xaa, 0xea, 0xbd, 0x21,
	0xf8, 0x4b, 0xba, 0x44, 0x5f, 0xc0, 0x56, 0x7e, 0x6e, 0x3e, 0x9b, 0xe1, 0x64, 0xe9, 0x6c, 0x2a,
	0xda, 0xce, 0x8e, 0x6a, 0x70, 0x75, 0xf7, 0x14, 0xa7, 0x53, 0xc7, 0xd4, 0xd3, 0x4b, 0xe0, 0x5b,
	0x9c, 0x4e, 0xe5, 0xe2, 0xf3, 0x98, 0x60, 0x41, 0x49, 0x80, 0x85, 0x03, 0xea, 0x6a, 0x33, 0x43,
	0x7a, 0x02, 0xed, 0x43, 0x6d, 0xc1, 0x05, 0x4d, 0xd2, 0x60, 0x81, 0x43, 0x46, 0x1c, 0xab, 0x59,
	0x6a, 0x9b, 0x9e, 0xa5, 0xb1, 0x13, 0x09, 0xc9, 0x29, 0x32, 0x09, 0x8b, 0xb4, 0xa8, 0xa6, 0x44,
	0xb6, 0x46, 0x5d, 0x0d, 0xde, 0x92, 0xe1, 0x71, 0x2a, 0x30, 0x8b, 0x1c, 0xfb, 0xb6, 0xac, 0xa7,
	0x41, 0xb4, 0x03, 0x9b, 0x67, 0x09, 0x9f, 0xa9, 0x65, 0xb7, 0xd4, 0xac, 0x55, 0x59, 0xcb, 0x75,
	0x3b, 0xf0, 0x30, 0xf7, 0x28, 0x4e, 0xf8, 0x82, 0x11, 0x9a, 0x48, 0xb3, 0x1e, 0x34, 0x8d, 0xb6,
	0xed, 0x7d, 0x92, 0x51, 0xc7, 0x19, 0xe3, 0xaa, 0x1b, 0x4f, 0xf9, 0x2c, 0x4e, 0x68, 0x9a, 0x32,
	0x1e, 0x49, 0x69, 0x5d, 0x49, 0xed, 0x5b, 0xa8, 0x4b, 0x5a, 0x7f, 0x96, 0xe0, 0xc1, 0x21, 0x8b,
	0x70, 0xc8, 0x2e, 0x29, 0xd1, 0x79, 0xf9, 0x70, 0x4e, 0xb6, 0xa0, 0x98, 0xe5, 0xa3, 0xec, 0x15,
	0xd9, 0xbb, 0xb9, 0x29, 0xfd, 0x57, 0x6e, 0xca, 0xef, 0xe4, 0x66, 0x0f, 0x40, 0x6d, 0xca, 0x22,
	0x42, 0x2f, 0xb2, 0x4c, 0x98, 0x12, 0x71, 0x25, 0x20, 0x1f, 0x42, 0xf0, 0x8c, 0xd4, 0x89, 0xa8,
	0x0a, 0xae, 0xa9, 0x8f, 0x18, 0x87, 0x3e, 0xd4, 0xce, 0xf2, 0xb7, 0xc8, 0x03, 0x61, 0x3d, 0xdf,
	0xef, 0xdc, 0xf5, 0xb7, 0xeb, 0xac, 0x5e, 0xad, 0x27, 0x3c, 0xeb, 0xec, 0xa6, 0x58, 0x33, 0xd1,
	0xba, 0x97, 0x89, 0xb5, 0xfb, 0x9b, 0x68, 0xdf, 0x65, 0xe2, 0x0b, 0xb0, 0x6e, 0x4d, 0x83, 0x9e,
	0x40, 0x65, 0x4a, 0xd9, 0x64, 0x2a, 0x72, 0xfb, 0x74, 0x85, 0x3e, 0x05, 0x53, 0xb0, 0x19, 0x4d,
	0x05, 0x9e, 0xc5, 0x99, 0x8b, 0x37, 0x40, 0xeb, 0x0d, 0xec, 0x7b, 0x7c, 0x1e, 0x11, 0x8f, 0x8f,
	0x59, 0xe4, 0xb3, 0x68, 0x12, 0x52, 0x15, 0x71, 0x2c, 0x78, 0x72, 0x9c, 0xf0, 0x89, 0xbc, 0x0e,
	0x39, 0x50, 0xc5, 0x84, 0xc8, 0x9f, 0xaa, 0xb7, 0xe9, 0xe5, 0xa5, 0x34, 0x3b, 0xce, 0x54, 0xaa,
	0x77, 0xc9, 0x5b, 0xd5, 0xad, 0x5f, 0x0c, 0x40, 0x37, 0xbd, 0x57, 0xcd, 0x3e, 0x98, 0xb3, 0x1f,
	0xc1, 0xce, 0xcf, 0x06, 0x21, 0x4b, 0x85, 0x53, 0x6c, 0x96, 0xda, 0xd6, 0xf3, 0x6f, 0xee, 0x36,
	0xe2, 0x7f, 0xa7, 0xf6, 0x6a, 0x79, 0xb7, 0x23, 0x96, 0x8a, 0x2f, 0xff, 0x30, 0xa0, 0xa6, 0x93,
	0xee, 0x0b, 0x2c, 0xe6, 0x29, 0xda, 0x83, 0x9d, 0x83, 0xd1, 0xb0, 0x7f, 0x34, 0x08, 0xfc, 0xd7,
	0xbd, 0xd7, 0x23, 0x3f, 0x18, 0x0d, 0xfd, 0xe3, 0xc1, 0x0b, 0xf7, 0xd0, 0x1d, 0xf4, 0xeb, 0x05,
	0xb4, 0x0d, 0x0f, 0xd7, 0xe9, 0x93, 0xde, 0x91, 0xdb, 0xaf, 0x1b, 0x68, 0x07, 0x1e, 0xaf, 0x13,
	0xee, 0x50, 0x53, 0x45, 0xb4, 0x0b, 0x4f, 0xd6, 0xa9, 0xe1, 0xab, 0xe0, 0x70, 0x34, 0xec, 0xfb,
	0xf5, 0x12, 0x7a, 0x0a, 0xdb, 0xef, 0x71, 0xdf, 0x8f, 0x5e, 0x79, 0xa3, 0xef, 0xea, 0xe5, 0xf7,
	0x0f, 0xf6, 0x5d, 0xbf, 0x77, 0x70, 0x34, 0xe8, 0xd7, 0x37, 0x76, 0xcb, 0x3f, 0xff, 0xd6, 0x28,
	0x1c, 0x1c, 0xfe, 0x75, 0xd5, 0x30, 0xde, 0x5e, 0x35, 0x8c, 0x7f, 0xae, 0x1a, 0xc6, 0xaf, 0xd7,
	0x8d, 0xc2, 0xdb, 0xeb, 0x46, 0xe1, 0xef, 0xeb, 0x46, 0xe1, 0x87, 0xaf, 0x26, 0x4c, 0x4c, 0xe7,
	0xe3, 0xce, 0x29, 0x9f, 0x75, 0x5f, 0xbe, 0x39, 0x19, 0x0c, 0xa9, 0xf8, 0x89, 0x27, 0xe7, 0xdd,
	0xd3, 0x29, 0x66, 0x51, 0xf7, 0x62, 0xf5, 0x71, 0x11, 0xcb, 0x98, 0xa6, 0xe3, 0x8a, 0xfa, 0x4e,
	0x7c, 0xfd, 0x6f, 0x00, 0x00, 0x00, 0xff, 0xff, 0x74, 0x5f, 0x6b, 0xe1, 0x79, 0x06, 0x00, 0x00,
}

func (m *BundleProposal) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BundleProposal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BundleProposal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.CompressionId != 0 {
		i = encodeVarintBundles(dAtA, i, uint64(m.CompressionId))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if m.StorageProviderId != 0 {
		i = encodeVarintBundles(dAtA, i, uint64(m.StorageProviderId))
		i--
		dAtA[i] = 0x78
	}
	if len(m.FromKey) > 0 {
		i -= len(m.FromKey)
		copy(dAtA[i:], m.FromKey)
		i = encodeVarintBundles(dAtA, i, uint64(len(m.FromKey)))
		i--
		dAtA[i] = 0x72
	}
	if len(m.VotersAbstain) > 0 {
		for iNdEx := len(m.VotersAbstain) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.VotersAbstain[iNdEx])
			copy(dAtA[i:], m.VotersAbstain[iNdEx])
			i = encodeVarintBundles(dAtA, i, uint64(len(m.VotersAbstain[iNdEx])))
			i--
			dAtA[i] = 0x6a
		}
	}
	if len(m.VotersInvalid) > 0 {
		for iNdEx := len(m.VotersInvalid) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.VotersInvalid[iNdEx])
			copy(dAtA[i:], m.VotersInvalid[iNdEx])
			i = encodeVarintBundles(dAtA, i, uint64(len(m.VotersInvalid[iNdEx])))
			i--
			dAtA[i] = 0x62
		}
	}
	if len(m.VotersValid) > 0 {
		for iNdEx := len(m.VotersValid) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.VotersValid[iNdEx])
			copy(dAtA[i:], m.VotersValid[iNdEx])
			i = encodeVarintBundles(dAtA, i, uint64(len(m.VotersValid[iNdEx])))
			i--
			dAtA[i] = 0x5a
		}
	}
	if m.UpdatedAt != 0 {
		i = encodeVarintBundles(dAtA, i, uint64(m.UpdatedAt))
		i--
		dAtA[i] = 0x50
	}
	if len(m.DataHash) > 0 {
		i -= len(m.DataHash)
		copy(dAtA[i:], m.DataHash)
		i = encodeVarintBundles(dAtA, i, uint64(len(m.DataHash)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.BundleSummary) > 0 {
		i -= len(m.BundleSummary)
		copy(dAtA[i:], m.BundleSummary)
		i = encodeVarintBundles(dAtA, i, uint64(len(m.BundleSummary)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.ToKey) > 0 {
		i -= len(m.ToKey)
		copy(dAtA[i:], m.ToKey)
		i = encodeVarintBundles(dAtA, i, uint64(len(m.ToKey)))
		i--
		dAtA[i] = 0x3a
	}
	if m.BundleSize != 0 {
		i = encodeVarintBundles(dAtA, i, uint64(m.BundleSize))
		i--
		dAtA[i] = 0x30
	}
	if m.DataSize != 0 {
		i = encodeVarintBundles(dAtA, i, uint64(m.DataSize))
		i--
		dAtA[i] = 0x28
	}
	if len(m.NextUploader) > 0 {
		i -= len(m.NextUploader)
		copy(dAtA[i:], m.NextUploader)
		i = encodeVarintBundles(dAtA, i, uint64(len(m.NextUploader)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Uploader) > 0 {
		i -= len(m.Uploader)
		copy(dAtA[i:], m.Uploader)
		i = encodeVarintBundles(dAtA, i, uint64(len(m.Uploader)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.StorageId) > 0 {
		i -= len(m.StorageId)
		copy(dAtA[i:], m.StorageId)
		i = encodeVarintBundles(dAtA, i, uint64(len(m.StorageId)))
		i--
		dAtA[i] = 0x12
	}
	if m.PoolId != 0 {
		i = encodeVarintBundles(dAtA, i, uint64(m.PoolId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FinalizedBundle) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FinalizedBundle) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FinalizedBundle) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.CompressionId != 0 {
		i = encodeVarintBundles(dAtA, i, uint64(m.CompressionId))
		i--
		dAtA[i] = 0x68
	}
	if m.StorageProviderId != 0 {
		i = encodeVarintBundles(dAtA, i, uint64(m.StorageProviderId))
		i--
		dAtA[i] = 0x60
	}
	if len(m.FromKey) > 0 {
		i -= len(m.FromKey)
		copy(dAtA[i:], m.FromKey)
		i = encodeVarintBundles(dAtA, i, uint64(len(m.FromKey)))
		i--
		dAtA[i] = 0x5a
	}
	if m.FinalizedAt != nil {
		{
			size, err := m.FinalizedAt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBundles(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if len(m.DataHash) > 0 {
		i -= len(m.DataHash)
		copy(dAtA[i:], m.DataHash)
		i = encodeVarintBundles(dAtA, i, uint64(len(m.DataHash)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.BundleSummary) > 0 {
		i -= len(m.BundleSummary)
		copy(dAtA[i:], m.BundleSummary)
		i = encodeVarintBundles(dAtA, i, uint64(len(m.BundleSummary)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.ToKey) > 0 {
		i -= len(m.ToKey)
		copy(dAtA[i:], m.ToKey)
		i = encodeVarintBundles(dAtA, i, uint64(len(m.ToKey)))
		i--
		dAtA[i] = 0x3a
	}
	if m.ToIndex != 0 {
		i = encodeVarintBundles(dAtA, i, uint64(m.ToIndex))
		i--
		dAtA[i] = 0x30
	}
	if m.FromIndex != 0 {
		i = encodeVarintBundles(dAtA, i, uint64(m.FromIndex))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Uploader) > 0 {
		i -= len(m.Uploader)
		copy(dAtA[i:], m.Uploader)
		i = encodeVarintBundles(dAtA, i, uint64(len(m.Uploader)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.StorageId) > 0 {
		i -= len(m.StorageId)
		copy(dAtA[i:], m.StorageId)
		i = encodeVarintBundles(dAtA, i, uint64(len(m.StorageId)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Id != 0 {
		i = encodeVarintBundles(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x10
	}
	if m.PoolId != 0 {
		i = encodeVarintBundles(dAtA, i, uint64(m.PoolId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FinalizedAt) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FinalizedAt) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FinalizedAt) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Timestamp != 0 {
		i = encodeVarintBundles(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x10
	}
	if m.Height != 0 {
		i = encodeVarintBundles(dAtA, i, uint64(m.Height))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RoundRobinSingleValidatorProgress) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RoundRobinSingleValidatorProgress) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RoundRobinSingleValidatorProgress) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Progress != 0 {
		i = encodeVarintBundles(dAtA, i, uint64(m.Progress))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintBundles(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RoundRobinProgress) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RoundRobinProgress) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RoundRobinProgress) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ProgressList) > 0 {
		for iNdEx := len(m.ProgressList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ProgressList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBundles(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.PoolId != 0 {
		i = encodeVarintBundles(dAtA, i, uint64(m.PoolId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintBundles(dAtA []byte, offset int, v uint64) int {
	offset -= sovBundles(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *BundleProposal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PoolId != 0 {
		n += 1 + sovBundles(uint64(m.PoolId))
	}
	l = len(m.StorageId)
	if l > 0 {
		n += 1 + l + sovBundles(uint64(l))
	}
	l = len(m.Uploader)
	if l > 0 {
		n += 1 + l + sovBundles(uint64(l))
	}
	l = len(m.NextUploader)
	if l > 0 {
		n += 1 + l + sovBundles(uint64(l))
	}
	if m.DataSize != 0 {
		n += 1 + sovBundles(uint64(m.DataSize))
	}
	if m.BundleSize != 0 {
		n += 1 + sovBundles(uint64(m.BundleSize))
	}
	l = len(m.ToKey)
	if l > 0 {
		n += 1 + l + sovBundles(uint64(l))
	}
	l = len(m.BundleSummary)
	if l > 0 {
		n += 1 + l + sovBundles(uint64(l))
	}
	l = len(m.DataHash)
	if l > 0 {
		n += 1 + l + sovBundles(uint64(l))
	}
	if m.UpdatedAt != 0 {
		n += 1 + sovBundles(uint64(m.UpdatedAt))
	}
	if len(m.VotersValid) > 0 {
		for _, s := range m.VotersValid {
			l = len(s)
			n += 1 + l + sovBundles(uint64(l))
		}
	}
	if len(m.VotersInvalid) > 0 {
		for _, s := range m.VotersInvalid {
			l = len(s)
			n += 1 + l + sovBundles(uint64(l))
		}
	}
	if len(m.VotersAbstain) > 0 {
		for _, s := range m.VotersAbstain {
			l = len(s)
			n += 1 + l + sovBundles(uint64(l))
		}
	}
	l = len(m.FromKey)
	if l > 0 {
		n += 1 + l + sovBundles(uint64(l))
	}
	if m.StorageProviderId != 0 {
		n += 1 + sovBundles(uint64(m.StorageProviderId))
	}
	if m.CompressionId != 0 {
		n += 2 + sovBundles(uint64(m.CompressionId))
	}
	return n
}

func (m *FinalizedBundle) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PoolId != 0 {
		n += 1 + sovBundles(uint64(m.PoolId))
	}
	if m.Id != 0 {
		n += 1 + sovBundles(uint64(m.Id))
	}
	l = len(m.StorageId)
	if l > 0 {
		n += 1 + l + sovBundles(uint64(l))
	}
	l = len(m.Uploader)
	if l > 0 {
		n += 1 + l + sovBundles(uint64(l))
	}
	if m.FromIndex != 0 {
		n += 1 + sovBundles(uint64(m.FromIndex))
	}
	if m.ToIndex != 0 {
		n += 1 + sovBundles(uint64(m.ToIndex))
	}
	l = len(m.ToKey)
	if l > 0 {
		n += 1 + l + sovBundles(uint64(l))
	}
	l = len(m.BundleSummary)
	if l > 0 {
		n += 1 + l + sovBundles(uint64(l))
	}
	l = len(m.DataHash)
	if l > 0 {
		n += 1 + l + sovBundles(uint64(l))
	}
	if m.FinalizedAt != nil {
		l = m.FinalizedAt.Size()
		n += 1 + l + sovBundles(uint64(l))
	}
	l = len(m.FromKey)
	if l > 0 {
		n += 1 + l + sovBundles(uint64(l))
	}
	if m.StorageProviderId != 0 {
		n += 1 + sovBundles(uint64(m.StorageProviderId))
	}
	if m.CompressionId != 0 {
		n += 1 + sovBundles(uint64(m.CompressionId))
	}
	return n
}

func (m *FinalizedAt) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Height != 0 {
		n += 1 + sovBundles(uint64(m.Height))
	}
	if m.Timestamp != 0 {
		n += 1 + sovBundles(uint64(m.Timestamp))
	}
	return n
}

func (m *RoundRobinSingleValidatorProgress) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovBundles(uint64(l))
	}
	if m.Progress != 0 {
		n += 1 + sovBundles(uint64(m.Progress))
	}
	return n
}

func (m *RoundRobinProgress) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PoolId != 0 {
		n += 1 + sovBundles(uint64(m.PoolId))
	}
	if len(m.ProgressList) > 0 {
		for _, e := range m.ProgressList {
			l = e.Size()
			n += 1 + l + sovBundles(uint64(l))
		}
	}
	return n
}

func sovBundles(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozBundles(x uint64) (n int) {
	return sovBundles(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *BundleProposal) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBundles
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BundleProposal: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BundleProposal: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PoolId", wireType)
			}
			m.PoolId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBundles
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PoolId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StorageId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBundles
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBundles
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBundles
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StorageId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uploader", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBundles
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBundles
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBundles
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uploader = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextUploader", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBundles
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBundles
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBundles
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NextUploader = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataSize", wireType)
			}
			m.DataSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBundles
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DataSize |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BundleSize", wireType)
			}
			m.BundleSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBundles
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BundleSize |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBundles
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBundles
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBundles
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ToKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BundleSummary", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBundles
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBundles
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBundles
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BundleSummary = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBundles
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBundles
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBundles
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DataHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedAt", wireType)
			}
			m.UpdatedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBundles
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpdatedAt |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VotersValid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBundles
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBundles
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBundles
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VotersValid = append(m.VotersValid, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VotersInvalid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBundles
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBundles
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBundles
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VotersInvalid = append(m.VotersInvalid, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VotersAbstain", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBundles
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBundles
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBundles
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VotersAbstain = append(m.VotersAbstain, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBundles
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBundles
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBundles
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FromKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StorageProviderId", wireType)
			}
			m.StorageProviderId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBundles
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StorageProviderId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompressionId", wireType)
			}
			m.CompressionId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBundles
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CompressionId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBundles(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBundles
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FinalizedBundle) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBundles
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FinalizedBundle: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FinalizedBundle: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PoolId", wireType)
			}
			m.PoolId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBundles
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PoolId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBundles
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StorageId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBundles
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBundles
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBundles
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StorageId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uploader", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBundles
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBundles
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBundles
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uploader = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromIndex", wireType)
			}
			m.FromIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBundles
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FromIndex |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToIndex", wireType)
			}
			m.ToIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBundles
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ToIndex |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBundles
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBundles
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBundles
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ToKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BundleSummary", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBundles
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBundles
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBundles
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BundleSummary = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBundles
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBundles
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBundles
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DataHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FinalizedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBundles
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBundles
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBundles
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FinalizedAt == nil {
				m.FinalizedAt = &FinalizedAt{}
			}
			if err := m.FinalizedAt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBundles
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBundles
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBundles
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FromKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StorageProviderId", wireType)
			}
			m.StorageProviderId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBundles
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StorageProviderId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompressionId", wireType)
			}
			m.CompressionId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBundles
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CompressionId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBundles(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBundles
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FinalizedAt) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBundles
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FinalizedAt: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FinalizedAt: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			m.Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBundles
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Height |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBundles
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBundles(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBundles
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RoundRobinSingleValidatorProgress) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBundles
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RoundRobinSingleValidatorProgress: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RoundRobinSingleValidatorProgress: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBundles
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBundles
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBundles
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Progress", wireType)
			}
			m.Progress = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBundles
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Progress |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBundles(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBundles
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RoundRobinProgress) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBundles
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RoundRobinProgress: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RoundRobinProgress: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PoolId", wireType)
			}
			m.PoolId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBundles
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PoolId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProgressList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBundles
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBundles
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBundles
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProgressList = append(m.ProgressList, &RoundRobinSingleValidatorProgress{})
			if err := m.ProgressList[len(m.ProgressList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBundles(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBundles
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipBundles(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowBundles
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowBundles
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowBundles
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthBundles
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupBundles
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthBundles
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthBundles        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowBundles          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupBundles = fmt.Errorf("proto: unexpected end of group")
)
