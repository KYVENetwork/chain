// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: kyve/stakers/v1beta1/stakers.proto

package types

import (
	cosmossdk_io_math "cosmossdk.io/math"
	fmt "fmt"
	github_com_cosmos_cosmos_sdk_types "github.com/cosmos/cosmos-sdk/types"
	types "github.com/cosmos/cosmos-sdk/types"
	_ "github.com/cosmos/cosmos-sdk/types/tx/amino"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/cosmos/gogoproto/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// SlashType ...
type SlashType int32

const (
	// SLASH_TYPE_UNSPECIFIED ...
	SLASH_TYPE_UNSPECIFIED SlashType = 0
	// SLASH_TYPE_TIMEOUT ...
	SLASH_TYPE_TIMEOUT SlashType = 1
	// SLASH_TYPE_VOTE ...
	SLASH_TYPE_VOTE SlashType = 2
	// SLASH_TYPE_UPLOAD ...
	SLASH_TYPE_UPLOAD SlashType = 3
)

var SlashType_name = map[int32]string{
	0: "SLASH_TYPE_UNSPECIFIED",
	1: "SLASH_TYPE_TIMEOUT",
	2: "SLASH_TYPE_VOTE",
	3: "SLASH_TYPE_UPLOAD",
}

var SlashType_value = map[string]int32{
	"SLASH_TYPE_UNSPECIFIED": 0,
	"SLASH_TYPE_TIMEOUT":     1,
	"SLASH_TYPE_VOTE":        2,
	"SLASH_TYPE_UPLOAD":      3,
}

func (x SlashType) String() string {
	return proto.EnumName(SlashType_name, int32(x))
}

func (SlashType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d209d1a2a74d375d, []int{0}
}

// deprecated
// Staker contains all metadata for a staker
// Every address can only create one staker (itself)
type Staker struct {
	// address ...
	Address string `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
	// commission ...
	Commission cosmossdk_io_math.LegacyDec `protobuf:"bytes,2,opt,name=commission,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"commission"`
	// moniker ...
	Moniker string `protobuf:"bytes,3,opt,name=moniker,proto3" json:"moniker,omitempty"`
	// website ...
	Website string `protobuf:"bytes,4,opt,name=website,proto3" json:"website,omitempty"`
	// identity is the 64 bit keybase.io identity string
	Identity string `protobuf:"bytes,5,opt,name=identity,proto3" json:"identity,omitempty"`
	// security_contact ...
	SecurityContact string `protobuf:"bytes,6,opt,name=security_contact,json=securityContact,proto3" json:"security_contact,omitempty"`
	// details are some additional notes the staker finds important
	Details string `protobuf:"bytes,7,opt,name=details,proto3" json:"details,omitempty"`
	// commission_rewards are the rewards through commission and storage cost
	CommissionRewards github_com_cosmos_cosmos_sdk_types.Coins `protobuf:"bytes,8,rep,name=commission_rewards,json=commissionRewards,proto3,castrepeated=github.com/cosmos/cosmos-sdk/types.Coins" json:"commission_rewards"`
}

func (m *Staker) Reset()         { *m = Staker{} }
func (m *Staker) String() string { return proto.CompactTextString(m) }
func (*Staker) ProtoMessage()    {}
func (*Staker) Descriptor() ([]byte, []int) {
	return fileDescriptor_d209d1a2a74d375d, []int{0}
}
func (m *Staker) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Staker) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Staker.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Staker) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Staker.Merge(m, src)
}
func (m *Staker) XXX_Size() int {
	return m.Size()
}
func (m *Staker) XXX_DiscardUnknown() {
	xxx_messageInfo_Staker.DiscardUnknown(m)
}

var xxx_messageInfo_Staker proto.InternalMessageInfo

func (m *Staker) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *Staker) GetMoniker() string {
	if m != nil {
		return m.Moniker
	}
	return ""
}

func (m *Staker) GetWebsite() string {
	if m != nil {
		return m.Website
	}
	return ""
}

func (m *Staker) GetIdentity() string {
	if m != nil {
		return m.Identity
	}
	return ""
}

func (m *Staker) GetSecurityContact() string {
	if m != nil {
		return m.SecurityContact
	}
	return ""
}

func (m *Staker) GetDetails() string {
	if m != nil {
		return m.Details
	}
	return ""
}

func (m *Staker) GetCommissionRewards() github_com_cosmos_cosmos_sdk_types.Coins {
	if m != nil {
		return m.CommissionRewards
	}
	return nil
}

// PoolAccount gets authorized by a validator to
// vote in a given pool by favor of the validator.
// The pool account basically acts like an operator
// here so the validator private key can be stored
// securely and not on a remote server where
// the pool account will operate
type PoolAccount struct {
	// pool_id defines the pool in which the address
	// is allowed to vote in.
	PoolId uint64 `protobuf:"varint,1,opt,name=pool_id,json=poolId,proto3" json:"pool_id,omitempty"`
	// staker is the address validator
	Staker string `protobuf:"bytes,2,opt,name=staker,proto3" json:"staker,omitempty"`
	// pool_address is the account stored on the protocol
	// node which votes for the staker in the given pool
	PoolAddress string `protobuf:"bytes,3,opt,name=pool_address,json=poolAddress,proto3" json:"pool_address,omitempty"`
	// When a node is inactive (does not vote at all)
	// A point is added, after a certain amount of points
	// is reached the node gets kicked out.
	Points uint64 `protobuf:"varint,4,opt,name=points,proto3" json:"points,omitempty"`
	// isLeaving indicates if a staker is leaving the given pool.
	IsLeaving bool `protobuf:"varint,5,opt,name=is_leaving,json=isLeaving,proto3" json:"is_leaving,omitempty"`
	// commission ...
	Commission cosmossdk_io_math.LegacyDec `protobuf:"bytes,6,opt,name=commission,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"commission"`
	// stake_fraction ...
	StakeFraction cosmossdk_io_math.LegacyDec `protobuf:"bytes,7,opt,name=stake_fraction,json=stakeFraction,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"stake_fraction"`
}

func (m *PoolAccount) Reset()         { *m = PoolAccount{} }
func (m *PoolAccount) String() string { return proto.CompactTextString(m) }
func (*PoolAccount) ProtoMessage()    {}
func (*PoolAccount) Descriptor() ([]byte, []int) {
	return fileDescriptor_d209d1a2a74d375d, []int{1}
}
func (m *PoolAccount) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PoolAccount) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PoolAccount.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PoolAccount) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PoolAccount.Merge(m, src)
}
func (m *PoolAccount) XXX_Size() int {
	return m.Size()
}
func (m *PoolAccount) XXX_DiscardUnknown() {
	xxx_messageInfo_PoolAccount.DiscardUnknown(m)
}

var xxx_messageInfo_PoolAccount proto.InternalMessageInfo

func (m *PoolAccount) GetPoolId() uint64 {
	if m != nil {
		return m.PoolId
	}
	return 0
}

func (m *PoolAccount) GetStaker() string {
	if m != nil {
		return m.Staker
	}
	return ""
}

func (m *PoolAccount) GetPoolAddress() string {
	if m != nil {
		return m.PoolAddress
	}
	return ""
}

func (m *PoolAccount) GetPoints() uint64 {
	if m != nil {
		return m.Points
	}
	return 0
}

func (m *PoolAccount) GetIsLeaving() bool {
	if m != nil {
		return m.IsLeaving
	}
	return false
}

// CommissionChangeEntry stores the information for an
// upcoming commission change. A commission change is never
// instant, so delegators have time to redelegate in case
// they don't agree with the new commission.
type CommissionChangeEntry struct {
	// index is needed for the queue-algorithm which
	// processes the commission changes
	Index uint64 `protobuf:"varint,1,opt,name=index,proto3" json:"index,omitempty"`
	// staker is the address of the affected staker
	Staker string `protobuf:"bytes,2,opt,name=staker,proto3" json:"staker,omitempty"`
	// pool_id ...
	PoolId uint64 `protobuf:"varint,3,opt,name=pool_id,json=poolId,proto3" json:"pool_id,omitempty"`
	// commission is the new commission which will
	// be applied after the waiting time is over.
	Commission cosmossdk_io_math.LegacyDec `protobuf:"bytes,4,opt,name=commission,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"commission"`
	// creation_date is the UNIX-timestamp in seconds
	// when the entry was created.
	CreationDate int64 `protobuf:"varint,5,opt,name=creation_date,json=creationDate,proto3" json:"creation_date,omitempty"`
}

func (m *CommissionChangeEntry) Reset()         { *m = CommissionChangeEntry{} }
func (m *CommissionChangeEntry) String() string { return proto.CompactTextString(m) }
func (*CommissionChangeEntry) ProtoMessage()    {}
func (*CommissionChangeEntry) Descriptor() ([]byte, []int) {
	return fileDescriptor_d209d1a2a74d375d, []int{2}
}
func (m *CommissionChangeEntry) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CommissionChangeEntry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CommissionChangeEntry.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CommissionChangeEntry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CommissionChangeEntry.Merge(m, src)
}
func (m *CommissionChangeEntry) XXX_Size() int {
	return m.Size()
}
func (m *CommissionChangeEntry) XXX_DiscardUnknown() {
	xxx_messageInfo_CommissionChangeEntry.DiscardUnknown(m)
}

var xxx_messageInfo_CommissionChangeEntry proto.InternalMessageInfo

func (m *CommissionChangeEntry) GetIndex() uint64 {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *CommissionChangeEntry) GetStaker() string {
	if m != nil {
		return m.Staker
	}
	return ""
}

func (m *CommissionChangeEntry) GetPoolId() uint64 {
	if m != nil {
		return m.PoolId
	}
	return 0
}

func (m *CommissionChangeEntry) GetCreationDate() int64 {
	if m != nil {
		return m.CreationDate
	}
	return 0
}

// StakeFractionChangeEntry stores the information for an
// upcoming stake fraction change. A stake fraction change is
// only instant if it gets increased, if it gets decreased
// the staker needs to wait for the stake fraction change time
type StakeFractionChangeEntry struct {
	// index is needed for the queue-algorithm which
	// processes the commission changes
	Index uint64 `protobuf:"varint,1,opt,name=index,proto3" json:"index,omitempty"`
	// staker is the address of the affected staker
	Staker string `protobuf:"bytes,2,opt,name=staker,proto3" json:"staker,omitempty"`
	// pool_id ...
	PoolId uint64 `protobuf:"varint,3,opt,name=pool_id,json=poolId,proto3" json:"pool_id,omitempty"`
	// stake_fraction is the new stake fraction which will
	// be applied after the waiting time is over.
	StakeFraction cosmossdk_io_math.LegacyDec `protobuf:"bytes,4,opt,name=stake_fraction,json=stakeFraction,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"stake_fraction"`
	// creation_date is the UNIX-timestamp in seconds
	// when the entry was created.
	CreationDate int64 `protobuf:"varint,5,opt,name=creation_date,json=creationDate,proto3" json:"creation_date,omitempty"`
}

func (m *StakeFractionChangeEntry) Reset()         { *m = StakeFractionChangeEntry{} }
func (m *StakeFractionChangeEntry) String() string { return proto.CompactTextString(m) }
func (*StakeFractionChangeEntry) ProtoMessage()    {}
func (*StakeFractionChangeEntry) Descriptor() ([]byte, []int) {
	return fileDescriptor_d209d1a2a74d375d, []int{3}
}
func (m *StakeFractionChangeEntry) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StakeFractionChangeEntry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StakeFractionChangeEntry.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StakeFractionChangeEntry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StakeFractionChangeEntry.Merge(m, src)
}
func (m *StakeFractionChangeEntry) XXX_Size() int {
	return m.Size()
}
func (m *StakeFractionChangeEntry) XXX_DiscardUnknown() {
	xxx_messageInfo_StakeFractionChangeEntry.DiscardUnknown(m)
}

var xxx_messageInfo_StakeFractionChangeEntry proto.InternalMessageInfo

func (m *StakeFractionChangeEntry) GetIndex() uint64 {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *StakeFractionChangeEntry) GetStaker() string {
	if m != nil {
		return m.Staker
	}
	return ""
}

func (m *StakeFractionChangeEntry) GetPoolId() uint64 {
	if m != nil {
		return m.PoolId
	}
	return 0
}

func (m *StakeFractionChangeEntry) GetCreationDate() int64 {
	if m != nil {
		return m.CreationDate
	}
	return 0
}

// LeavePoolEntry stores the information for an upcoming
// pool leave. A staker can't leave a pool instantly.
// Instead a the `LeaveTime` needs to be awaited.
// If a staker start to leave a pool, it will be shown
// in the UI to the delegators.
type LeavePoolEntry struct {
	// index is needed for the queue-algorithm which
	// processes the commission changes
	Index uint64 `protobuf:"varint,1,opt,name=index,proto3" json:"index,omitempty"`
	// staker is the address of the affected staker
	Staker string `protobuf:"bytes,2,opt,name=staker,proto3" json:"staker,omitempty"`
	// pool_id indicates the pool the staker wants to leave
	PoolId uint64 `protobuf:"varint,3,opt,name=pool_id,json=poolId,proto3" json:"pool_id,omitempty"`
	// creation_date is the UNIX-timestamp in seconds
	// when the entry was created.
	CreationDate int64 `protobuf:"varint,4,opt,name=creation_date,json=creationDate,proto3" json:"creation_date,omitempty"`
}

func (m *LeavePoolEntry) Reset()         { *m = LeavePoolEntry{} }
func (m *LeavePoolEntry) String() string { return proto.CompactTextString(m) }
func (*LeavePoolEntry) ProtoMessage()    {}
func (*LeavePoolEntry) Descriptor() ([]byte, []int) {
	return fileDescriptor_d209d1a2a74d375d, []int{4}
}
func (m *LeavePoolEntry) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LeavePoolEntry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LeavePoolEntry.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LeavePoolEntry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LeavePoolEntry.Merge(m, src)
}
func (m *LeavePoolEntry) XXX_Size() int {
	return m.Size()
}
func (m *LeavePoolEntry) XXX_DiscardUnknown() {
	xxx_messageInfo_LeavePoolEntry.DiscardUnknown(m)
}

var xxx_messageInfo_LeavePoolEntry proto.InternalMessageInfo

func (m *LeavePoolEntry) GetIndex() uint64 {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *LeavePoolEntry) GetStaker() string {
	if m != nil {
		return m.Staker
	}
	return ""
}

func (m *LeavePoolEntry) GetPoolId() uint64 {
	if m != nil {
		return m.PoolId
	}
	return 0
}

func (m *LeavePoolEntry) GetCreationDate() int64 {
	if m != nil {
		return m.CreationDate
	}
	return 0
}

// UnbondingState stores the state for the unbonding of stakes and delegations.
type QueueState struct {
	// low_index is the tail of the queue. It is the
	// oldest entry in the queue. If this entry isn't
	// due, non of the other entries is.
	LowIndex uint64 `protobuf:"varint,1,opt,name=low_index,json=lowIndex,proto3" json:"low_index,omitempty"`
	// high_index is the head of the queue. New entries
	// are added to the top.
	HighIndex uint64 `protobuf:"varint,2,opt,name=high_index,json=highIndex,proto3" json:"high_index,omitempty"`
}

func (m *QueueState) Reset()         { *m = QueueState{} }
func (m *QueueState) String() string { return proto.CompactTextString(m) }
func (*QueueState) ProtoMessage()    {}
func (*QueueState) Descriptor() ([]byte, []int) {
	return fileDescriptor_d209d1a2a74d375d, []int{5}
}
func (m *QueueState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueueState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueueState.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueueState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueueState.Merge(m, src)
}
func (m *QueueState) XXX_Size() int {
	return m.Size()
}
func (m *QueueState) XXX_DiscardUnknown() {
	xxx_messageInfo_QueueState.DiscardUnknown(m)
}

var xxx_messageInfo_QueueState proto.InternalMessageInfo

func (m *QueueState) GetLowIndex() uint64 {
	if m != nil {
		return m.LowIndex
	}
	return 0
}

func (m *QueueState) GetHighIndex() uint64 {
	if m != nil {
		return m.HighIndex
	}
	return 0
}

// MultiCoinPendingRewardsEntry ...
type MultiCoinPendingRewardsEntry struct {
	// index is needed for the queue-algorithm which
	// processes the commission changes
	Index uint64 `protobuf:"varint,1,opt,name=index,proto3" json:"index,omitempty"`
	// staker is the address of the affected staker
	Address string `protobuf:"bytes,2,opt,name=address,proto3" json:"address,omitempty"`
	// rewards ...
	Rewards      github_com_cosmos_cosmos_sdk_types.Coins `protobuf:"bytes,3,rep,name=rewards,proto3,castrepeated=github.com/cosmos/cosmos-sdk/types.Coins" json:"rewards"`
	CreationDate int64                                    `protobuf:"varint,4,opt,name=creation_date,json=creationDate,proto3" json:"creation_date,omitempty"`
}

func (m *MultiCoinPendingRewardsEntry) Reset()         { *m = MultiCoinPendingRewardsEntry{} }
func (m *MultiCoinPendingRewardsEntry) String() string { return proto.CompactTextString(m) }
func (*MultiCoinPendingRewardsEntry) ProtoMessage()    {}
func (*MultiCoinPendingRewardsEntry) Descriptor() ([]byte, []int) {
	return fileDescriptor_d209d1a2a74d375d, []int{6}
}
func (m *MultiCoinPendingRewardsEntry) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MultiCoinPendingRewardsEntry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MultiCoinPendingRewardsEntry.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MultiCoinPendingRewardsEntry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MultiCoinPendingRewardsEntry.Merge(m, src)
}
func (m *MultiCoinPendingRewardsEntry) XXX_Size() int {
	return m.Size()
}
func (m *MultiCoinPendingRewardsEntry) XXX_DiscardUnknown() {
	xxx_messageInfo_MultiCoinPendingRewardsEntry.DiscardUnknown(m)
}

var xxx_messageInfo_MultiCoinPendingRewardsEntry proto.InternalMessageInfo

func (m *MultiCoinPendingRewardsEntry) GetIndex() uint64 {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *MultiCoinPendingRewardsEntry) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *MultiCoinPendingRewardsEntry) GetRewards() github_com_cosmos_cosmos_sdk_types.Coins {
	if m != nil {
		return m.Rewards
	}
	return nil
}

func (m *MultiCoinPendingRewardsEntry) GetCreationDate() int64 {
	if m != nil {
		return m.CreationDate
	}
	return 0
}

// MultiCoinRefundPolicy ...
type MultiCoinRefundPolicy struct {
	Entries []*MultiCoinRefundDenomEntry `protobuf:"bytes,1,rep,name=entries,proto3" json:"entries,omitempty"`
}

func (m *MultiCoinRefundPolicy) Reset()         { *m = MultiCoinRefundPolicy{} }
func (m *MultiCoinRefundPolicy) String() string { return proto.CompactTextString(m) }
func (*MultiCoinRefundPolicy) ProtoMessage()    {}
func (*MultiCoinRefundPolicy) Descriptor() ([]byte, []int) {
	return fileDescriptor_d209d1a2a74d375d, []int{7}
}
func (m *MultiCoinRefundPolicy) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MultiCoinRefundPolicy) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MultiCoinRefundPolicy.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MultiCoinRefundPolicy) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MultiCoinRefundPolicy.Merge(m, src)
}
func (m *MultiCoinRefundPolicy) XXX_Size() int {
	return m.Size()
}
func (m *MultiCoinRefundPolicy) XXX_DiscardUnknown() {
	xxx_messageInfo_MultiCoinRefundPolicy.DiscardUnknown(m)
}

var xxx_messageInfo_MultiCoinRefundPolicy proto.InternalMessageInfo

func (m *MultiCoinRefundPolicy) GetEntries() []*MultiCoinRefundDenomEntry {
	if m != nil {
		return m.Entries
	}
	return nil
}

// MultiCoinRefundDenomEntry ...
type MultiCoinRefundDenomEntry struct {
	Denom       string                            `protobuf:"bytes,1,opt,name=denom,proto3" json:"denom,omitempty"`
	PoolWeights []*MultiCoinRefundPoolWeightEntry `protobuf:"bytes,2,rep,name=pool_weights,json=poolWeights,proto3" json:"pool_weights,omitempty"`
}

func (m *MultiCoinRefundDenomEntry) Reset()         { *m = MultiCoinRefundDenomEntry{} }
func (m *MultiCoinRefundDenomEntry) String() string { return proto.CompactTextString(m) }
func (*MultiCoinRefundDenomEntry) ProtoMessage()    {}
func (*MultiCoinRefundDenomEntry) Descriptor() ([]byte, []int) {
	return fileDescriptor_d209d1a2a74d375d, []int{8}
}
func (m *MultiCoinRefundDenomEntry) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MultiCoinRefundDenomEntry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MultiCoinRefundDenomEntry.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MultiCoinRefundDenomEntry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MultiCoinRefundDenomEntry.Merge(m, src)
}
func (m *MultiCoinRefundDenomEntry) XXX_Size() int {
	return m.Size()
}
func (m *MultiCoinRefundDenomEntry) XXX_DiscardUnknown() {
	xxx_messageInfo_MultiCoinRefundDenomEntry.DiscardUnknown(m)
}

var xxx_messageInfo_MultiCoinRefundDenomEntry proto.InternalMessageInfo

func (m *MultiCoinRefundDenomEntry) GetDenom() string {
	if m != nil {
		return m.Denom
	}
	return ""
}

func (m *MultiCoinRefundDenomEntry) GetPoolWeights() []*MultiCoinRefundPoolWeightEntry {
	if m != nil {
		return m.PoolWeights
	}
	return nil
}

// MultiCoinRefundPoolWeightEntry ...
type MultiCoinRefundPoolWeightEntry struct {
	PoolId uint64                      `protobuf:"varint,1,opt,name=pool_id,json=poolId,proto3" json:"pool_id,omitempty"`
	Weight cosmossdk_io_math.LegacyDec `protobuf:"bytes,2,opt,name=weight,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"weight"`
}

func (m *MultiCoinRefundPoolWeightEntry) Reset()         { *m = MultiCoinRefundPoolWeightEntry{} }
func (m *MultiCoinRefundPoolWeightEntry) String() string { return proto.CompactTextString(m) }
func (*MultiCoinRefundPoolWeightEntry) ProtoMessage()    {}
func (*MultiCoinRefundPoolWeightEntry) Descriptor() ([]byte, []int) {
	return fileDescriptor_d209d1a2a74d375d, []int{9}
}
func (m *MultiCoinRefundPoolWeightEntry) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MultiCoinRefundPoolWeightEntry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MultiCoinRefundPoolWeightEntry.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MultiCoinRefundPoolWeightEntry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MultiCoinRefundPoolWeightEntry.Merge(m, src)
}
func (m *MultiCoinRefundPoolWeightEntry) XXX_Size() int {
	return m.Size()
}
func (m *MultiCoinRefundPoolWeightEntry) XXX_DiscardUnknown() {
	xxx_messageInfo_MultiCoinRefundPoolWeightEntry.DiscardUnknown(m)
}

var xxx_messageInfo_MultiCoinRefundPoolWeightEntry proto.InternalMessageInfo

func (m *MultiCoinRefundPoolWeightEntry) GetPoolId() uint64 {
	if m != nil {
		return m.PoolId
	}
	return 0
}

func init() {
	proto.RegisterEnum("kyve.stakers.v1beta1.SlashType", SlashType_name, SlashType_value)
	proto.RegisterType((*Staker)(nil), "kyve.stakers.v1beta1.Staker")
	proto.RegisterType((*PoolAccount)(nil), "kyve.stakers.v1beta1.PoolAccount")
	proto.RegisterType((*CommissionChangeEntry)(nil), "kyve.stakers.v1beta1.CommissionChangeEntry")
	proto.RegisterType((*StakeFractionChangeEntry)(nil), "kyve.stakers.v1beta1.StakeFractionChangeEntry")
	proto.RegisterType((*LeavePoolEntry)(nil), "kyve.stakers.v1beta1.LeavePoolEntry")
	proto.RegisterType((*QueueState)(nil), "kyve.stakers.v1beta1.QueueState")
	proto.RegisterType((*MultiCoinPendingRewardsEntry)(nil), "kyve.stakers.v1beta1.MultiCoinPendingRewardsEntry")
	proto.RegisterType((*MultiCoinRefundPolicy)(nil), "kyve.stakers.v1beta1.MultiCoinRefundPolicy")
	proto.RegisterType((*MultiCoinRefundDenomEntry)(nil), "kyve.stakers.v1beta1.MultiCoinRefundDenomEntry")
	proto.RegisterType((*MultiCoinRefundPoolWeightEntry)(nil), "kyve.stakers.v1beta1.MultiCoinRefundPoolWeightEntry")
}

func init() {
	proto.RegisterFile("kyve/stakers/v1beta1/stakers.proto", fileDescriptor_d209d1a2a74d375d)
}

var fileDescriptor_d209d1a2a74d375d = []byte{
	// 903 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x56, 0x4d, 0x6f, 0x1b, 0xc5,
	0x1b, 0xf7, 0xda, 0xae, 0x1d, 0x3f, 0xe9, 0x8b, 0x33, 0xff, 0x24, 0xff, 0x6d, 0x4a, 0x9d, 0xe2,
	0x5e, 0x42, 0x05, 0xbb, 0x2a, 0x2f, 0x27, 0x4e, 0x89, 0xed, 0xa8, 0x86, 0xb4, 0x31, 0x6b, 0xb7,
	0x55, 0xb9, 0x58, 0xe3, 0xdd, 0xe9, 0x7a, 0xf0, 0x7a, 0xc6, 0xec, 0x8c, 0xe3, 0x5a, 0x42, 0xe2,
	0x8a, 0x38, 0xf1, 0x1d, 0xb8, 0x00, 0x27, 0x3e, 0x46, 0x8e, 0x15, 0x27, 0xc4, 0xa1, 0x45, 0xc9,
	0x81, 0x4f, 0x81, 0x84, 0x66, 0x66, 0xd7, 0xdd, 0xb4, 0x4d, 0x15, 0x22, 0x7a, 0xb1, 0xf7, 0xf7,
	0xbc, 0x3f, 0xbf, 0x79, 0xf6, 0x99, 0x85, 0xfa, 0x68, 0x7e, 0x40, 0x5c, 0x21, 0xf1, 0x88, 0xc4,
	0xc2, 0x3d, 0xb8, 0x3d, 0x20, 0x12, 0xdf, 0x4e, 0xb1, 0x33, 0x89, 0xb9, 0xe4, 0x68, 0x55, 0xd9,
	0x38, 0xa9, 0x2c, 0xb1, 0xd9, 0x58, 0xc1, 0x63, 0xca, 0xb8, 0xab, 0x7f, 0x8d, 0xe1, 0x46, 0xcd,
	0xe7, 0x62, 0xcc, 0x85, 0x3b, 0xc0, 0x82, 0x2c, 0x62, 0xf9, 0x9c, 0xb2, 0x44, 0xbf, 0x1a, 0xf2,
	0x90, 0xeb, 0x47, 0x57, 0x3d, 0x19, 0x69, 0xfd, 0xef, 0x3c, 0x94, 0xba, 0x3a, 0x38, 0xb2, 0xa1,
	0x8c, 0x83, 0x20, 0x26, 0x42, 0xd8, 0xd6, 0x0d, 0x6b, 0xab, 0xe2, 0xa5, 0x10, 0x35, 0x00, 0x7c,
	0x3e, 0x1e, 0x53, 0x21, 0x28, 0x67, 0x76, 0x5e, 0x29, 0x77, 0x6e, 0x1e, 0x3e, 0xdb, 0xcc, 0xfd,
	0xf1, 0x6c, 0xf3, 0x9a, 0x49, 0x2b, 0x82, 0x91, 0x43, 0xb9, 0x3b, 0xc6, 0x72, 0xe8, 0xec, 0x91,
	0x10, 0xfb, 0xf3, 0x26, 0xf1, 0xbd, 0x8c, 0x9b, 0x0a, 0x3f, 0xe6, 0x8c, 0x8e, 0x48, 0x6c, 0x17,
	0x4c, 0xf8, 0x04, 0x2a, 0xcd, 0x8c, 0x0c, 0x04, 0x95, 0xc4, 0x2e, 0x1a, 0x4d, 0x02, 0xd1, 0x06,
	0x2c, 0xd1, 0x80, 0x30, 0x49, 0xe5, 0xdc, 0xbe, 0xa0, 0x55, 0x0b, 0x8c, 0xde, 0x83, 0xaa, 0x20,
	0xfe, 0x34, 0xa6, 0x72, 0xde, 0xf7, 0x39, 0x93, 0xd8, 0x97, 0x76, 0x49, 0xdb, 0x5c, 0x49, 0xe5,
	0x0d, 0x23, 0x56, 0x09, 0x02, 0x22, 0x31, 0x8d, 0x84, 0x5d, 0x36, 0x09, 0x12, 0x88, 0xbe, 0x05,
	0xf4, 0xa2, 0xc4, 0x7e, 0x4c, 0x66, 0x38, 0x0e, 0x84, 0xbd, 0x74, 0xa3, 0xb0, 0xb5, 0xfc, 0xe1,
	0x55, 0xc7, 0xb4, 0xe6, 0x28, 0x46, 0x53, 0xe6, 0x9d, 0x06, 0xa7, 0x6c, 0xe7, 0x13, 0xd5, 0xfc,
	0x2f, 0xcf, 0x37, 0xb7, 0x42, 0x2a, 0x87, 0xd3, 0x81, 0xe3, 0xf3, 0xb1, 0x9b, 0xd0, 0x6f, 0xfe,
	0x3e, 0x10, 0xc1, 0xc8, 0x95, 0xf3, 0x09, 0x11, 0xda, 0x41, 0xfc, 0xf4, 0xd7, 0xaf, 0xb7, 0x2c,
	0x6f, 0xe5, 0x45, 0x2e, 0xcf, 0xa4, 0xaa, 0xff, 0x9c, 0x87, 0xe5, 0x0e, 0xe7, 0xd1, 0xb6, 0xef,
	0xf3, 0x29, 0x93, 0xe8, 0xff, 0x50, 0x9e, 0x70, 0x1e, 0xf5, 0x69, 0xa0, 0x0f, 0xa1, 0xe8, 0x95,
	0x14, 0x6c, 0x07, 0x68, 0x1d, 0x4a, 0x66, 0x08, 0x0c, 0xff, 0x5e, 0x82, 0xd0, 0xbb, 0x70, 0x51,
	0x3b, 0xa4, 0x47, 0x67, 0xb8, 0x5d, 0x56, 0xb2, 0xed, 0xe4, 0xf8, 0xd6, 0xa1, 0x34, 0xe1, 0x94,
	0x49, 0xa1, 0xe9, 0xd5, 0x21, 0x15, 0x42, 0xd7, 0x01, 0xa8, 0xe8, 0x47, 0x04, 0x1f, 0x50, 0x16,
	0x6a, 0x7e, 0x97, 0xbc, 0x0a, 0x15, 0x7b, 0x46, 0xf0, 0xd2, 0xa9, 0x97, 0xce, 0x77, 0xea, 0x9f,
	0xc1, 0x65, 0x5d, 0x68, 0xff, 0x71, 0x8c, 0x7d, 0xa9, 0x02, 0x95, 0xcf, 0x1e, 0xe8, 0x92, 0x76,
	0xdd, 0x4d, 0x3c, 0xeb, 0x87, 0x16, 0xac, 0x35, 0x16, 0xa1, 0x1b, 0x43, 0xcc, 0x42, 0xd2, 0x62,
	0x32, 0x9e, 0xa3, 0x55, 0xb8, 0x40, 0x59, 0x40, 0x9e, 0x24, 0x9c, 0x19, 0x70, 0x2a, 0x65, 0x19,
	0x8e, 0x0b, 0x27, 0x38, 0x3e, 0xd9, 0x71, 0xf1, 0x7c, 0x1d, 0xdf, 0x84, 0x4b, 0x7e, 0x4c, 0xb0,
	0xaa, 0xb8, 0x1f, 0x60, 0x49, 0x34, 0xb1, 0x05, 0xef, 0x62, 0x2a, 0x6c, 0x62, 0x49, 0xea, 0xbf,
	0x59, 0x60, 0x77, 0xb3, 0xcd, 0xbd, 0x85, 0x6e, 0x5e, 0xa5, 0xbe, 0x78, 0x5e, 0xea, 0xcf, 0xd6,
	0xd4, 0x37, 0x70, 0x59, 0xcd, 0x0e, 0x51, 0xf3, 0xfc, 0x9f, 0x76, 0xf2, 0x4a, 0xf6, 0xe2, 0x6b,
	0xb2, 0xdf, 0x01, 0xf8, 0x62, 0x4a, 0xa6, 0xa4, 0x2b, 0xb1, 0x24, 0xe8, 0x1a, 0x54, 0x22, 0x3e,
	0xeb, 0x67, 0xb3, 0x2f, 0x45, 0x7c, 0xd6, 0xd6, 0x05, 0x5c, 0x07, 0x18, 0xd2, 0x70, 0x98, 0x68,
	0xf3, 0x5a, 0x5b, 0x51, 0x12, 0xad, 0xae, 0x3f, 0xb7, 0xe0, 0x9d, 0xbb, 0xd3, 0x48, 0x52, 0xf5,
	0xea, 0x76, 0x08, 0x0b, 0x28, 0x0b, 0x93, 0xf7, 0xf5, 0x4d, 0x6d, 0x65, 0xf6, 0x67, 0xfe, 0xe4,
	0xfe, 0xfc, 0x0a, 0xca, 0xe9, 0x6a, 0x29, 0xbc, 0xa5, 0xd5, 0x92, 0x26, 0x38, 0x1b, 0x57, 0x03,
	0x58, 0x5b, 0x34, 0xe8, 0x91, 0xc7, 0x53, 0x16, 0x74, 0x78, 0x44, 0xfd, 0x39, 0x6a, 0x43, 0x99,
	0x30, 0x19, 0x53, 0xa2, 0xee, 0x00, 0x55, 0xa9, 0xeb, 0xbc, 0xee, 0xfe, 0x71, 0x5e, 0xf2, 0x6e,
	0x12, 0xc6, 0xc7, 0x9a, 0x1b, 0x2f, 0xf5, 0xaf, 0x7f, 0x6f, 0xc1, 0xd5, 0x53, 0xcd, 0x14, 0x85,
	0x81, 0x42, 0xc9, 0x55, 0x63, 0x00, 0x7a, 0x98, 0x2c, 0xb3, 0x19, 0xa1, 0xe1, 0x50, 0x2a, 0x1e,
	0x55, 0x0d, 0x1f, 0x9f, 0xa9, 0x06, 0x35, 0x75, 0x0f, 0xb5, 0x9f, 0x29, 0x44, 0xaf, 0x40, 0x23,
	0x10, 0xf5, 0x03, 0xa8, 0xbd, 0xd9, 0xfc, 0xf4, 0xc5, 0xfb, 0x29, 0x94, 0x4c, 0x39, 0xff, 0xe6,
	0xe2, 0x4b, 0x5c, 0x6e, 0x7d, 0x0d, 0x95, 0x6e, 0x84, 0xc5, 0xb0, 0x37, 0x9f, 0xa8, 0xdb, 0x6c,
	0xbd, 0xbb, 0xb7, 0xdd, 0xbd, 0xd3, 0xef, 0x3d, 0xea, 0xb4, 0xfa, 0xf7, 0xef, 0x75, 0x3b, 0xad,
	0x46, 0x7b, 0xb7, 0xdd, 0x6a, 0x56, 0x73, 0x68, 0x1d, 0x50, 0x46, 0xd7, 0x6b, 0xdf, 0x6d, 0xed,
	0xdf, 0xef, 0x55, 0x2d, 0xf4, 0x3f, 0xb8, 0x92, 0x91, 0x3f, 0xd8, 0xef, 0xb5, 0xaa, 0x79, 0xb4,
	0x06, 0x2b, 0xd9, 0x40, 0x9d, 0xbd, 0xfd, 0xed, 0x66, 0xb5, 0xb0, 0x51, 0xfc, 0xee, 0xc7, 0x5a,
	0x6e, 0x67, 0xf7, 0xf0, 0xa8, 0x66, 0x3d, 0x3d, 0xaa, 0x59, 0x7f, 0x1e, 0xd5, 0xac, 0x1f, 0x8e,
	0x6b, 0xb9, 0xa7, 0xc7, 0xb5, 0xdc, 0xef, 0xc7, 0xb5, 0xdc, 0x97, 0xef, 0x67, 0x46, 0xea, 0xf3,
	0x47, 0x0f, 0x5a, 0xf7, 0x88, 0x9c, 0xf1, 0x78, 0xe4, 0xfa, 0x43, 0x4c, 0x99, 0xfb, 0x64, 0xf1,
	0x21, 0xa2, 0x87, 0x6b, 0x50, 0xd2, 0x1f, 0x08, 0x1f, 0xfd, 0x13, 0x00, 0x00, 0xff, 0xff, 0x2a,
	0xee, 0xd7, 0x4f, 0xa5, 0x08, 0x00, 0x00,
}

func (m *Staker) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Staker) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Staker) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.CommissionRewards) > 0 {
		for iNdEx := len(m.CommissionRewards) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CommissionRewards[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintStakers(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.Details) > 0 {
		i -= len(m.Details)
		copy(dAtA[i:], m.Details)
		i = encodeVarintStakers(dAtA, i, uint64(len(m.Details)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.SecurityContact) > 0 {
		i -= len(m.SecurityContact)
		copy(dAtA[i:], m.SecurityContact)
		i = encodeVarintStakers(dAtA, i, uint64(len(m.SecurityContact)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Identity) > 0 {
		i -= len(m.Identity)
		copy(dAtA[i:], m.Identity)
		i = encodeVarintStakers(dAtA, i, uint64(len(m.Identity)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Website) > 0 {
		i -= len(m.Website)
		copy(dAtA[i:], m.Website)
		i = encodeVarintStakers(dAtA, i, uint64(len(m.Website)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Moniker) > 0 {
		i -= len(m.Moniker)
		copy(dAtA[i:], m.Moniker)
		i = encodeVarintStakers(dAtA, i, uint64(len(m.Moniker)))
		i--
		dAtA[i] = 0x1a
	}
	{
		size := m.Commission.Size()
		i -= size
		if _, err := m.Commission.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintStakers(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintStakers(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PoolAccount) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PoolAccount) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PoolAccount) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.StakeFraction.Size()
		i -= size
		if _, err := m.StakeFraction.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintStakers(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x3a
	{
		size := m.Commission.Size()
		i -= size
		if _, err := m.Commission.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintStakers(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	if m.IsLeaving {
		i--
		if m.IsLeaving {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.Points != 0 {
		i = encodeVarintStakers(dAtA, i, uint64(m.Points))
		i--
		dAtA[i] = 0x20
	}
	if len(m.PoolAddress) > 0 {
		i -= len(m.PoolAddress)
		copy(dAtA[i:], m.PoolAddress)
		i = encodeVarintStakers(dAtA, i, uint64(len(m.PoolAddress)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Staker) > 0 {
		i -= len(m.Staker)
		copy(dAtA[i:], m.Staker)
		i = encodeVarintStakers(dAtA, i, uint64(len(m.Staker)))
		i--
		dAtA[i] = 0x12
	}
	if m.PoolId != 0 {
		i = encodeVarintStakers(dAtA, i, uint64(m.PoolId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CommissionChangeEntry) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CommissionChangeEntry) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CommissionChangeEntry) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.CreationDate != 0 {
		i = encodeVarintStakers(dAtA, i, uint64(m.CreationDate))
		i--
		dAtA[i] = 0x28
	}
	{
		size := m.Commission.Size()
		i -= size
		if _, err := m.Commission.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintStakers(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if m.PoolId != 0 {
		i = encodeVarintStakers(dAtA, i, uint64(m.PoolId))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Staker) > 0 {
		i -= len(m.Staker)
		copy(dAtA[i:], m.Staker)
		i = encodeVarintStakers(dAtA, i, uint64(len(m.Staker)))
		i--
		dAtA[i] = 0x12
	}
	if m.Index != 0 {
		i = encodeVarintStakers(dAtA, i, uint64(m.Index))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *StakeFractionChangeEntry) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StakeFractionChangeEntry) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StakeFractionChangeEntry) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.CreationDate != 0 {
		i = encodeVarintStakers(dAtA, i, uint64(m.CreationDate))
		i--
		dAtA[i] = 0x28
	}
	{
		size := m.StakeFraction.Size()
		i -= size
		if _, err := m.StakeFraction.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintStakers(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if m.PoolId != 0 {
		i = encodeVarintStakers(dAtA, i, uint64(m.PoolId))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Staker) > 0 {
		i -= len(m.Staker)
		copy(dAtA[i:], m.Staker)
		i = encodeVarintStakers(dAtA, i, uint64(len(m.Staker)))
		i--
		dAtA[i] = 0x12
	}
	if m.Index != 0 {
		i = encodeVarintStakers(dAtA, i, uint64(m.Index))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LeavePoolEntry) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LeavePoolEntry) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LeavePoolEntry) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.CreationDate != 0 {
		i = encodeVarintStakers(dAtA, i, uint64(m.CreationDate))
		i--
		dAtA[i] = 0x20
	}
	if m.PoolId != 0 {
		i = encodeVarintStakers(dAtA, i, uint64(m.PoolId))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Staker) > 0 {
		i -= len(m.Staker)
		copy(dAtA[i:], m.Staker)
		i = encodeVarintStakers(dAtA, i, uint64(len(m.Staker)))
		i--
		dAtA[i] = 0x12
	}
	if m.Index != 0 {
		i = encodeVarintStakers(dAtA, i, uint64(m.Index))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *QueueState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueueState) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueueState) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.HighIndex != 0 {
		i = encodeVarintStakers(dAtA, i, uint64(m.HighIndex))
		i--
		dAtA[i] = 0x10
	}
	if m.LowIndex != 0 {
		i = encodeVarintStakers(dAtA, i, uint64(m.LowIndex))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MultiCoinPendingRewardsEntry) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MultiCoinPendingRewardsEntry) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MultiCoinPendingRewardsEntry) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.CreationDate != 0 {
		i = encodeVarintStakers(dAtA, i, uint64(m.CreationDate))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Rewards) > 0 {
		for iNdEx := len(m.Rewards) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Rewards[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintStakers(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintStakers(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0x12
	}
	if m.Index != 0 {
		i = encodeVarintStakers(dAtA, i, uint64(m.Index))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MultiCoinRefundPolicy) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MultiCoinRefundPolicy) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MultiCoinRefundPolicy) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Entries) > 0 {
		for iNdEx := len(m.Entries) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Entries[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintStakers(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *MultiCoinRefundDenomEntry) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MultiCoinRefundDenomEntry) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MultiCoinRefundDenomEntry) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.PoolWeights) > 0 {
		for iNdEx := len(m.PoolWeights) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PoolWeights[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintStakers(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Denom) > 0 {
		i -= len(m.Denom)
		copy(dAtA[i:], m.Denom)
		i = encodeVarintStakers(dAtA, i, uint64(len(m.Denom)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MultiCoinRefundPoolWeightEntry) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MultiCoinRefundPoolWeightEntry) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MultiCoinRefundPoolWeightEntry) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.Weight.Size()
		i -= size
		if _, err := m.Weight.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintStakers(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if m.PoolId != 0 {
		i = encodeVarintStakers(dAtA, i, uint64(m.PoolId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintStakers(dAtA []byte, offset int, v uint64) int {
	offset -= sovStakers(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Staker) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovStakers(uint64(l))
	}
	l = m.Commission.Size()
	n += 1 + l + sovStakers(uint64(l))
	l = len(m.Moniker)
	if l > 0 {
		n += 1 + l + sovStakers(uint64(l))
	}
	l = len(m.Website)
	if l > 0 {
		n += 1 + l + sovStakers(uint64(l))
	}
	l = len(m.Identity)
	if l > 0 {
		n += 1 + l + sovStakers(uint64(l))
	}
	l = len(m.SecurityContact)
	if l > 0 {
		n += 1 + l + sovStakers(uint64(l))
	}
	l = len(m.Details)
	if l > 0 {
		n += 1 + l + sovStakers(uint64(l))
	}
	if len(m.CommissionRewards) > 0 {
		for _, e := range m.CommissionRewards {
			l = e.Size()
			n += 1 + l + sovStakers(uint64(l))
		}
	}
	return n
}

func (m *PoolAccount) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PoolId != 0 {
		n += 1 + sovStakers(uint64(m.PoolId))
	}
	l = len(m.Staker)
	if l > 0 {
		n += 1 + l + sovStakers(uint64(l))
	}
	l = len(m.PoolAddress)
	if l > 0 {
		n += 1 + l + sovStakers(uint64(l))
	}
	if m.Points != 0 {
		n += 1 + sovStakers(uint64(m.Points))
	}
	if m.IsLeaving {
		n += 2
	}
	l = m.Commission.Size()
	n += 1 + l + sovStakers(uint64(l))
	l = m.StakeFraction.Size()
	n += 1 + l + sovStakers(uint64(l))
	return n
}

func (m *CommissionChangeEntry) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Index != 0 {
		n += 1 + sovStakers(uint64(m.Index))
	}
	l = len(m.Staker)
	if l > 0 {
		n += 1 + l + sovStakers(uint64(l))
	}
	if m.PoolId != 0 {
		n += 1 + sovStakers(uint64(m.PoolId))
	}
	l = m.Commission.Size()
	n += 1 + l + sovStakers(uint64(l))
	if m.CreationDate != 0 {
		n += 1 + sovStakers(uint64(m.CreationDate))
	}
	return n
}

func (m *StakeFractionChangeEntry) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Index != 0 {
		n += 1 + sovStakers(uint64(m.Index))
	}
	l = len(m.Staker)
	if l > 0 {
		n += 1 + l + sovStakers(uint64(l))
	}
	if m.PoolId != 0 {
		n += 1 + sovStakers(uint64(m.PoolId))
	}
	l = m.StakeFraction.Size()
	n += 1 + l + sovStakers(uint64(l))
	if m.CreationDate != 0 {
		n += 1 + sovStakers(uint64(m.CreationDate))
	}
	return n
}

func (m *LeavePoolEntry) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Index != 0 {
		n += 1 + sovStakers(uint64(m.Index))
	}
	l = len(m.Staker)
	if l > 0 {
		n += 1 + l + sovStakers(uint64(l))
	}
	if m.PoolId != 0 {
		n += 1 + sovStakers(uint64(m.PoolId))
	}
	if m.CreationDate != 0 {
		n += 1 + sovStakers(uint64(m.CreationDate))
	}
	return n
}

func (m *QueueState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LowIndex != 0 {
		n += 1 + sovStakers(uint64(m.LowIndex))
	}
	if m.HighIndex != 0 {
		n += 1 + sovStakers(uint64(m.HighIndex))
	}
	return n
}

func (m *MultiCoinPendingRewardsEntry) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Index != 0 {
		n += 1 + sovStakers(uint64(m.Index))
	}
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovStakers(uint64(l))
	}
	if len(m.Rewards) > 0 {
		for _, e := range m.Rewards {
			l = e.Size()
			n += 1 + l + sovStakers(uint64(l))
		}
	}
	if m.CreationDate != 0 {
		n += 1 + sovStakers(uint64(m.CreationDate))
	}
	return n
}

func (m *MultiCoinRefundPolicy) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Entries) > 0 {
		for _, e := range m.Entries {
			l = e.Size()
			n += 1 + l + sovStakers(uint64(l))
		}
	}
	return n
}

func (m *MultiCoinRefundDenomEntry) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Denom)
	if l > 0 {
		n += 1 + l + sovStakers(uint64(l))
	}
	if len(m.PoolWeights) > 0 {
		for _, e := range m.PoolWeights {
			l = e.Size()
			n += 1 + l + sovStakers(uint64(l))
		}
	}
	return n
}

func (m *MultiCoinRefundPoolWeightEntry) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PoolId != 0 {
		n += 1 + sovStakers(uint64(m.PoolId))
	}
	l = m.Weight.Size()
	n += 1 + l + sovStakers(uint64(l))
	return n
}

func sovStakers(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozStakers(x uint64) (n int) {
	return sovStakers(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Staker) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStakers
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Staker: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Staker: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStakers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStakers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStakers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Commission", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStakers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStakers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStakers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Commission.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Moniker", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStakers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStakers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStakers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Moniker = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Website", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStakers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStakers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStakers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Website = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Identity", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStakers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStakers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStakers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Identity = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SecurityContact", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStakers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStakers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStakers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SecurityContact = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Details", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStakers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStakers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStakers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Details = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommissionRewards", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStakers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStakers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStakers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CommissionRewards = append(m.CommissionRewards, types.Coin{})
			if err := m.CommissionRewards[len(m.CommissionRewards)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStakers(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStakers
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PoolAccount) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStakers
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PoolAccount: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PoolAccount: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PoolId", wireType)
			}
			m.PoolId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStakers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PoolId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Staker", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStakers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStakers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStakers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Staker = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PoolAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStakers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStakers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStakers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PoolAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Points", wireType)
			}
			m.Points = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStakers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Points |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsLeaving", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStakers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsLeaving = bool(v != 0)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Commission", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStakers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStakers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStakers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Commission.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StakeFraction", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStakers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStakers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStakers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.StakeFraction.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStakers(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStakers
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CommissionChangeEntry) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStakers
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CommissionChangeEntry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CommissionChangeEntry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStakers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Staker", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStakers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStakers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStakers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Staker = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PoolId", wireType)
			}
			m.PoolId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStakers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PoolId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Commission", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStakers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStakers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStakers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Commission.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreationDate", wireType)
			}
			m.CreationDate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStakers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreationDate |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStakers(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStakers
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StakeFractionChangeEntry) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStakers
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StakeFractionChangeEntry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StakeFractionChangeEntry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStakers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Staker", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStakers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStakers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStakers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Staker = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PoolId", wireType)
			}
			m.PoolId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStakers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PoolId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StakeFraction", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStakers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStakers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStakers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.StakeFraction.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreationDate", wireType)
			}
			m.CreationDate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStakers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreationDate |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStakers(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStakers
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LeavePoolEntry) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStakers
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LeavePoolEntry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LeavePoolEntry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStakers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Staker", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStakers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStakers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStakers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Staker = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PoolId", wireType)
			}
			m.PoolId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStakers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PoolId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreationDate", wireType)
			}
			m.CreationDate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStakers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreationDate |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStakers(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStakers
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueueState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStakers
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueueState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueueState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LowIndex", wireType)
			}
			m.LowIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStakers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LowIndex |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HighIndex", wireType)
			}
			m.HighIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStakers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HighIndex |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStakers(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStakers
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MultiCoinPendingRewardsEntry) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStakers
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MultiCoinPendingRewardsEntry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MultiCoinPendingRewardsEntry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStakers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStakers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStakers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStakers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rewards", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStakers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStakers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStakers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rewards = append(m.Rewards, types.Coin{})
			if err := m.Rewards[len(m.Rewards)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreationDate", wireType)
			}
			m.CreationDate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStakers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreationDate |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStakers(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStakers
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MultiCoinRefundPolicy) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStakers
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MultiCoinRefundPolicy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MultiCoinRefundPolicy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entries", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStakers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStakers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStakers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Entries = append(m.Entries, &MultiCoinRefundDenomEntry{})
			if err := m.Entries[len(m.Entries)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStakers(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStakers
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MultiCoinRefundDenomEntry) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStakers
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MultiCoinRefundDenomEntry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MultiCoinRefundDenomEntry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Denom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStakers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStakers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStakers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Denom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PoolWeights", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStakers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStakers
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStakers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PoolWeights = append(m.PoolWeights, &MultiCoinRefundPoolWeightEntry{})
			if err := m.PoolWeights[len(m.PoolWeights)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStakers(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStakers
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MultiCoinRefundPoolWeightEntry) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStakers
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MultiCoinRefundPoolWeightEntry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MultiCoinRefundPoolWeightEntry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PoolId", wireType)
			}
			m.PoolId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStakers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PoolId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Weight", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStakers
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStakers
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStakers
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Weight.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStakers(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStakers
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipStakers(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowStakers
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowStakers
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowStakers
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthStakers
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupStakers
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthStakers
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthStakers        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowStakers          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupStakers = fmt.Errorf("proto: unexpected end of group")
)
