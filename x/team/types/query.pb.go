// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: kyve/team/v1beta1/query.proto

package types

import (
	context "context"
	fmt "fmt"
	_ "github.com/cosmos/gogoproto/gogoproto"
	grpc1 "github.com/gogo/protobuf/grpc"
	proto "github.com/gogo/protobuf/proto"
	_ "google.golang.org/genproto/googleapis/api/annotations"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// QueryAccountsRequest is request type for the Query/TeamInfo RPC method.
type QueryTeamInfoRequest struct {
}

func (m *QueryTeamInfoRequest) Reset()         { *m = QueryTeamInfoRequest{} }
func (m *QueryTeamInfoRequest) String() string { return proto.CompactTextString(m) }
func (*QueryTeamInfoRequest) ProtoMessage()    {}
func (*QueryTeamInfoRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_6dd564523865e528, []int{0}
}
func (m *QueryTeamInfoRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryTeamInfoRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryTeamInfoRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryTeamInfoRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryTeamInfoRequest.Merge(m, src)
}
func (m *QueryTeamInfoRequest) XXX_Size() int {
	return m.Size()
}
func (m *QueryTeamInfoRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryTeamInfoRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QueryTeamInfoRequest proto.InternalMessageInfo

// QueryAccountsResponse is response type for the Query/TeamInfo RPC method.
type QueryTeamInfoResponse struct {
	// foundation is the authority foundation address
	FoundationAuthority string `protobuf:"bytes,1,opt,name=foundation_authority,json=foundationAuthority,proto3" json:"foundation_authority,omitempty"`
	// bcp is the authority bcp address
	BcpAuthority string `protobuf:"bytes,2,opt,name=bcp_authority,json=bcpAuthority,proto3" json:"bcp_authority,omitempty"`
	// total_team_allocation is the total allocation in $KYVE the team module has in order to reward team members
	TotalTeamAllocation uint64 `protobuf:"varint,3,opt,name=total_team_allocation,json=totalTeamAllocation,proto3" json:"total_team_allocation,omitempty"`
	// issued_team_allocation is the amount in $KYVE tied to team vesting accounts and which are not available anymore
	IssuedTeamAllocation uint64 `protobuf:"varint,4,opt,name=issued_team_allocation,json=issuedTeamAllocation,proto3" json:"issued_team_allocation,omitempty"`
	// available_team_allocation is the amount in $KYVE with which further team vesting accounts can be created.
	// if the available amount is zero no new vesting accounts can be created
	AvailableTeamAllocation uint64 `protobuf:"varint,5,opt,name=available_team_allocation,json=availableTeamAllocation,proto3" json:"available_team_allocation,omitempty"`
	// total_authority_rewards is the amount in $KYVE the authority has earned in total with inflation rewards.
	// Those rewards can be payed out for different purposes
	TotalAuthorityRewards uint64 `protobuf:"varint,6,opt,name=total_authority_rewards,json=totalAuthorityRewards,proto3" json:"total_authority_rewards,omitempty"`
	// claimed_authority_rewards is the amount in $KYVE of how much the authority already claimed
	ClaimedAuthorityRewards uint64 `protobuf:"varint,7,opt,name=claimed_authority_rewards,json=claimedAuthorityRewards,proto3" json:"claimed_authority_rewards,omitempty"`
	// available_authority_rewards is the amount in $KYVE of how much rewards the authority can claim right now
	AvailableAuthorityRewards uint64 `protobuf:"varint,8,opt,name=available_authority_rewards,json=availableAuthorityRewards,proto3" json:"available_authority_rewards,omitempty"`
	// total_account_rewards is the amount in $KYVE all team vesting accounts have ever received
	TotalAccountRewards uint64 `protobuf:"varint,9,opt,name=total_account_rewards,json=totalAccountRewards,proto3" json:"total_account_rewards,omitempty"`
	// claimed_account_rewards is the amount in $KYVE all team vesting accounts have ever claimed
	ClaimedAccountRewards uint64 `protobuf:"varint,10,opt,name=claimed_account_rewards,json=claimedAccountRewards,proto3" json:"claimed_account_rewards,omitempty"`
	// available_account_rewards is the total amount of $KYVE all team vesting accounts can currently claim
	AvailableAccountRewards uint64 `protobuf:"varint,11,opt,name=available_account_rewards,json=availableAccountRewards,proto3" json:"available_account_rewards,omitempty"`
	// required_module_balance is the balance the team module should have. If this is less than the module balance
	// something went wrong
	RequiredModuleBalance uint64 `protobuf:"varint,12,opt,name=required_module_balance,json=requiredModuleBalance,proto3" json:"required_module_balance,omitempty"`
	// team_module_balance is the team module balance in $KYVE
	TeamModuleBalance uint64 `protobuf:"varint,13,opt,name=team_module_balance,json=teamModuleBalance,proto3" json:"team_module_balance,omitempty"`
}

func (m *QueryTeamInfoResponse) Reset()         { *m = QueryTeamInfoResponse{} }
func (m *QueryTeamInfoResponse) String() string { return proto.CompactTextString(m) }
func (*QueryTeamInfoResponse) ProtoMessage()    {}
func (*QueryTeamInfoResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_6dd564523865e528, []int{1}
}
func (m *QueryTeamInfoResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryTeamInfoResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryTeamInfoResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryTeamInfoResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryTeamInfoResponse.Merge(m, src)
}
func (m *QueryTeamInfoResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryTeamInfoResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryTeamInfoResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryTeamInfoResponse proto.InternalMessageInfo

func (m *QueryTeamInfoResponse) GetFoundationAuthority() string {
	if m != nil {
		return m.FoundationAuthority
	}
	return ""
}

func (m *QueryTeamInfoResponse) GetBcpAuthority() string {
	if m != nil {
		return m.BcpAuthority
	}
	return ""
}

func (m *QueryTeamInfoResponse) GetTotalTeamAllocation() uint64 {
	if m != nil {
		return m.TotalTeamAllocation
	}
	return 0
}

func (m *QueryTeamInfoResponse) GetIssuedTeamAllocation() uint64 {
	if m != nil {
		return m.IssuedTeamAllocation
	}
	return 0
}

func (m *QueryTeamInfoResponse) GetAvailableTeamAllocation() uint64 {
	if m != nil {
		return m.AvailableTeamAllocation
	}
	return 0
}

func (m *QueryTeamInfoResponse) GetTotalAuthorityRewards() uint64 {
	if m != nil {
		return m.TotalAuthorityRewards
	}
	return 0
}

func (m *QueryTeamInfoResponse) GetClaimedAuthorityRewards() uint64 {
	if m != nil {
		return m.ClaimedAuthorityRewards
	}
	return 0
}

func (m *QueryTeamInfoResponse) GetAvailableAuthorityRewards() uint64 {
	if m != nil {
		return m.AvailableAuthorityRewards
	}
	return 0
}

func (m *QueryTeamInfoResponse) GetTotalAccountRewards() uint64 {
	if m != nil {
		return m.TotalAccountRewards
	}
	return 0
}

func (m *QueryTeamInfoResponse) GetClaimedAccountRewards() uint64 {
	if m != nil {
		return m.ClaimedAccountRewards
	}
	return 0
}

func (m *QueryTeamInfoResponse) GetAvailableAccountRewards() uint64 {
	if m != nil {
		return m.AvailableAccountRewards
	}
	return 0
}

func (m *QueryTeamInfoResponse) GetRequiredModuleBalance() uint64 {
	if m != nil {
		return m.RequiredModuleBalance
	}
	return 0
}

func (m *QueryTeamInfoResponse) GetTeamModuleBalance() uint64 {
	if m != nil {
		return m.TeamModuleBalance
	}
	return 0
}

// QueryAccountsRequest is request type for the Query/TeamVestingAccounts RPC method.
type QueryTeamVestingAccountsRequest struct {
}

func (m *QueryTeamVestingAccountsRequest) Reset()         { *m = QueryTeamVestingAccountsRequest{} }
func (m *QueryTeamVestingAccountsRequest) String() string { return proto.CompactTextString(m) }
func (*QueryTeamVestingAccountsRequest) ProtoMessage()    {}
func (*QueryTeamVestingAccountsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_6dd564523865e528, []int{2}
}
func (m *QueryTeamVestingAccountsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryTeamVestingAccountsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryTeamVestingAccountsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryTeamVestingAccountsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryTeamVestingAccountsRequest.Merge(m, src)
}
func (m *QueryTeamVestingAccountsRequest) XXX_Size() int {
	return m.Size()
}
func (m *QueryTeamVestingAccountsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryTeamVestingAccountsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QueryTeamVestingAccountsRequest proto.InternalMessageInfo

// QueryAccountsResponse is response type for the Query/TeamVestingAccounts RPC method.
type QueryTeamVestingAccountsResponse struct {
	// accounts holds all the team vesting accounts of this module.
	Accounts []TeamVestingAccount `protobuf:"bytes,1,rep,name=accounts,proto3" json:"accounts"`
}

func (m *QueryTeamVestingAccountsResponse) Reset()         { *m = QueryTeamVestingAccountsResponse{} }
func (m *QueryTeamVestingAccountsResponse) String() string { return proto.CompactTextString(m) }
func (*QueryTeamVestingAccountsResponse) ProtoMessage()    {}
func (*QueryTeamVestingAccountsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_6dd564523865e528, []int{3}
}
func (m *QueryTeamVestingAccountsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryTeamVestingAccountsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryTeamVestingAccountsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryTeamVestingAccountsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryTeamVestingAccountsResponse.Merge(m, src)
}
func (m *QueryTeamVestingAccountsResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryTeamVestingAccountsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryTeamVestingAccountsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryTeamVestingAccountsResponse proto.InternalMessageInfo

func (m *QueryTeamVestingAccountsResponse) GetAccounts() []TeamVestingAccount {
	if m != nil {
		return m.Accounts
	}
	return nil
}

// QueryTeamVestingAccountRequest is request type for the Query/TeamVestingAccount RPC method.
type QueryTeamVestingAccountRequest struct {
	// id is a unique identify for each vesting account, tied to a single team member.
	Id uint64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
}

func (m *QueryTeamVestingAccountRequest) Reset()         { *m = QueryTeamVestingAccountRequest{} }
func (m *QueryTeamVestingAccountRequest) String() string { return proto.CompactTextString(m) }
func (*QueryTeamVestingAccountRequest) ProtoMessage()    {}
func (*QueryTeamVestingAccountRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_6dd564523865e528, []int{4}
}
func (m *QueryTeamVestingAccountRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryTeamVestingAccountRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryTeamVestingAccountRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryTeamVestingAccountRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryTeamVestingAccountRequest.Merge(m, src)
}
func (m *QueryTeamVestingAccountRequest) XXX_Size() int {
	return m.Size()
}
func (m *QueryTeamVestingAccountRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryTeamVestingAccountRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QueryTeamVestingAccountRequest proto.InternalMessageInfo

func (m *QueryTeamVestingAccountRequest) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

// QueryTeamVestingAccountResponse is the response type for the Query/TeamVestingAccount RPC method.
type QueryTeamVestingAccountResponse struct {
	// account holds the requested team vesting account
	Account TeamVestingAccount `protobuf:"bytes,1,opt,name=account,proto3" json:"account"`
}

func (m *QueryTeamVestingAccountResponse) Reset()         { *m = QueryTeamVestingAccountResponse{} }
func (m *QueryTeamVestingAccountResponse) String() string { return proto.CompactTextString(m) }
func (*QueryTeamVestingAccountResponse) ProtoMessage()    {}
func (*QueryTeamVestingAccountResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_6dd564523865e528, []int{5}
}
func (m *QueryTeamVestingAccountResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryTeamVestingAccountResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryTeamVestingAccountResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryTeamVestingAccountResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryTeamVestingAccountResponse.Merge(m, src)
}
func (m *QueryTeamVestingAccountResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryTeamVestingAccountResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryTeamVestingAccountResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryTeamVestingAccountResponse proto.InternalMessageInfo

func (m *QueryTeamVestingAccountResponse) GetAccount() TeamVestingAccount {
	if m != nil {
		return m.Account
	}
	return TeamVestingAccount{}
}

// QueryTeamCurrentVestingStatusRequest is request type for the Query/TeamCurrentVestingStatus RPC method.
type QueryTeamVestingStatusRequest struct {
	// id is a unique identify for each vesting account, tied to a single team member.
	Id uint64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
}

func (m *QueryTeamVestingStatusRequest) Reset()         { *m = QueryTeamVestingStatusRequest{} }
func (m *QueryTeamVestingStatusRequest) String() string { return proto.CompactTextString(m) }
func (*QueryTeamVestingStatusRequest) ProtoMessage()    {}
func (*QueryTeamVestingStatusRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_6dd564523865e528, []int{6}
}
func (m *QueryTeamVestingStatusRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryTeamVestingStatusRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryTeamVestingStatusRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryTeamVestingStatusRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryTeamVestingStatusRequest.Merge(m, src)
}
func (m *QueryTeamVestingStatusRequest) XXX_Size() int {
	return m.Size()
}
func (m *QueryTeamVestingStatusRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryTeamVestingStatusRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QueryTeamVestingStatusRequest proto.InternalMessageInfo

func (m *QueryTeamVestingStatusRequest) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

// QueryTeamCurrentVestingStatusResponse is the response type for the Query/TeamCurrentVestingStatus RPC method.
type QueryTeamVestingStatusResponse struct {
	// request_date ..
	RequestDate string `protobuf:"bytes,1,opt,name=request_date,json=requestDate,proto3" json:"request_date,omitempty"`
	// plan ...
	Plan *QueryVestingPlan `protobuf:"bytes,2,opt,name=plan,proto3" json:"plan,omitempty"`
	// status ..
	Status *QueryVestingStatus `protobuf:"bytes,3,opt,name=status,proto3" json:"status,omitempty"`
}

func (m *QueryTeamVestingStatusResponse) Reset()         { *m = QueryTeamVestingStatusResponse{} }
func (m *QueryTeamVestingStatusResponse) String() string { return proto.CompactTextString(m) }
func (*QueryTeamVestingStatusResponse) ProtoMessage()    {}
func (*QueryTeamVestingStatusResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_6dd564523865e528, []int{7}
}
func (m *QueryTeamVestingStatusResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryTeamVestingStatusResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryTeamVestingStatusResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryTeamVestingStatusResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryTeamVestingStatusResponse.Merge(m, src)
}
func (m *QueryTeamVestingStatusResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryTeamVestingStatusResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryTeamVestingStatusResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryTeamVestingStatusResponse proto.InternalMessageInfo

func (m *QueryTeamVestingStatusResponse) GetRequestDate() string {
	if m != nil {
		return m.RequestDate
	}
	return ""
}

func (m *QueryTeamVestingStatusResponse) GetPlan() *QueryVestingPlan {
	if m != nil {
		return m.Plan
	}
	return nil
}

func (m *QueryTeamVestingStatusResponse) GetStatus() *QueryVestingStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

// QueryTeamVestingStatusByTimeRequest is request type for the Query/TeamCurrentVestingByTimeStatus RPC method.
type QueryTeamVestingStatusByTimeRequest struct {
	// id is a unique identify for each vesting account, tied to a single team member.
	Id uint64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	// time is a unix timestamp of the time the vesting progress should be calculated
	Time uint64 `protobuf:"varint,2,opt,name=time,proto3" json:"time,omitempty"`
}

func (m *QueryTeamVestingStatusByTimeRequest) Reset()         { *m = QueryTeamVestingStatusByTimeRequest{} }
func (m *QueryTeamVestingStatusByTimeRequest) String() string { return proto.CompactTextString(m) }
func (*QueryTeamVestingStatusByTimeRequest) ProtoMessage()    {}
func (*QueryTeamVestingStatusByTimeRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_6dd564523865e528, []int{8}
}
func (m *QueryTeamVestingStatusByTimeRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryTeamVestingStatusByTimeRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryTeamVestingStatusByTimeRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryTeamVestingStatusByTimeRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryTeamVestingStatusByTimeRequest.Merge(m, src)
}
func (m *QueryTeamVestingStatusByTimeRequest) XXX_Size() int {
	return m.Size()
}
func (m *QueryTeamVestingStatusByTimeRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryTeamVestingStatusByTimeRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QueryTeamVestingStatusByTimeRequest proto.InternalMessageInfo

func (m *QueryTeamVestingStatusByTimeRequest) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *QueryTeamVestingStatusByTimeRequest) GetTime() uint64 {
	if m != nil {
		return m.Time
	}
	return 0
}

// QueryTeamVestingStatusByTimeResponse is the response type for the Query/TeamCurrentVestingByTimeStatus RPC method.
type QueryTeamVestingStatusByTimeResponse struct {
	// request_date ..
	RequestDate string `protobuf:"bytes,1,opt,name=request_date,json=requestDate,proto3" json:"request_date,omitempty"`
	// plan ...
	Plan *QueryVestingPlan `protobuf:"bytes,2,opt,name=plan,proto3" json:"plan,omitempty"`
	// status ..
	Status *QueryVestingStatus `protobuf:"bytes,3,opt,name=status,proto3" json:"status,omitempty"`
}

func (m *QueryTeamVestingStatusByTimeResponse) Reset()         { *m = QueryTeamVestingStatusByTimeResponse{} }
func (m *QueryTeamVestingStatusByTimeResponse) String() string { return proto.CompactTextString(m) }
func (*QueryTeamVestingStatusByTimeResponse) ProtoMessage()    {}
func (*QueryTeamVestingStatusByTimeResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_6dd564523865e528, []int{9}
}
func (m *QueryTeamVestingStatusByTimeResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryTeamVestingStatusByTimeResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryTeamVestingStatusByTimeResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryTeamVestingStatusByTimeResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryTeamVestingStatusByTimeResponse.Merge(m, src)
}
func (m *QueryTeamVestingStatusByTimeResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryTeamVestingStatusByTimeResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryTeamVestingStatusByTimeResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryTeamVestingStatusByTimeResponse proto.InternalMessageInfo

func (m *QueryTeamVestingStatusByTimeResponse) GetRequestDate() string {
	if m != nil {
		return m.RequestDate
	}
	return ""
}

func (m *QueryTeamVestingStatusByTimeResponse) GetPlan() *QueryVestingPlan {
	if m != nil {
		return m.Plan
	}
	return nil
}

func (m *QueryTeamVestingStatusByTimeResponse) GetStatus() *QueryVestingStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

// QueryVestingStatus is a type holding information about the account's vesting progress
type QueryVestingStatus struct {
	// total_vested_amount ...
	TotalVestedAmount uint64 `protobuf:"varint,1,opt,name=total_vested_amount,json=totalVestedAmount,proto3" json:"total_vested_amount,omitempty"`
	// total_unlocked_amount ...
	TotalUnlockedAmount uint64 `protobuf:"varint,2,opt,name=total_unlocked_amount,json=totalUnlockedAmount,proto3" json:"total_unlocked_amount,omitempty"`
	// current_claimable_amount ...
	CurrentClaimableAmount uint64 `protobuf:"varint,3,opt,name=current_claimable_amount,json=currentClaimableAmount,proto3" json:"current_claimable_amount,omitempty"`
	// locked_vested_amount ...
	LockedVestedAmount uint64 `protobuf:"varint,4,opt,name=locked_vested_amount,json=lockedVestedAmount,proto3" json:"locked_vested_amount,omitempty"`
	// remaining_unvested_amount ...
	RemainingUnvestedAmount uint64 `protobuf:"varint,5,opt,name=remaining_unvested_amount,json=remainingUnvestedAmount,proto3" json:"remaining_unvested_amount,omitempty"`
	// claimed_amount ...
	ClaimedAmount uint64 `protobuf:"varint,6,opt,name=claimed_amount,json=claimedAmount,proto3" json:"claimed_amount,omitempty"`
	// total_rewards ...
	TotalRewards uint64 `protobuf:"varint,7,opt,name=total_rewards,json=totalRewards,proto3" json:"total_rewards,omitempty"`
	// claimed_rewards ...
	ClaimedRewards uint64 `protobuf:"varint,8,opt,name=claimed_rewards,json=claimedRewards,proto3" json:"claimed_rewards,omitempty"`
	// available_rewards ...
	AvailableRewards uint64 `protobuf:"varint,9,opt,name=available_rewards,json=availableRewards,proto3" json:"available_rewards,omitempty"`
}

func (m *QueryVestingStatus) Reset()         { *m = QueryVestingStatus{} }
func (m *QueryVestingStatus) String() string { return proto.CompactTextString(m) }
func (*QueryVestingStatus) ProtoMessage()    {}
func (*QueryVestingStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_6dd564523865e528, []int{10}
}
func (m *QueryVestingStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryVestingStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryVestingStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryVestingStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryVestingStatus.Merge(m, src)
}
func (m *QueryVestingStatus) XXX_Size() int {
	return m.Size()
}
func (m *QueryVestingStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryVestingStatus.DiscardUnknown(m)
}

var xxx_messageInfo_QueryVestingStatus proto.InternalMessageInfo

func (m *QueryVestingStatus) GetTotalVestedAmount() uint64 {
	if m != nil {
		return m.TotalVestedAmount
	}
	return 0
}

func (m *QueryVestingStatus) GetTotalUnlockedAmount() uint64 {
	if m != nil {
		return m.TotalUnlockedAmount
	}
	return 0
}

func (m *QueryVestingStatus) GetCurrentClaimableAmount() uint64 {
	if m != nil {
		return m.CurrentClaimableAmount
	}
	return 0
}

func (m *QueryVestingStatus) GetLockedVestedAmount() uint64 {
	if m != nil {
		return m.LockedVestedAmount
	}
	return 0
}

func (m *QueryVestingStatus) GetRemainingUnvestedAmount() uint64 {
	if m != nil {
		return m.RemainingUnvestedAmount
	}
	return 0
}

func (m *QueryVestingStatus) GetClaimedAmount() uint64 {
	if m != nil {
		return m.ClaimedAmount
	}
	return 0
}

func (m *QueryVestingStatus) GetTotalRewards() uint64 {
	if m != nil {
		return m.TotalRewards
	}
	return 0
}

func (m *QueryVestingStatus) GetClaimedRewards() uint64 {
	if m != nil {
		return m.ClaimedRewards
	}
	return 0
}

func (m *QueryVestingStatus) GetAvailableRewards() uint64 {
	if m != nil {
		return m.AvailableRewards
	}
	return 0
}

// QueryVestingPlan is a type holding information about the account's vesting data which does not change
type QueryVestingPlan struct {
	// commencement ...
	Commencement string `protobuf:"bytes,1,opt,name=commencement,proto3" json:"commencement,omitempty"`
	// token_vesting_start ...
	TokenVestingStart string `protobuf:"bytes,2,opt,name=token_vesting_start,json=tokenVestingStart,proto3" json:"token_vesting_start,omitempty"`
	// token_vesting_finished ...
	TokenVestingFinished string `protobuf:"bytes,3,opt,name=token_vesting_finished,json=tokenVestingFinished,proto3" json:"token_vesting_finished,omitempty"`
	// token_unlock_start ...
	TokenUnlockStart string `protobuf:"bytes,4,opt,name=token_unlock_start,json=tokenUnlockStart,proto3" json:"token_unlock_start,omitempty"`
	// token_unlock_finished ...
	TokenUnlockFinished string `protobuf:"bytes,5,opt,name=token_unlock_finished,json=tokenUnlockFinished,proto3" json:"token_unlock_finished,omitempty"`
	// clawback ...
	Clawback uint64 `protobuf:"varint,6,opt,name=clawback,proto3" json:"clawback,omitempty"`
	// clawback_amount ...
	ClawbackAmount uint64 `protobuf:"varint,7,opt,name=clawback_amount,json=clawbackAmount,proto3" json:"clawback_amount,omitempty"`
	// maximum_vesting_amount ...
	MaximumVestingAmount uint64 `protobuf:"varint,8,opt,name=maximum_vesting_amount,json=maximumVestingAmount,proto3" json:"maximum_vesting_amount,omitempty"`
}

func (m *QueryVestingPlan) Reset()         { *m = QueryVestingPlan{} }
func (m *QueryVestingPlan) String() string { return proto.CompactTextString(m) }
func (*QueryVestingPlan) ProtoMessage()    {}
func (*QueryVestingPlan) Descriptor() ([]byte, []int) {
	return fileDescriptor_6dd564523865e528, []int{11}
}
func (m *QueryVestingPlan) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryVestingPlan) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryVestingPlan.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryVestingPlan) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryVestingPlan.Merge(m, src)
}
func (m *QueryVestingPlan) XXX_Size() int {
	return m.Size()
}
func (m *QueryVestingPlan) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryVestingPlan.DiscardUnknown(m)
}

var xxx_messageInfo_QueryVestingPlan proto.InternalMessageInfo

func (m *QueryVestingPlan) GetCommencement() string {
	if m != nil {
		return m.Commencement
	}
	return ""
}

func (m *QueryVestingPlan) GetTokenVestingStart() string {
	if m != nil {
		return m.TokenVestingStart
	}
	return ""
}

func (m *QueryVestingPlan) GetTokenVestingFinished() string {
	if m != nil {
		return m.TokenVestingFinished
	}
	return ""
}

func (m *QueryVestingPlan) GetTokenUnlockStart() string {
	if m != nil {
		return m.TokenUnlockStart
	}
	return ""
}

func (m *QueryVestingPlan) GetTokenUnlockFinished() string {
	if m != nil {
		return m.TokenUnlockFinished
	}
	return ""
}

func (m *QueryVestingPlan) GetClawback() uint64 {
	if m != nil {
		return m.Clawback
	}
	return 0
}

func (m *QueryVestingPlan) GetClawbackAmount() uint64 {
	if m != nil {
		return m.ClawbackAmount
	}
	return 0
}

func (m *QueryVestingPlan) GetMaximumVestingAmount() uint64 {
	if m != nil {
		return m.MaximumVestingAmount
	}
	return 0
}

func init() {
	proto.RegisterType((*QueryTeamInfoRequest)(nil), "kyve.team.v1beta1.QueryTeamInfoRequest")
	proto.RegisterType((*QueryTeamInfoResponse)(nil), "kyve.team.v1beta1.QueryTeamInfoResponse")
	proto.RegisterType((*QueryTeamVestingAccountsRequest)(nil), "kyve.team.v1beta1.QueryTeamVestingAccountsRequest")
	proto.RegisterType((*QueryTeamVestingAccountsResponse)(nil), "kyve.team.v1beta1.QueryTeamVestingAccountsResponse")
	proto.RegisterType((*QueryTeamVestingAccountRequest)(nil), "kyve.team.v1beta1.QueryTeamVestingAccountRequest")
	proto.RegisterType((*QueryTeamVestingAccountResponse)(nil), "kyve.team.v1beta1.QueryTeamVestingAccountResponse")
	proto.RegisterType((*QueryTeamVestingStatusRequest)(nil), "kyve.team.v1beta1.QueryTeamVestingStatusRequest")
	proto.RegisterType((*QueryTeamVestingStatusResponse)(nil), "kyve.team.v1beta1.QueryTeamVestingStatusResponse")
	proto.RegisterType((*QueryTeamVestingStatusByTimeRequest)(nil), "kyve.team.v1beta1.QueryTeamVestingStatusByTimeRequest")
	proto.RegisterType((*QueryTeamVestingStatusByTimeResponse)(nil), "kyve.team.v1beta1.QueryTeamVestingStatusByTimeResponse")
	proto.RegisterType((*QueryVestingStatus)(nil), "kyve.team.v1beta1.QueryVestingStatus")
	proto.RegisterType((*QueryVestingPlan)(nil), "kyve.team.v1beta1.QueryVestingPlan")
}

func init() { proto.RegisterFile("kyve/team/v1beta1/query.proto", fileDescriptor_6dd564523865e528) }

var fileDescriptor_6dd564523865e528 = []byte{
	// 1164 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x57, 0xcf, 0x6f, 0x1b, 0xc5,
	0x17, 0xcf, 0xba, 0xce, 0xaf, 0x97, 0xa4, 0xdf, 0x64, 0xe2, 0x26, 0xae, 0xbf, 0xad, 0x9b, 0x6e,
	0x5a, 0x35, 0xd0, 0xe2, 0x4d, 0x9c, 0x28, 0x45, 0x11, 0x20, 0x25, 0xa5, 0xa0, 0x0a, 0x81, 0xc0,
	0xb4, 0x91, 0xe0, 0xb2, 0x1a, 0xef, 0x4e, 0x9c, 0x91, 0xf7, 0x87, 0xb3, 0x3b, 0x9b, 0xd4, 0xaa,
	0x7a, 0x81, 0x7f, 0x00, 0x89, 0xbf, 0x03, 0x09, 0xce, 0x9c, 0xe0, 0xd4, 0x13, 0xaa, 0xc4, 0x05,
	0x2e, 0x08, 0x25, 0xfc, 0x0b, 0x1c, 0xb8, 0xa1, 0x7d, 0x33, 0xbb, 0xf6, 0x7a, 0xed, 0x36, 0xb9,
	0x71, 0x5b, 0xef, 0xe7, 0x7d, 0xe6, 0xf3, 0x79, 0x6f, 0x66, 0xde, 0x5b, 0xc3, 0xf5, 0x76, 0xf7,
	0x98, 0x19, 0x82, 0x51, 0xd7, 0x38, 0xde, 0x68, 0x32, 0x41, 0x37, 0x8c, 0xa3, 0x88, 0x05, 0xdd,
	0x5a, 0x27, 0xf0, 0x85, 0x4f, 0x16, 0x62, 0xb8, 0x16, 0xc3, 0x35, 0x05, 0x57, 0x4a, 0x2d, 0xbf,
	0xe5, 0x23, 0x6a, 0xc4, 0x4f, 0x32, 0xb0, 0x72, 0xad, 0xe5, 0xfb, 0x2d, 0x87, 0x19, 0xb4, 0xc3,
	0x0d, 0xea, 0x79, 0xbe, 0xa0, 0x82, 0xfb, 0x5e, 0x98, 0xa0, 0x79, 0x15, 0x5c, 0x13, 0x51, 0x7d,
	0x09, 0x4a, 0x9f, 0xc5, 0x9a, 0x8f, 0x19, 0x75, 0x1f, 0x79, 0x07, 0x7e, 0x83, 0x1d, 0x45, 0x2c,
	0x14, 0xfa, 0xef, 0xe3, 0x70, 0x65, 0x00, 0x08, 0x3b, 0xbe, 0x17, 0x32, 0xb2, 0x01, 0xa5, 0x03,
	0x3f, 0xf2, 0x6c, 0x14, 0x31, 0x69, 0x24, 0x0e, 0xfd, 0x80, 0x8b, 0x6e, 0x59, 0x5b, 0xd1, 0xd6,
	0xa6, 0x1b, 0x8b, 0x3d, 0x6c, 0x37, 0x81, 0xc8, 0x2a, 0xcc, 0x35, 0xad, 0x4e, 0x5f, 0x6c, 0x01,
	0x63, 0x67, 0x9b, 0x56, 0xa7, 0x17, 0x54, 0x87, 0x2b, 0xc2, 0x17, 0xd4, 0x31, 0x63, 0x77, 0x26,
	0x75, 0x1c, 0xdf, 0xc2, 0x65, 0xca, 0x97, 0x56, 0xb4, 0xb5, 0x62, 0x63, 0x11, 0xc1, 0xd8, 0xcd,
	0x6e, 0x0a, 0x91, 0x2d, 0x58, 0xe2, 0x61, 0x18, 0x31, 0x3b, 0x47, 0x2a, 0x22, 0xa9, 0x24, 0xd1,
	0x01, 0xd6, 0x0e, 0x5c, 0xa5, 0xc7, 0x94, 0x3b, 0xb4, 0xe9, 0xb0, 0x1c, 0x71, 0x1c, 0x89, 0xcb,
	0x69, 0xc0, 0x00, 0x77, 0x1b, 0x96, 0xa5, 0xcb, 0x34, 0x19, 0x33, 0x60, 0x27, 0x34, 0xb0, 0xc3,
	0xf2, 0x04, 0x32, 0x65, 0x12, 0x69, 0x5a, 0x0d, 0x09, 0xc6, 0x9a, 0x96, 0x43, 0xb9, 0xcb, 0xec,
	0x21, 0xcc, 0x49, 0xa9, 0xa9, 0x02, 0x72, 0xdc, 0xf7, 0xe0, 0xff, 0x3d, 0xbf, 0x79, 0xf6, 0x14,
	0xb2, 0x7b, 0x29, 0xe5, 0xf8, 0x69, 0x65, 0xa9, 0x65, 0xf9, 0x91, 0x27, 0x52, 0xe6, 0x74, 0x5f,
	0x65, 0x77, 0x25, 0x96, 0x70, 0xb6, 0x61, 0x39, 0xf5, 0x3b, 0xc0, 0x02, 0x99, 0x67, 0xe2, 0x36,
	0xcb, 0xcb, 0xd4, 0x76, 0x90, 0x39, 0x33, 0x50, 0xdb, 0xbc, 0x66, 0xc0, 0x8e, 0x22, 0x1e, 0x30,
	0xdb, 0x74, 0x7d, 0x3b, 0x72, 0x98, 0xd9, 0xa4, 0x0e, 0xf5, 0x2c, 0x56, 0x9e, 0x95, 0x9a, 0x09,
	0xfc, 0x31, 0xa2, 0x7b, 0x12, 0x24, 0x35, 0x58, 0xc4, 0x5d, 0x1c, 0xe0, 0xcc, 0x21, 0x67, 0x21,
	0x86, 0x32, 0xf1, 0xfa, 0x4d, 0xb8, 0x91, 0x1e, 0xed, 0x7d, 0x16, 0x0a, 0xee, 0xb5, 0x94, 0x93,
	0x30, 0x39, 0xfe, 0x6d, 0x58, 0x19, 0x1d, 0xa2, 0x2e, 0xc2, 0x87, 0x30, 0xa5, 0x12, 0x0c, 0xcb,
	0xda, 0xca, 0xa5, 0xb5, 0x99, 0xfa, 0xed, 0x5a, 0xee, 0xca, 0xd6, 0xf2, 0x2b, 0xec, 0x15, 0x5f,
	0xfc, 0x71, 0x63, 0xac, 0x91, 0x92, 0xf5, 0x75, 0xa8, 0x8e, 0x10, 0x53, 0x76, 0xc8, 0x65, 0x28,
	0x70, 0x1b, 0x6f, 0x58, 0xb1, 0x51, 0xe0, 0xb6, 0x7e, 0x38, 0x32, 0x83, 0xd4, 0xdd, 0x43, 0x98,
	0x54, 0x02, 0xc8, 0xbb, 0xa0, 0xb9, 0x84, 0xab, 0x1b, 0x70, 0x7d, 0x50, 0xe9, 0x73, 0x41, 0x45,
	0x14, 0x8e, 0xb2, 0xf6, 0xa3, 0x96, 0xcf, 0x26, 0x61, 0x28, 0x6b, 0x37, 0x61, 0x36, 0x90, 0x6c,
	0xd3, 0xa6, 0x82, 0xa9, 0xce, 0x31, 0xa3, 0xde, 0xbd, 0x4f, 0x05, 0x23, 0xf7, 0xa1, 0xd8, 0x71,
	0xa8, 0x87, 0x8d, 0x62, 0xa6, 0xbe, 0x3a, 0xc4, 0x3a, 0x6a, 0xa8, 0xf5, 0x3f, 0x75, 0xa8, 0xd7,
	0x40, 0x02, 0x79, 0x17, 0x26, 0x42, 0x54, 0xc3, 0xb6, 0x31, 0x3c, 0xeb, 0x7e, 0xaa, 0xb2, 0xa6,
	0x48, 0xfa, 0x23, 0x58, 0x1d, 0x6e, 0x7e, 0xaf, 0xfb, 0x98, 0xbb, 0x6c, 0x44, 0xd2, 0x84, 0x40,
	0x51, 0x70, 0x97, 0xa1, 0xdd, 0x62, 0x03, 0x9f, 0xf5, 0x9f, 0x34, 0xb8, 0xf5, 0xea, 0xb5, 0xfe,
	0xfb, 0xe5, 0xf8, 0xf9, 0x12, 0x90, 0x3c, 0x8c, 0x17, 0x0e, 0x1b, 0xca, 0x31, 0x0b, 0x45, 0xdc,
	0x21, 0xdc, 0xf4, 0x9c, 0xc5, 0x17, 0x2e, 0x86, 0xf6, 0x11, 0xd9, 0x45, 0xa0, 0xd7, 0x80, 0x22,
	0xcf, 0xf1, 0xad, 0x76, 0x8f, 0x51, 0xe8, 0x6b, 0x40, 0x4f, 0x14, 0xa6, 0x38, 0x6f, 0x43, 0xd9,
	0x8a, 0x82, 0x80, 0x79, 0xc2, 0xc4, 0x4e, 0x23, 0x1b, 0x8a, 0xa4, 0xc9, 0x89, 0xb0, 0xa4, 0xf0,
	0x07, 0x09, 0xac, 0x98, 0xeb, 0x50, 0x52, 0x2a, 0x59, 0x7b, 0x72, 0x24, 0x10, 0x89, 0x65, 0xfc,
	0xed, 0xc0, 0xd5, 0x80, 0xb9, 0x94, 0x7b, 0xdc, 0x6b, 0x99, 0x91, 0x97, 0xa5, 0xa9, 0x81, 0x90,
	0x06, 0x3c, 0x51, 0xb8, 0xe2, 0xde, 0x86, 0xcb, 0x69, 0xa3, 0x94, 0x04, 0x39, 0x07, 0xe6, 0x92,
	0xfe, 0x28, 0xc3, 0x56, 0x61, 0x4e, 0x96, 0x20, 0xdb, 0xf3, 0x67, 0xf1, 0x65, 0xd2, 0x00, 0xef,
	0xc0, 0xff, 0x92, 0xb5, 0xb2, 0xcd, 0x3d, 0x91, 0x48, 0x02, 0xef, 0xc2, 0x42, 0xaf, 0xcb, 0x66,
	0xbb, 0xf9, 0x7c, 0x0a, 0xa8, 0x60, 0xfd, 0x9f, 0x02, 0xcc, 0x0f, 0x1e, 0x0f, 0xa2, 0xc3, 0xac,
	0xe5, 0xbb, 0x2e, 0xf3, 0x2c, 0xe6, 0x32, 0xb5, 0x77, 0xd3, 0x8d, 0xcc, 0x3b, 0xb9, 0xcd, 0x6d,
	0xe6, 0x61, 0x1d, 0xe3, 0xd2, 0x84, 0x82, 0x06, 0x42, 0x0d, 0xef, 0x05, 0x84, 0x7a, 0xe7, 0x22,
	0x10, 0xf1, 0x34, 0xce, 0xc6, 0x1f, 0x70, 0x8f, 0x87, 0x87, 0xcc, 0xc6, 0x0d, 0x9b, 0x6e, 0x94,
	0xfa, 0x29, 0x1f, 0x28, 0x8c, 0xdc, 0x03, 0x22, 0x59, 0xf2, 0x70, 0x28, 0x91, 0x22, 0x32, 0xe6,
	0x11, 0x91, 0x27, 0x43, 0x6a, 0xe0, 0x51, 0xea, 0x8b, 0x4e, 0x25, 0xc6, 0xe5, 0xe7, 0x47, 0x1f,
	0x21, 0x55, 0xa8, 0xc0, 0x94, 0xe5, 0xd0, 0x93, 0x26, 0xb5, 0xda, 0x6a, 0x73, 0xd2, 0xdf, 0xaa,
	0xe4, 0xf8, 0x9c, 0xec, 0xdf, 0x64, 0x5a, 0x72, 0x7c, 0xad, 0x36, 0x70, 0x0b, 0x96, 0x5c, 0xfa,
	0x94, 0xbb, 0x91, 0x9b, 0xa6, 0xa7, 0xe2, 0xe5, 0x16, 0x95, 0x14, 0x9a, 0xb4, 0x53, 0xc4, 0xea,
	0x7f, 0x4f, 0xc0, 0x38, 0xd6, 0x9e, 0x7c, 0xad, 0xc1, 0x54, 0xf2, 0x2d, 0x45, 0xee, 0x8c, 0xba,
	0x86, 0x03, 0x9f, 0x61, 0x95, 0xb5, 0xd7, 0x07, 0xca, 0x2e, 0xa2, 0xdf, 0xfa, 0xea, 0xd7, 0xbf,
	0xbe, 0x2d, 0x54, 0xc9, 0x35, 0x63, 0xf8, 0xf7, 0x9e, 0xc9, 0x63, 0xe1, 0xef, 0x35, 0x58, 0x1c,
	0x32, 0xd3, 0x48, 0xfd, 0x55, 0x3a, 0xc3, 0x67, 0x64, 0x65, 0xf3, 0x42, 0x1c, 0x65, 0x73, 0x1d,
	0x6d, 0xbe, 0x49, 0xd6, 0x46, 0xd9, 0x4c, 0x8b, 0x9b, 0x58, 0xfb, 0x41, 0x03, 0x92, 0x5f, 0x91,
	0x6c, 0x9c, 0x5f, 0x3d, 0x31, 0x5c, 0xbf, 0x08, 0x45, 0xf9, 0xdd, 0x42, 0xbf, 0x35, 0x72, 0xef,
	0x9c, 0x7e, 0x8d, 0x67, 0xdc, 0x7e, 0x4e, 0xbe, 0xd3, 0x60, 0x21, 0xd7, 0xf6, 0xc9, 0xfa, 0x39,
	0xf4, 0x33, 0xc3, 0xb5, 0xb2, 0x71, 0x01, 0x86, 0x32, 0xbc, 0x89, 0x86, 0xdf, 0x22, 0x77, 0x5f,
	0x67, 0x58, 0xb6, 0x78, 0xe9, 0xf7, 0x17, 0x0d, 0x96, 0x47, 0x8c, 0x29, 0xb2, 0x7d, 0x6e, 0x0f,
	0x99, 0x19, 0x59, 0xb9, 0x7f, 0x61, 0x9e, 0xca, 0x60, 0x0f, 0x33, 0x78, 0x87, 0xec, 0x9c, 0x2f,
	0x03, 0xb3, 0xd9, 0x35, 0xe3, 0x81, 0x8b, 0x99, 0x18, 0xcf, 0xe2, 0xc7, 0xe7, 0x7b, 0x0f, 0x5e,
	0x9c, 0x56, 0xb5, 0x97, 0xa7, 0x55, 0xed, 0xcf, 0xd3, 0xaa, 0xf6, 0xcd, 0x59, 0x75, 0xec, 0xe5,
	0x59, 0x75, 0xec, 0xb7, 0xb3, 0xea, 0xd8, 0x97, 0x6f, 0xb4, 0xb8, 0x38, 0x8c, 0x9a, 0x35, 0xcb,
	0x77, 0x8d, 0x8f, 0xbe, 0xd8, 0x7f, 0xf8, 0x09, 0x13, 0x27, 0x7e, 0xd0, 0x36, 0xac, 0x43, 0xca,
	0x3d, 0xe3, 0xa9, 0x94, 0x13, 0xdd, 0x0e, 0x0b, 0x9b, 0x13, 0xf8, 0x17, 0x69, 0xf3, 0xdf, 0x00,
	0x00, 0x00, 0xff, 0xff, 0xc6, 0xf5, 0xa4, 0x1a, 0xa8, 0x0d, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// QueryClient is the client API for Query service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type QueryClient interface {
	// TeamInfo queries all important information from the team module
	TeamInfo(ctx context.Context, in *QueryTeamInfoRequest, opts ...grpc.CallOption) (*QueryTeamInfoResponse, error)
	// TeamVestingAccounts queries all team vesting accounts of the module.
	TeamVestingAccounts(ctx context.Context, in *QueryTeamVestingAccountsRequest, opts ...grpc.CallOption) (*QueryTeamVestingAccountsResponse, error)
	// TeamVestingAccount queries the team vesting accounts of the module.
	TeamVestingAccount(ctx context.Context, in *QueryTeamVestingAccountRequest, opts ...grpc.CallOption) (*QueryTeamVestingAccountResponse, error)
	// TeamCurrentVestingStatus queries the current vesting progress of a team vesting account
	TeamVestingStatus(ctx context.Context, in *QueryTeamVestingStatusRequest, opts ...grpc.CallOption) (*QueryTeamVestingStatusResponse, error)
	// TeamCurrentVestingStatus queries the current vesting progress of a team vesting account
	TeamVestingStatusByTime(ctx context.Context, in *QueryTeamVestingStatusByTimeRequest, opts ...grpc.CallOption) (*QueryTeamVestingStatusByTimeResponse, error)
}

type queryClient struct {
	cc grpc1.ClientConn
}

func NewQueryClient(cc grpc1.ClientConn) QueryClient {
	return &queryClient{cc}
}

func (c *queryClient) TeamInfo(ctx context.Context, in *QueryTeamInfoRequest, opts ...grpc.CallOption) (*QueryTeamInfoResponse, error) {
	out := new(QueryTeamInfoResponse)
	err := c.cc.Invoke(ctx, "/kyve.team.v1beta1.Query/TeamInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) TeamVestingAccounts(ctx context.Context, in *QueryTeamVestingAccountsRequest, opts ...grpc.CallOption) (*QueryTeamVestingAccountsResponse, error) {
	out := new(QueryTeamVestingAccountsResponse)
	err := c.cc.Invoke(ctx, "/kyve.team.v1beta1.Query/TeamVestingAccounts", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) TeamVestingAccount(ctx context.Context, in *QueryTeamVestingAccountRequest, opts ...grpc.CallOption) (*QueryTeamVestingAccountResponse, error) {
	out := new(QueryTeamVestingAccountResponse)
	err := c.cc.Invoke(ctx, "/kyve.team.v1beta1.Query/TeamVestingAccount", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) TeamVestingStatus(ctx context.Context, in *QueryTeamVestingStatusRequest, opts ...grpc.CallOption) (*QueryTeamVestingStatusResponse, error) {
	out := new(QueryTeamVestingStatusResponse)
	err := c.cc.Invoke(ctx, "/kyve.team.v1beta1.Query/TeamVestingStatus", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) TeamVestingStatusByTime(ctx context.Context, in *QueryTeamVestingStatusByTimeRequest, opts ...grpc.CallOption) (*QueryTeamVestingStatusByTimeResponse, error) {
	out := new(QueryTeamVestingStatusByTimeResponse)
	err := c.cc.Invoke(ctx, "/kyve.team.v1beta1.Query/TeamVestingStatusByTime", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// QueryServer is the server API for Query service.
type QueryServer interface {
	// TeamInfo queries all important information from the team module
	TeamInfo(context.Context, *QueryTeamInfoRequest) (*QueryTeamInfoResponse, error)
	// TeamVestingAccounts queries all team vesting accounts of the module.
	TeamVestingAccounts(context.Context, *QueryTeamVestingAccountsRequest) (*QueryTeamVestingAccountsResponse, error)
	// TeamVestingAccount queries the team vesting accounts of the module.
	TeamVestingAccount(context.Context, *QueryTeamVestingAccountRequest) (*QueryTeamVestingAccountResponse, error)
	// TeamCurrentVestingStatus queries the current vesting progress of a team vesting account
	TeamVestingStatus(context.Context, *QueryTeamVestingStatusRequest) (*QueryTeamVestingStatusResponse, error)
	// TeamCurrentVestingStatus queries the current vesting progress of a team vesting account
	TeamVestingStatusByTime(context.Context, *QueryTeamVestingStatusByTimeRequest) (*QueryTeamVestingStatusByTimeResponse, error)
}

// UnimplementedQueryServer can be embedded to have forward compatible implementations.
type UnimplementedQueryServer struct {
}

func (*UnimplementedQueryServer) TeamInfo(ctx context.Context, req *QueryTeamInfoRequest) (*QueryTeamInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TeamInfo not implemented")
}
func (*UnimplementedQueryServer) TeamVestingAccounts(ctx context.Context, req *QueryTeamVestingAccountsRequest) (*QueryTeamVestingAccountsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TeamVestingAccounts not implemented")
}
func (*UnimplementedQueryServer) TeamVestingAccount(ctx context.Context, req *QueryTeamVestingAccountRequest) (*QueryTeamVestingAccountResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TeamVestingAccount not implemented")
}
func (*UnimplementedQueryServer) TeamVestingStatus(ctx context.Context, req *QueryTeamVestingStatusRequest) (*QueryTeamVestingStatusResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TeamVestingStatus not implemented")
}
func (*UnimplementedQueryServer) TeamVestingStatusByTime(ctx context.Context, req *QueryTeamVestingStatusByTimeRequest) (*QueryTeamVestingStatusByTimeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TeamVestingStatusByTime not implemented")
}

func RegisterQueryServer(s grpc1.Server, srv QueryServer) {
	s.RegisterService(&_Query_serviceDesc, srv)
}

func _Query_TeamInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryTeamInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).TeamInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kyve.team.v1beta1.Query/TeamInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).TeamInfo(ctx, req.(*QueryTeamInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_TeamVestingAccounts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryTeamVestingAccountsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).TeamVestingAccounts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kyve.team.v1beta1.Query/TeamVestingAccounts",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).TeamVestingAccounts(ctx, req.(*QueryTeamVestingAccountsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_TeamVestingAccount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryTeamVestingAccountRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).TeamVestingAccount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kyve.team.v1beta1.Query/TeamVestingAccount",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).TeamVestingAccount(ctx, req.(*QueryTeamVestingAccountRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_TeamVestingStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryTeamVestingStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).TeamVestingStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kyve.team.v1beta1.Query/TeamVestingStatus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).TeamVestingStatus(ctx, req.(*QueryTeamVestingStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_TeamVestingStatusByTime_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryTeamVestingStatusByTimeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).TeamVestingStatusByTime(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kyve.team.v1beta1.Query/TeamVestingStatusByTime",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).TeamVestingStatusByTime(ctx, req.(*QueryTeamVestingStatusByTimeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Query_serviceDesc = grpc.ServiceDesc{
	ServiceName: "kyve.team.v1beta1.Query",
	HandlerType: (*QueryServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "TeamInfo",
			Handler:    _Query_TeamInfo_Handler,
		},
		{
			MethodName: "TeamVestingAccounts",
			Handler:    _Query_TeamVestingAccounts_Handler,
		},
		{
			MethodName: "TeamVestingAccount",
			Handler:    _Query_TeamVestingAccount_Handler,
		},
		{
			MethodName: "TeamVestingStatus",
			Handler:    _Query_TeamVestingStatus_Handler,
		},
		{
			MethodName: "TeamVestingStatusByTime",
			Handler:    _Query_TeamVestingStatusByTime_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "kyve/team/v1beta1/query.proto",
}

func (m *QueryTeamInfoRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryTeamInfoRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryTeamInfoRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *QueryTeamInfoResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryTeamInfoResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryTeamInfoResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TeamModuleBalance != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.TeamModuleBalance))
		i--
		dAtA[i] = 0x68
	}
	if m.RequiredModuleBalance != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.RequiredModuleBalance))
		i--
		dAtA[i] = 0x60
	}
	if m.AvailableAccountRewards != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.AvailableAccountRewards))
		i--
		dAtA[i] = 0x58
	}
	if m.ClaimedAccountRewards != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.ClaimedAccountRewards))
		i--
		dAtA[i] = 0x50
	}
	if m.TotalAccountRewards != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.TotalAccountRewards))
		i--
		dAtA[i] = 0x48
	}
	if m.AvailableAuthorityRewards != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.AvailableAuthorityRewards))
		i--
		dAtA[i] = 0x40
	}
	if m.ClaimedAuthorityRewards != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.ClaimedAuthorityRewards))
		i--
		dAtA[i] = 0x38
	}
	if m.TotalAuthorityRewards != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.TotalAuthorityRewards))
		i--
		dAtA[i] = 0x30
	}
	if m.AvailableTeamAllocation != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.AvailableTeamAllocation))
		i--
		dAtA[i] = 0x28
	}
	if m.IssuedTeamAllocation != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.IssuedTeamAllocation))
		i--
		dAtA[i] = 0x20
	}
	if m.TotalTeamAllocation != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.TotalTeamAllocation))
		i--
		dAtA[i] = 0x18
	}
	if len(m.BcpAuthority) > 0 {
		i -= len(m.BcpAuthority)
		copy(dAtA[i:], m.BcpAuthority)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.BcpAuthority)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.FoundationAuthority) > 0 {
		i -= len(m.FoundationAuthority)
		copy(dAtA[i:], m.FoundationAuthority)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.FoundationAuthority)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryTeamVestingAccountsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryTeamVestingAccountsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryTeamVestingAccountsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *QueryTeamVestingAccountsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryTeamVestingAccountsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryTeamVestingAccountsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Accounts) > 0 {
		for iNdEx := len(m.Accounts) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Accounts[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQuery(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *QueryTeamVestingAccountRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryTeamVestingAccountRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryTeamVestingAccountRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *QueryTeamVestingAccountResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryTeamVestingAccountResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryTeamVestingAccountResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Account.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintQuery(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *QueryTeamVestingStatusRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryTeamVestingStatusRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryTeamVestingStatusRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *QueryTeamVestingStatusResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryTeamVestingStatusResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryTeamVestingStatusResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Status != nil {
		{
			size, err := m.Status.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Plan != nil {
		{
			size, err := m.Plan.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.RequestDate) > 0 {
		i -= len(m.RequestDate)
		copy(dAtA[i:], m.RequestDate)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.RequestDate)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryTeamVestingStatusByTimeRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryTeamVestingStatusByTimeRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryTeamVestingStatusByTimeRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Time != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.Time))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *QueryTeamVestingStatusByTimeResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryTeamVestingStatusByTimeResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryTeamVestingStatusByTimeResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Status != nil {
		{
			size, err := m.Status.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Plan != nil {
		{
			size, err := m.Plan.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.RequestDate) > 0 {
		i -= len(m.RequestDate)
		copy(dAtA[i:], m.RequestDate)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.RequestDate)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryVestingStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryVestingStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryVestingStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.AvailableRewards != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.AvailableRewards))
		i--
		dAtA[i] = 0x48
	}
	if m.ClaimedRewards != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.ClaimedRewards))
		i--
		dAtA[i] = 0x40
	}
	if m.TotalRewards != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.TotalRewards))
		i--
		dAtA[i] = 0x38
	}
	if m.ClaimedAmount != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.ClaimedAmount))
		i--
		dAtA[i] = 0x30
	}
	if m.RemainingUnvestedAmount != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.RemainingUnvestedAmount))
		i--
		dAtA[i] = 0x28
	}
	if m.LockedVestedAmount != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.LockedVestedAmount))
		i--
		dAtA[i] = 0x20
	}
	if m.CurrentClaimableAmount != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.CurrentClaimableAmount))
		i--
		dAtA[i] = 0x18
	}
	if m.TotalUnlockedAmount != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.TotalUnlockedAmount))
		i--
		dAtA[i] = 0x10
	}
	if m.TotalVestedAmount != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.TotalVestedAmount))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *QueryVestingPlan) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryVestingPlan) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryVestingPlan) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MaximumVestingAmount != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.MaximumVestingAmount))
		i--
		dAtA[i] = 0x40
	}
	if m.ClawbackAmount != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.ClawbackAmount))
		i--
		dAtA[i] = 0x38
	}
	if m.Clawback != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.Clawback))
		i--
		dAtA[i] = 0x30
	}
	if len(m.TokenUnlockFinished) > 0 {
		i -= len(m.TokenUnlockFinished)
		copy(dAtA[i:], m.TokenUnlockFinished)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.TokenUnlockFinished)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.TokenUnlockStart) > 0 {
		i -= len(m.TokenUnlockStart)
		copy(dAtA[i:], m.TokenUnlockStart)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.TokenUnlockStart)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.TokenVestingFinished) > 0 {
		i -= len(m.TokenVestingFinished)
		copy(dAtA[i:], m.TokenVestingFinished)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.TokenVestingFinished)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.TokenVestingStart) > 0 {
		i -= len(m.TokenVestingStart)
		copy(dAtA[i:], m.TokenVestingStart)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.TokenVestingStart)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Commencement) > 0 {
		i -= len(m.Commencement)
		copy(dAtA[i:], m.Commencement)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.Commencement)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintQuery(dAtA []byte, offset int, v uint64) int {
	offset -= sovQuery(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *QueryTeamInfoRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *QueryTeamInfoResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.FoundationAuthority)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	l = len(m.BcpAuthority)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	if m.TotalTeamAllocation != 0 {
		n += 1 + sovQuery(uint64(m.TotalTeamAllocation))
	}
	if m.IssuedTeamAllocation != 0 {
		n += 1 + sovQuery(uint64(m.IssuedTeamAllocation))
	}
	if m.AvailableTeamAllocation != 0 {
		n += 1 + sovQuery(uint64(m.AvailableTeamAllocation))
	}
	if m.TotalAuthorityRewards != 0 {
		n += 1 + sovQuery(uint64(m.TotalAuthorityRewards))
	}
	if m.ClaimedAuthorityRewards != 0 {
		n += 1 + sovQuery(uint64(m.ClaimedAuthorityRewards))
	}
	if m.AvailableAuthorityRewards != 0 {
		n += 1 + sovQuery(uint64(m.AvailableAuthorityRewards))
	}
	if m.TotalAccountRewards != 0 {
		n += 1 + sovQuery(uint64(m.TotalAccountRewards))
	}
	if m.ClaimedAccountRewards != 0 {
		n += 1 + sovQuery(uint64(m.ClaimedAccountRewards))
	}
	if m.AvailableAccountRewards != 0 {
		n += 1 + sovQuery(uint64(m.AvailableAccountRewards))
	}
	if m.RequiredModuleBalance != 0 {
		n += 1 + sovQuery(uint64(m.RequiredModuleBalance))
	}
	if m.TeamModuleBalance != 0 {
		n += 1 + sovQuery(uint64(m.TeamModuleBalance))
	}
	return n
}

func (m *QueryTeamVestingAccountsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *QueryTeamVestingAccountsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Accounts) > 0 {
		for _, e := range m.Accounts {
			l = e.Size()
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	return n
}

func (m *QueryTeamVestingAccountRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovQuery(uint64(m.Id))
	}
	return n
}

func (m *QueryTeamVestingAccountResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Account.Size()
	n += 1 + l + sovQuery(uint64(l))
	return n
}

func (m *QueryTeamVestingStatusRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovQuery(uint64(m.Id))
	}
	return n
}

func (m *QueryTeamVestingStatusResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.RequestDate)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	if m.Plan != nil {
		l = m.Plan.Size()
		n += 1 + l + sovQuery(uint64(l))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *QueryTeamVestingStatusByTimeRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovQuery(uint64(m.Id))
	}
	if m.Time != 0 {
		n += 1 + sovQuery(uint64(m.Time))
	}
	return n
}

func (m *QueryTeamVestingStatusByTimeResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.RequestDate)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	if m.Plan != nil {
		l = m.Plan.Size()
		n += 1 + l + sovQuery(uint64(l))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *QueryVestingStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TotalVestedAmount != 0 {
		n += 1 + sovQuery(uint64(m.TotalVestedAmount))
	}
	if m.TotalUnlockedAmount != 0 {
		n += 1 + sovQuery(uint64(m.TotalUnlockedAmount))
	}
	if m.CurrentClaimableAmount != 0 {
		n += 1 + sovQuery(uint64(m.CurrentClaimableAmount))
	}
	if m.LockedVestedAmount != 0 {
		n += 1 + sovQuery(uint64(m.LockedVestedAmount))
	}
	if m.RemainingUnvestedAmount != 0 {
		n += 1 + sovQuery(uint64(m.RemainingUnvestedAmount))
	}
	if m.ClaimedAmount != 0 {
		n += 1 + sovQuery(uint64(m.ClaimedAmount))
	}
	if m.TotalRewards != 0 {
		n += 1 + sovQuery(uint64(m.TotalRewards))
	}
	if m.ClaimedRewards != 0 {
		n += 1 + sovQuery(uint64(m.ClaimedRewards))
	}
	if m.AvailableRewards != 0 {
		n += 1 + sovQuery(uint64(m.AvailableRewards))
	}
	return n
}

func (m *QueryVestingPlan) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Commencement)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	l = len(m.TokenVestingStart)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	l = len(m.TokenVestingFinished)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	l = len(m.TokenUnlockStart)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	l = len(m.TokenUnlockFinished)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	if m.Clawback != 0 {
		n += 1 + sovQuery(uint64(m.Clawback))
	}
	if m.ClawbackAmount != 0 {
		n += 1 + sovQuery(uint64(m.ClawbackAmount))
	}
	if m.MaximumVestingAmount != 0 {
		n += 1 + sovQuery(uint64(m.MaximumVestingAmount))
	}
	return n
}

func sovQuery(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozQuery(x uint64) (n int) {
	return sovQuery(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *QueryTeamInfoRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryTeamInfoRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryTeamInfoRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryTeamInfoResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryTeamInfoResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryTeamInfoResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FoundationAuthority", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FoundationAuthority = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BcpAuthority", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BcpAuthority = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalTeamAllocation", wireType)
			}
			m.TotalTeamAllocation = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalTeamAllocation |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IssuedTeamAllocation", wireType)
			}
			m.IssuedTeamAllocation = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IssuedTeamAllocation |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AvailableTeamAllocation", wireType)
			}
			m.AvailableTeamAllocation = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AvailableTeamAllocation |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalAuthorityRewards", wireType)
			}
			m.TotalAuthorityRewards = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalAuthorityRewards |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClaimedAuthorityRewards", wireType)
			}
			m.ClaimedAuthorityRewards = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClaimedAuthorityRewards |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AvailableAuthorityRewards", wireType)
			}
			m.AvailableAuthorityRewards = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AvailableAuthorityRewards |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalAccountRewards", wireType)
			}
			m.TotalAccountRewards = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalAccountRewards |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClaimedAccountRewards", wireType)
			}
			m.ClaimedAccountRewards = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClaimedAccountRewards |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AvailableAccountRewards", wireType)
			}
			m.AvailableAccountRewards = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AvailableAccountRewards |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequiredModuleBalance", wireType)
			}
			m.RequiredModuleBalance = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RequiredModuleBalance |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TeamModuleBalance", wireType)
			}
			m.TeamModuleBalance = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TeamModuleBalance |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryTeamVestingAccountsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryTeamVestingAccountsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryTeamVestingAccountsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryTeamVestingAccountsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryTeamVestingAccountsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryTeamVestingAccountsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Accounts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Accounts = append(m.Accounts, TeamVestingAccount{})
			if err := m.Accounts[len(m.Accounts)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryTeamVestingAccountRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryTeamVestingAccountRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryTeamVestingAccountRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryTeamVestingAccountResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryTeamVestingAccountResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryTeamVestingAccountResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Account", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Account.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryTeamVestingStatusRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryTeamVestingStatusRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryTeamVestingStatusRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryTeamVestingStatusResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryTeamVestingStatusResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryTeamVestingStatusResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestDate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RequestDate = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Plan", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Plan == nil {
				m.Plan = &QueryVestingPlan{}
			}
			if err := m.Plan.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &QueryVestingStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryTeamVestingStatusByTimeRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryTeamVestingStatusByTimeRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryTeamVestingStatusByTimeRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			m.Time = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Time |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryTeamVestingStatusByTimeResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryTeamVestingStatusByTimeResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryTeamVestingStatusByTimeResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestDate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RequestDate = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Plan", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Plan == nil {
				m.Plan = &QueryVestingPlan{}
			}
			if err := m.Plan.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &QueryVestingStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryVestingStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryVestingStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryVestingStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalVestedAmount", wireType)
			}
			m.TotalVestedAmount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalVestedAmount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalUnlockedAmount", wireType)
			}
			m.TotalUnlockedAmount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalUnlockedAmount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentClaimableAmount", wireType)
			}
			m.CurrentClaimableAmount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CurrentClaimableAmount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LockedVestedAmount", wireType)
			}
			m.LockedVestedAmount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LockedVestedAmount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemainingUnvestedAmount", wireType)
			}
			m.RemainingUnvestedAmount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RemainingUnvestedAmount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClaimedAmount", wireType)
			}
			m.ClaimedAmount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClaimedAmount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalRewards", wireType)
			}
			m.TotalRewards = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalRewards |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClaimedRewards", wireType)
			}
			m.ClaimedRewards = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClaimedRewards |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AvailableRewards", wireType)
			}
			m.AvailableRewards = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AvailableRewards |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryVestingPlan) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryVestingPlan: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryVestingPlan: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Commencement", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Commencement = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TokenVestingStart", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TokenVestingStart = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TokenVestingFinished", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TokenVestingFinished = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TokenUnlockStart", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TokenUnlockStart = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TokenUnlockFinished", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TokenUnlockFinished = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Clawback", wireType)
			}
			m.Clawback = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Clawback |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClawbackAmount", wireType)
			}
			m.ClawbackAmount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClawbackAmount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaximumVestingAmount", wireType)
			}
			m.MaximumVestingAmount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaximumVestingAmount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipQuery(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthQuery
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupQuery
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthQuery
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthQuery        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowQuery          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupQuery = fmt.Errorf("proto: unexpected end of group")
)
