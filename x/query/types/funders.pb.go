// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: kyve/query/v1beta1/funders.proto

package types

import (
	context "context"
	fmt "fmt"
	github_com_cosmos_cosmos_sdk_types "github.com/cosmos/cosmos-sdk/types"
	types "github.com/cosmos/cosmos-sdk/types"
	query "github.com/cosmos/cosmos-sdk/types/query"
	_ "github.com/cosmos/cosmos-sdk/types/tx/amino"
	_ "github.com/cosmos/gogoproto/gogoproto"
	grpc1 "github.com/cosmos/gogoproto/grpc"
	proto "github.com/cosmos/gogoproto/proto"
	_ "google.golang.org/genproto/googleapis/api/annotations"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// FundingStatus ...
type FundingStatus int32

const (
	// FundingStatusUnspecified ...
	FUNDING_STATUS_UNSPECIFIED FundingStatus = 0
	// FundingStatusActive status is set when the funding is active.
	FUNDING_STATUS_ACTIVE FundingStatus = 1
	// FundingStatusInactive status is set when the funding has been used up or refunded.
	FUNDING_STATUS_INACTIVE FundingStatus = 2
)

var FundingStatus_name = map[int32]string{
	0: "FUNDING_STATUS_UNSPECIFIED",
	1: "FUNDING_STATUS_ACTIVE",
	2: "FUNDING_STATUS_INACTIVE",
}

var FundingStatus_value = map[string]int32{
	"FUNDING_STATUS_UNSPECIFIED": 0,
	"FUNDING_STATUS_ACTIVE":      1,
	"FUNDING_STATUS_INACTIVE":    2,
}

func (x FundingStatus) String() string {
	return proto.EnumName(FundingStatus_name, int32(x))
}

func (FundingStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_a182f068d9f0dba9, []int{0}
}

// Funder ...
type Funder struct {
	// address ...
	Address string `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
	// moniker ...
	Moniker string `protobuf:"bytes,2,opt,name=moniker,proto3" json:"moniker,omitempty"`
	// identity is the 64 bit keybase.io identity string
	Identity string `protobuf:"bytes,3,opt,name=identity,proto3" json:"identity,omitempty"`
	// website ...
	Website string `protobuf:"bytes,4,opt,name=website,proto3" json:"website,omitempty"`
	// contact ...
	Contact string `protobuf:"bytes,5,opt,name=contact,proto3" json:"contact,omitempty"`
	// description ...
	Description string `protobuf:"bytes,6,opt,name=description,proto3" json:"description,omitempty"`
	// statistics about all the fundings of the funder.
	Stats *FundingStats `protobuf:"bytes,7,opt,name=stats,proto3" json:"stats,omitempty"`
}

func (m *Funder) Reset()         { *m = Funder{} }
func (m *Funder) String() string { return proto.CompactTextString(m) }
func (*Funder) ProtoMessage()    {}
func (*Funder) Descriptor() ([]byte, []int) {
	return fileDescriptor_a182f068d9f0dba9, []int{0}
}
func (m *Funder) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Funder) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Funder.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Funder) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Funder.Merge(m, src)
}
func (m *Funder) XXX_Size() int {
	return m.Size()
}
func (m *Funder) XXX_DiscardUnknown() {
	xxx_messageInfo_Funder.DiscardUnknown(m)
}

var xxx_messageInfo_Funder proto.InternalMessageInfo

func (m *Funder) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *Funder) GetMoniker() string {
	if m != nil {
		return m.Moniker
	}
	return ""
}

func (m *Funder) GetIdentity() string {
	if m != nil {
		return m.Identity
	}
	return ""
}

func (m *Funder) GetWebsite() string {
	if m != nil {
		return m.Website
	}
	return ""
}

func (m *Funder) GetContact() string {
	if m != nil {
		return m.Contact
	}
	return ""
}

func (m *Funder) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *Funder) GetStats() *FundingStats {
	if m != nil {
		return m.Stats
	}
	return nil
}

// FundingStats ...
type FundingStats struct {
	// total_used_funds are the total funds that have been distributed by the funder.
	TotalUsedFunds github_com_cosmos_cosmos_sdk_types.Coins `protobuf:"bytes,1,rep,name=total_used_funds,json=totalUsedFunds,proto3,castrepeated=github.com/cosmos/cosmos-sdk/types.Coins" json:"total_used_funds"`
	// total_allocated_funds are the total funds that have been allocated by the funder.
	// They can either get distributed or refunded.
	TotalAllocatedFunds github_com_cosmos_cosmos_sdk_types.Coins `protobuf:"bytes,2,rep,name=total_allocated_funds,json=totalAllocatedFunds,proto3,castrepeated=github.com/cosmos/cosmos-sdk/types.Coins" json:"total_allocated_funds"`
	// total_amount_per_bundle is the total amount per bundle of all fundings of the funder.
	TotalAmountPerBundle github_com_cosmos_cosmos_sdk_types.Coins `protobuf:"bytes,3,rep,name=total_amount_per_bundle,json=totalAmountPerBundle,proto3,castrepeated=github.com/cosmos/cosmos-sdk/types.Coins" json:"total_amount_per_bundle"`
	// pools_funded are the ids of the pools that have been funded by the funder.
	PoolsFunded []uint64 `protobuf:"varint,4,rep,packed,name=pools_funded,json=poolsFunded,proto3" json:"pools_funded,omitempty"`
	// score is the result of all coins of the funder currently allocated times the coin weight
	// specified in the params
	Score uint64 `protobuf:"varint,5,opt,name=score,proto3" json:"score,omitempty"`
}

func (m *FundingStats) Reset()         { *m = FundingStats{} }
func (m *FundingStats) String() string { return proto.CompactTextString(m) }
func (*FundingStats) ProtoMessage()    {}
func (*FundingStats) Descriptor() ([]byte, []int) {
	return fileDescriptor_a182f068d9f0dba9, []int{1}
}
func (m *FundingStats) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FundingStats) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FundingStats.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FundingStats) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FundingStats.Merge(m, src)
}
func (m *FundingStats) XXX_Size() int {
	return m.Size()
}
func (m *FundingStats) XXX_DiscardUnknown() {
	xxx_messageInfo_FundingStats.DiscardUnknown(m)
}

var xxx_messageInfo_FundingStats proto.InternalMessageInfo

func (m *FundingStats) GetTotalUsedFunds() github_com_cosmos_cosmos_sdk_types.Coins {
	if m != nil {
		return m.TotalUsedFunds
	}
	return nil
}

func (m *FundingStats) GetTotalAllocatedFunds() github_com_cosmos_cosmos_sdk_types.Coins {
	if m != nil {
		return m.TotalAllocatedFunds
	}
	return nil
}

func (m *FundingStats) GetTotalAmountPerBundle() github_com_cosmos_cosmos_sdk_types.Coins {
	if m != nil {
		return m.TotalAmountPerBundle
	}
	return nil
}

func (m *FundingStats) GetPoolsFunded() []uint64 {
	if m != nil {
		return m.PoolsFunded
	}
	return nil
}

func (m *FundingStats) GetScore() uint64 {
	if m != nil {
		return m.Score
	}
	return 0
}

// Funding ...
type Funding struct {
	// funder_id is the id of the funder
	FunderAddress string `protobuf:"bytes,1,opt,name=funder_address,json=funderAddress,proto3" json:"funder_address,omitempty"`
	// pool_id is the id of the pool this funding is for
	PoolId uint64 `protobuf:"varint,2,opt,name=pool_id,json=poolId,proto3" json:"pool_id,omitempty"`
	// amounts is a list of coins the funder wants to fund the pool with
	Amounts github_com_cosmos_cosmos_sdk_types.Coins `protobuf:"bytes,3,rep,name=amounts,proto3,castrepeated=github.com/cosmos/cosmos-sdk/types.Coins" json:"amounts"`
	// amounts_per_bundle defines the amount of each coin that are distributed
	// per finalized bundle
	AmountsPerBundle github_com_cosmos_cosmos_sdk_types.Coins `protobuf:"bytes,4,rep,name=amounts_per_bundle,json=amountsPerBundle,proto3,castrepeated=github.com/cosmos/cosmos-sdk/types.Coins" json:"amounts_per_bundle"`
	// total_funded is the total amount of coins that the funder has funded
	TotalFunded github_com_cosmos_cosmos_sdk_types.Coins `protobuf:"bytes,5,rep,name=total_funded,json=totalFunded,proto3,castrepeated=github.com/cosmos/cosmos-sdk/types.Coins" json:"total_funded"`
	// score is the result of all coins allocated to this pool times the coin weight specified
	// by the params
	Score uint64 `protobuf:"varint,6,opt,name=score,proto3" json:"score,omitempty"`
}

func (m *Funding) Reset()         { *m = Funding{} }
func (m *Funding) String() string { return proto.CompactTextString(m) }
func (*Funding) ProtoMessage()    {}
func (*Funding) Descriptor() ([]byte, []int) {
	return fileDescriptor_a182f068d9f0dba9, []int{2}
}
func (m *Funding) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Funding) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Funding.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Funding) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Funding.Merge(m, src)
}
func (m *Funding) XXX_Size() int {
	return m.Size()
}
func (m *Funding) XXX_DiscardUnknown() {
	xxx_messageInfo_Funding.DiscardUnknown(m)
}

var xxx_messageInfo_Funding proto.InternalMessageInfo

func (m *Funding) GetFunderAddress() string {
	if m != nil {
		return m.FunderAddress
	}
	return ""
}

func (m *Funding) GetPoolId() uint64 {
	if m != nil {
		return m.PoolId
	}
	return 0
}

func (m *Funding) GetAmounts() github_com_cosmos_cosmos_sdk_types.Coins {
	if m != nil {
		return m.Amounts
	}
	return nil
}

func (m *Funding) GetAmountsPerBundle() github_com_cosmos_cosmos_sdk_types.Coins {
	if m != nil {
		return m.AmountsPerBundle
	}
	return nil
}

func (m *Funding) GetTotalFunded() github_com_cosmos_cosmos_sdk_types.Coins {
	if m != nil {
		return m.TotalFunded
	}
	return nil
}

func (m *Funding) GetScore() uint64 {
	if m != nil {
		return m.Score
	}
	return 0
}

// QueryFundersRequest is the request type for the Query/Funders RPC method.
type QueryFundersRequest struct {
	// pagination defines an optional pagination for the request.
	Pagination *query.PageRequest `protobuf:"bytes,1,opt,name=pagination,proto3" json:"pagination,omitempty"`
	// search ...
	Search string `protobuf:"bytes,2,opt,name=search,proto3" json:"search,omitempty"`
}

func (m *QueryFundersRequest) Reset()         { *m = QueryFundersRequest{} }
func (m *QueryFundersRequest) String() string { return proto.CompactTextString(m) }
func (*QueryFundersRequest) ProtoMessage()    {}
func (*QueryFundersRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_a182f068d9f0dba9, []int{3}
}
func (m *QueryFundersRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryFundersRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryFundersRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryFundersRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryFundersRequest.Merge(m, src)
}
func (m *QueryFundersRequest) XXX_Size() int {
	return m.Size()
}
func (m *QueryFundersRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryFundersRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QueryFundersRequest proto.InternalMessageInfo

func (m *QueryFundersRequest) GetPagination() *query.PageRequest {
	if m != nil {
		return m.Pagination
	}
	return nil
}

func (m *QueryFundersRequest) GetSearch() string {
	if m != nil {
		return m.Search
	}
	return ""
}

// QueryFundersResponse is the response type for the Query/Funders RPC method.
type QueryFundersResponse struct {
	// pagination defines the pagination in the response.
	Pagination *query.PageResponse `protobuf:"bytes,1,opt,name=pagination,proto3" json:"pagination,omitempty"`
	// funders ...
	Funders []Funder `protobuf:"bytes,2,rep,name=funders,proto3" json:"funders"`
}

func (m *QueryFundersResponse) Reset()         { *m = QueryFundersResponse{} }
func (m *QueryFundersResponse) String() string { return proto.CompactTextString(m) }
func (*QueryFundersResponse) ProtoMessage()    {}
func (*QueryFundersResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_a182f068d9f0dba9, []int{4}
}
func (m *QueryFundersResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryFundersResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryFundersResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryFundersResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryFundersResponse.Merge(m, src)
}
func (m *QueryFundersResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryFundersResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryFundersResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryFundersResponse proto.InternalMessageInfo

func (m *QueryFundersResponse) GetPagination() *query.PageResponse {
	if m != nil {
		return m.Pagination
	}
	return nil
}

func (m *QueryFundersResponse) GetFunders() []Funder {
	if m != nil {
		return m.Funders
	}
	return nil
}

// QueryFunderRequest is the request type for the Query/Funder RPC method.
type QueryFunderRequest struct {
	// address ...
	Address string `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
	// status ...
	Status FundingStatus `protobuf:"varint,3,opt,name=status,proto3,enum=kyve.query.v1beta1.FundingStatus" json:"status,omitempty"`
}

func (m *QueryFunderRequest) Reset()         { *m = QueryFunderRequest{} }
func (m *QueryFunderRequest) String() string { return proto.CompactTextString(m) }
func (*QueryFunderRequest) ProtoMessage()    {}
func (*QueryFunderRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_a182f068d9f0dba9, []int{5}
}
func (m *QueryFunderRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryFunderRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryFunderRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryFunderRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryFunderRequest.Merge(m, src)
}
func (m *QueryFunderRequest) XXX_Size() int {
	return m.Size()
}
func (m *QueryFunderRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryFunderRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QueryFunderRequest proto.InternalMessageInfo

func (m *QueryFunderRequest) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *QueryFunderRequest) GetStatus() FundingStatus {
	if m != nil {
		return m.Status
	}
	return FUNDING_STATUS_UNSPECIFIED
}

// QueryFunderResponse is the response type for the Query/Funder RPC method.
type QueryFunderResponse struct {
	// funder ...
	Funder *Funder `protobuf:"bytes,1,opt,name=funder,proto3" json:"funder,omitempty"`
	// fundings ...
	Fundings []Funding `protobuf:"bytes,2,rep,name=fundings,proto3" json:"fundings"`
}

func (m *QueryFunderResponse) Reset()         { *m = QueryFunderResponse{} }
func (m *QueryFunderResponse) String() string { return proto.CompactTextString(m) }
func (*QueryFunderResponse) ProtoMessage()    {}
func (*QueryFunderResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_a182f068d9f0dba9, []int{6}
}
func (m *QueryFunderResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryFunderResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryFunderResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryFunderResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryFunderResponse.Merge(m, src)
}
func (m *QueryFunderResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryFunderResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryFunderResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryFunderResponse proto.InternalMessageInfo

func (m *QueryFunderResponse) GetFunder() *Funder {
	if m != nil {
		return m.Funder
	}
	return nil
}

func (m *QueryFunderResponse) GetFundings() []Funding {
	if m != nil {
		return m.Fundings
	}
	return nil
}

// QueryFundingsByFunderRequest is the request type for the Query/FundingsByFunder RPC method.
type QueryFundingsByFunderRequest struct {
	// pagination defines an optional pagination for the request.
	Pagination *query.PageRequest `protobuf:"bytes,1,opt,name=pagination,proto3" json:"pagination,omitempty"`
	// address ...
	Address string `protobuf:"bytes,2,opt,name=address,proto3" json:"address,omitempty"`
	// status ...
	Status FundingStatus `protobuf:"varint,3,opt,name=status,proto3,enum=kyve.query.v1beta1.FundingStatus" json:"status,omitempty"`
}

func (m *QueryFundingsByFunderRequest) Reset()         { *m = QueryFundingsByFunderRequest{} }
func (m *QueryFundingsByFunderRequest) String() string { return proto.CompactTextString(m) }
func (*QueryFundingsByFunderRequest) ProtoMessage()    {}
func (*QueryFundingsByFunderRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_a182f068d9f0dba9, []int{7}
}
func (m *QueryFundingsByFunderRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryFundingsByFunderRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryFundingsByFunderRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryFundingsByFunderRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryFundingsByFunderRequest.Merge(m, src)
}
func (m *QueryFundingsByFunderRequest) XXX_Size() int {
	return m.Size()
}
func (m *QueryFundingsByFunderRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryFundingsByFunderRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QueryFundingsByFunderRequest proto.InternalMessageInfo

func (m *QueryFundingsByFunderRequest) GetPagination() *query.PageRequest {
	if m != nil {
		return m.Pagination
	}
	return nil
}

func (m *QueryFundingsByFunderRequest) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *QueryFundingsByFunderRequest) GetStatus() FundingStatus {
	if m != nil {
		return m.Status
	}
	return FUNDING_STATUS_UNSPECIFIED
}

// QueryFundingsByFunderResponse is the response type for the Query/FundingsByFunder RPC method.
type QueryFundingsByFunderResponse struct {
	// pagination defines the pagination in the response.
	Pagination *query.PageResponse `protobuf:"bytes,1,opt,name=pagination,proto3" json:"pagination,omitempty"`
	// fundings ...
	Fundings []Funding `protobuf:"bytes,2,rep,name=fundings,proto3" json:"fundings"`
}

func (m *QueryFundingsByFunderResponse) Reset()         { *m = QueryFundingsByFunderResponse{} }
func (m *QueryFundingsByFunderResponse) String() string { return proto.CompactTextString(m) }
func (*QueryFundingsByFunderResponse) ProtoMessage()    {}
func (*QueryFundingsByFunderResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_a182f068d9f0dba9, []int{8}
}
func (m *QueryFundingsByFunderResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryFundingsByFunderResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryFundingsByFunderResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryFundingsByFunderResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryFundingsByFunderResponse.Merge(m, src)
}
func (m *QueryFundingsByFunderResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryFundingsByFunderResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryFundingsByFunderResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryFundingsByFunderResponse proto.InternalMessageInfo

func (m *QueryFundingsByFunderResponse) GetPagination() *query.PageResponse {
	if m != nil {
		return m.Pagination
	}
	return nil
}

func (m *QueryFundingsByFunderResponse) GetFundings() []Funding {
	if m != nil {
		return m.Fundings
	}
	return nil
}

// QueryFundingsByPoolRequest is the request type for the Query/FundingsByPool RPC method.
type QueryFundingsByPoolRequest struct {
	// pagination defines an optional pagination for the request.
	Pagination *query.PageRequest `protobuf:"bytes,1,opt,name=pagination,proto3" json:"pagination,omitempty"`
	// pool_id ...
	PoolId uint64 `protobuf:"varint,2,opt,name=pool_id,json=poolId,proto3" json:"pool_id,omitempty"`
	// status ...
	Status FundingStatus `protobuf:"varint,3,opt,name=status,proto3,enum=kyve.query.v1beta1.FundingStatus" json:"status,omitempty"`
}

func (m *QueryFundingsByPoolRequest) Reset()         { *m = QueryFundingsByPoolRequest{} }
func (m *QueryFundingsByPoolRequest) String() string { return proto.CompactTextString(m) }
func (*QueryFundingsByPoolRequest) ProtoMessage()    {}
func (*QueryFundingsByPoolRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_a182f068d9f0dba9, []int{9}
}
func (m *QueryFundingsByPoolRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryFundingsByPoolRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryFundingsByPoolRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryFundingsByPoolRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryFundingsByPoolRequest.Merge(m, src)
}
func (m *QueryFundingsByPoolRequest) XXX_Size() int {
	return m.Size()
}
func (m *QueryFundingsByPoolRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryFundingsByPoolRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QueryFundingsByPoolRequest proto.InternalMessageInfo

func (m *QueryFundingsByPoolRequest) GetPagination() *query.PageRequest {
	if m != nil {
		return m.Pagination
	}
	return nil
}

func (m *QueryFundingsByPoolRequest) GetPoolId() uint64 {
	if m != nil {
		return m.PoolId
	}
	return 0
}

func (m *QueryFundingsByPoolRequest) GetStatus() FundingStatus {
	if m != nil {
		return m.Status
	}
	return FUNDING_STATUS_UNSPECIFIED
}

// QueryFundingsByPoolResponse is the response type for the Query/FundingsByPool RPC method.
type QueryFundingsByPoolResponse struct {
	// pagination defines the pagination in the response.
	Pagination *query.PageResponse `protobuf:"bytes,1,opt,name=pagination,proto3" json:"pagination,omitempty"`
	// fundings ...
	Fundings []Funding `protobuf:"bytes,2,rep,name=fundings,proto3" json:"fundings"`
}

func (m *QueryFundingsByPoolResponse) Reset()         { *m = QueryFundingsByPoolResponse{} }
func (m *QueryFundingsByPoolResponse) String() string { return proto.CompactTextString(m) }
func (*QueryFundingsByPoolResponse) ProtoMessage()    {}
func (*QueryFundingsByPoolResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_a182f068d9f0dba9, []int{10}
}
func (m *QueryFundingsByPoolResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryFundingsByPoolResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryFundingsByPoolResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryFundingsByPoolResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryFundingsByPoolResponse.Merge(m, src)
}
func (m *QueryFundingsByPoolResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryFundingsByPoolResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryFundingsByPoolResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryFundingsByPoolResponse proto.InternalMessageInfo

func (m *QueryFundingsByPoolResponse) GetPagination() *query.PageResponse {
	if m != nil {
		return m.Pagination
	}
	return nil
}

func (m *QueryFundingsByPoolResponse) GetFundings() []Funding {
	if m != nil {
		return m.Fundings
	}
	return nil
}

func init() {
	proto.RegisterEnum("kyve.query.v1beta1.FundingStatus", FundingStatus_name, FundingStatus_value)
	proto.RegisterType((*Funder)(nil), "kyve.query.v1beta1.Funder")
	proto.RegisterType((*FundingStats)(nil), "kyve.query.v1beta1.FundingStats")
	proto.RegisterType((*Funding)(nil), "kyve.query.v1beta1.Funding")
	proto.RegisterType((*QueryFundersRequest)(nil), "kyve.query.v1beta1.QueryFundersRequest")
	proto.RegisterType((*QueryFundersResponse)(nil), "kyve.query.v1beta1.QueryFundersResponse")
	proto.RegisterType((*QueryFunderRequest)(nil), "kyve.query.v1beta1.QueryFunderRequest")
	proto.RegisterType((*QueryFunderResponse)(nil), "kyve.query.v1beta1.QueryFunderResponse")
	proto.RegisterType((*QueryFundingsByFunderRequest)(nil), "kyve.query.v1beta1.QueryFundingsByFunderRequest")
	proto.RegisterType((*QueryFundingsByFunderResponse)(nil), "kyve.query.v1beta1.QueryFundingsByFunderResponse")
	proto.RegisterType((*QueryFundingsByPoolRequest)(nil), "kyve.query.v1beta1.QueryFundingsByPoolRequest")
	proto.RegisterType((*QueryFundingsByPoolResponse)(nil), "kyve.query.v1beta1.QueryFundingsByPoolResponse")
}

func init() { proto.RegisterFile("kyve/query/v1beta1/funders.proto", fileDescriptor_a182f068d9f0dba9) }

var fileDescriptor_a182f068d9f0dba9 = []byte{
	// 1050 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x57, 0xcd, 0x6f, 0x1b, 0x45,
	0x14, 0xf7, 0xc4, 0x8e, 0x5d, 0x9e, 0xd3, 0x28, 0x4c, 0x53, 0xb2, 0xdd, 0xb4, 0xae, 0x6b, 0x20,
	0xb1, 0x22, 0xd8, 0x4d, 0x8c, 0xa8, 0x00, 0x89, 0x43, 0x3e, 0x2b, 0x0b, 0x29, 0x0a, 0x9b, 0xa4,
	0x12, 0x5c, 0x56, 0xeb, 0xdd, 0xa9, 0xb3, 0xc4, 0xde, 0x71, 0x77, 0x76, 0x5b, 0x42, 0x55, 0x24,
	0x10, 0x12, 0x3d, 0x22, 0x71, 0xe4, 0x88, 0x10, 0x1f, 0x27, 0xb8, 0x21, 0x71, 0xe1, 0xd8, 0x63,
	0x25, 0x38, 0x70, 0x02, 0x94, 0x20, 0xf8, 0x27, 0x38, 0xa0, 0xf9, 0x58, 0x77, 0xed, 0xc6, 0x71,
	0x51, 0x63, 0xa9, 0x97, 0x64, 0x66, 0xde, 0x7b, 0xf3, 0xfb, 0xcd, 0x6f, 0xde, 0x7b, 0x3b, 0x86,
	0xf2, 0xfe, 0xc1, 0x2d, 0x62, 0xde, 0x8c, 0x49, 0x78, 0x60, 0xde, 0x5a, 0x6a, 0x90, 0xc8, 0x59,
	0x32, 0x6f, 0xc4, 0x81, 0x47, 0x42, 0x66, 0x74, 0x42, 0x1a, 0x51, 0x8c, 0xb9, 0x87, 0x21, 0x3c,
	0x0c, 0xe5, 0xa1, 0x3f, 0xeb, 0xb4, 0xfd, 0x80, 0x9a, 0xe2, 0xaf, 0x74, 0xd3, 0x17, 0x5c, 0xca,
	0xda, 0x94, 0x99, 0x0d, 0x87, 0xf5, 0xef, 0xd7, 0x71, 0x9a, 0x7e, 0xe0, 0x44, 0x3e, 0x0d, 0x94,
	0x6f, 0x29, 0xed, 0x9b, 0x78, 0xb9, 0xd4, 0x4f, 0xec, 0xd3, 0x4d, 0xda, 0xa4, 0x62, 0x68, 0xf2,
	0x91, 0x5a, 0xbd, 0xd8, 0xa4, 0xb4, 0xd9, 0x22, 0xa6, 0xd3, 0xf1, 0x4d, 0x27, 0x08, 0x68, 0x24,
	0xb6, 0x54, 0x34, 0x2b, 0x7f, 0x23, 0xc8, 0x6f, 0x08, 0xe2, 0x58, 0x83, 0x82, 0xe3, 0x79, 0x21,
	0x61, 0x4c, 0x43, 0x65, 0x54, 0x7d, 0xc6, 0x4a, 0xa6, 0xdc, 0xd2, 0xa6, 0x81, 0xbf, 0x4f, 0x42,
	0x6d, 0x4c, 0x5a, 0xd4, 0x14, 0xeb, 0x70, 0xc6, 0xf7, 0x48, 0x10, 0xf9, 0xd1, 0x81, 0x96, 0x15,
	0xa6, 0xee, 0x9c, 0x47, 0xdd, 0x26, 0x0d, 0xe6, 0x47, 0x44, 0xcb, 0xc9, 0x28, 0x35, 0xe5, 0x16,
	0x97, 0x06, 0x91, 0xe3, 0x46, 0xda, 0xb8, 0xb4, 0xa8, 0x29, 0x2e, 0x43, 0xd1, 0x23, 0xcc, 0x0d,
	0xfd, 0x0e, 0x27, 0xa9, 0xe5, 0x85, 0x35, 0xbd, 0x84, 0xaf, 0xc2, 0x38, 0x8b, 0x9c, 0x88, 0x69,
	0x85, 0x32, 0xaa, 0x16, 0x6b, 0x65, 0xe3, 0x51, 0x9d, 0x0d, 0x7e, 0x20, 0x3f, 0x68, 0x6e, 0x73,
	0x3f, 0x4b, 0xba, 0x57, 0x7e, 0xcd, 0xc2, 0x44, 0x7a, 0x1d, 0x7f, 0x00, 0x53, 0x11, 0x8d, 0x9c,
	0x96, 0x1d, 0x33, 0xe2, 0xd9, 0xfc, 0xf2, 0xf8, 0xb9, 0xb3, 0xd5, 0x62, 0xed, 0x82, 0x21, 0x85,
	0x36, 0xb8, 0xd0, 0xdd, 0x4d, 0x57, 0xa9, 0x1f, 0xac, 0xbc, 0x7a, 0xff, 0xf7, 0xcb, 0x99, 0xef,
	0xfe, 0xb8, 0x5c, 0x6d, 0xfa, 0xd1, 0x5e, 0xdc, 0x30, 0x5c, 0xda, 0x36, 0xd5, 0xad, 0xc8, 0x7f,
	0x2f, 0x33, 0x6f, 0xdf, 0x8c, 0x0e, 0x3a, 0x84, 0x89, 0x00, 0xf6, 0xcd, 0x3f, 0xdf, 0x2f, 0x20,
	0x6b, 0x52, 0x20, 0xed, 0x32, 0xe2, 0x71, 0x0a, 0x0c, 0x7f, 0x82, 0xe0, 0xbc, 0x04, 0x77, 0x5a,
	0x2d, 0xea, 0x3a, 0x51, 0x97, 0xc1, 0xd8, 0x88, 0x18, 0x9c, 0x13, 0x70, 0xcb, 0x09, 0x9a, 0xa4,
	0xf1, 0x29, 0x82, 0x19, 0x45, 0xa3, 0x4d, 0xe3, 0x20, 0xb2, 0x3b, 0x24, 0xb4, 0x1b, 0x71, 0xe0,
	0xb5, 0x88, 0x96, 0x1d, 0x11, 0x91, 0x69, 0x49, 0x44, 0xe0, 0x6d, 0x91, 0x70, 0x45, 0xa0, 0xe1,
	0x2b, 0x30, 0xd1, 0xa1, 0xb4, 0xc5, 0x84, 0x0a, 0xc4, 0xd3, 0x72, 0xe5, 0x6c, 0x35, 0x67, 0x15,
	0xc5, 0x9a, 0x48, 0x4f, 0x0f, 0x4f, 0xc3, 0x38, 0x73, 0x69, 0x48, 0x44, 0xca, 0xe4, 0x2c, 0x39,
	0xa9, 0xfc, 0x9c, 0x85, 0x82, 0xba, 0x56, 0xfc, 0x22, 0x4c, 0xca, 0x1a, 0xb4, 0x7b, 0xf3, 0xf8,
	0xac, 0x5c, 0x5d, 0x56, 0xd9, 0x3c, 0x03, 0x05, 0xbe, 0xaf, 0xed, 0x7b, 0x22, 0x9b, 0x73, 0x56,
	0x9e, 0x4f, 0xeb, 0x1e, 0x7e, 0x0f, 0x0a, 0x52, 0x07, 0x36, 0xb2, 0xd3, 0x27, 0x00, 0xf8, 0x43,
	0xc0, 0x6a, 0x98, 0x16, 0x3d, 0x37, 0x22, 0xd8, 0x29, 0x85, 0xf5, 0x50, 0x70, 0x06, 0x13, 0xf2,
	0xe6, 0x95, 0xe0, 0xe3, 0x23, 0x42, 0x2e, 0x0a, 0x94, 0xfe, 0x2b, 0xcc, 0xa7, 0xaf, 0x30, 0x86,
	0x73, 0x6f, 0xf3, 0xf2, 0x95, 0x6d, 0x88, 0x59, 0xe4, 0x66, 0x4c, 0x58, 0x84, 0x37, 0x00, 0x1e,
	0x76, 0x40, 0x71, 0x93, 0xc5, 0xda, 0x5c, 0x0f, 0xbf, 0xde, 0xa2, 0xdf, 0x72, 0x9a, 0x44, 0xc5,
	0x5a, 0xa9, 0x48, 0xfc, 0x1c, 0xe4, 0x19, 0x71, 0x42, 0x77, 0x4f, 0xf5, 0x2e, 0x35, 0xab, 0x7c,
	0x81, 0x60, 0xba, 0x17, 0x97, 0x75, 0x68, 0xc0, 0x08, 0xbe, 0x76, 0x0c, 0xf0, 0xfc, 0x50, 0x60,
	0x19, 0xdc, 0x83, 0xfc, 0x06, 0x14, 0xd4, 0x37, 0x41, 0x95, 0xb5, 0x3e, 0xa8, 0x59, 0x91, 0x70,
	0x25, 0xc7, 0xf5, 0xb5, 0x92, 0x80, 0x8a, 0x0f, 0x38, 0x45, 0x2e, 0xd1, 0x64, 0x70, 0x8b, 0x7e,
	0x1d, 0xf2, 0xbc, 0xcf, 0xc5, 0x4c, 0xb4, 0xe1, 0xc9, 0xda, 0x95, 0x21, 0x7d, 0x31, 0x66, 0x96,
	0x0a, 0xa8, 0xdc, 0x43, 0x3d, 0x17, 0xd0, 0xd5, 0xa1, 0x06, 0x79, 0xc9, 0x46, 0x69, 0x70, 0x02,
	0x7b, 0x4b, 0x79, 0xe2, 0x37, 0xe1, 0xcc, 0x0d, 0x09, 0x92, 0x9c, 0x79, 0xf6, 0x04, 0x22, 0xea,
	0xd0, 0xdd, 0x90, 0xca, 0x4f, 0x08, 0x2e, 0x76, 0xa9, 0xf0, 0x95, 0x95, 0x3e, 0x01, 0x4e, 0x2b,
	0x29, 0x52, 0x42, 0x8e, 0x9d, 0x9a, 0x90, 0x5f, 0x23, 0xb8, 0x34, 0x80, 0xfd, 0x69, 0xa7, 0xd6,
	0x13, 0xea, 0xfc, 0x23, 0x02, 0xbd, 0x8f, 0xe9, 0x16, 0xa5, 0xad, 0xd3, 0x56, 0x79, 0x60, 0xa7,
	0x7d, 0x02, 0x91, 0xbf, 0x42, 0x30, 0x7b, 0x2c, 0xf5, 0xa7, 0x4b, 0xe2, 0x85, 0x36, 0x9c, 0xed,
	0x39, 0x00, 0x2e, 0x81, 0xbe, 0xb1, 0xbb, 0xb9, 0x56, 0xdf, 0xbc, 0x66, 0x6f, 0xef, 0x2c, 0xef,
	0xec, 0x6e, 0xdb, 0xbb, 0x9b, 0xdb, 0x5b, 0xeb, 0xab, 0xf5, 0x8d, 0xfa, 0xfa, 0xda, 0x54, 0x06,
	0x5f, 0x80, 0xf3, 0x7d, 0xf6, 0xe5, 0xd5, 0x9d, 0xfa, 0xf5, 0xf5, 0x29, 0x84, 0x67, 0x61, 0xa6,
	0xcf, 0x54, 0xdf, 0x54, 0xc6, 0x31, 0x3d, 0x77, 0xef, 0xcb, 0x52, 0xa6, 0xf6, 0x6f, 0x0e, 0x26,
	0xd2, 0xdd, 0x0c, 0x7f, 0x84, 0xe4, 0x87, 0x91, 0x8f, 0xe7, 0x8f, 0x23, 0x7e, 0x4c, 0xcf, 0xd5,
	0xab, 0xc3, 0x1d, 0xa5, 0x52, 0x95, 0xe7, 0x3f, 0xfe, 0xe5, 0xaf, 0xcf, 0xc7, 0x2e, 0xe1, 0x59,
	0x73, 0xf0, 0x4b, 0x98, 0xbf, 0x2f, 0x92, 0xc7, 0xe5, 0xdc, 0x90, 0x9d, 0x13, 0x06, 0xf3, 0x43,
	0xfd, 0x14, 0x81, 0x97, 0x04, 0x81, 0x39, 0xfc, 0xc2, 0x60, 0x02, 0xe6, 0x1d, 0x55, 0xd4, 0x77,
	0xf1, 0x0f, 0x08, 0xa6, 0xfa, 0xab, 0x12, 0x2f, 0x9e, 0x88, 0x75, 0x4c, 0xfb, 0xd1, 0x97, 0xfe,
	0x47, 0x84, 0xe2, 0xf9, 0x9a, 0xe0, 0x59, 0xc3, 0x8b, 0x83, 0x78, 0xf2, 0x28, 0xbb, 0x71, 0x60,
	0x3f, 0xc2, 0xf9, 0x5b, 0x04, 0x93, 0xbd, 0x49, 0x8e, 0x8d, 0xc7, 0xc0, 0x4f, 0x15, 0xb2, 0x6e,
	0x3e, 0xb6, 0xbf, 0x62, 0x7b, 0x55, 0xb0, 0x5d, 0xc4, 0xc6, 0x30, 0xb6, 0xbc, 0x90, 0xcd, 0x3b,
	0xaa, 0xba, 0xef, 0xae, 0xac, 0xdd, 0x3f, 0x2c, 0xa1, 0x07, 0x87, 0x25, 0xf4, 0xe7, 0x61, 0x09,
	0x7d, 0x76, 0x54, 0xca, 0x3c, 0x38, 0x2a, 0x65, 0x7e, 0x3b, 0x2a, 0x65, 0xde, 0x5d, 0x48, 0xbd,
	0x17, 0xde, 0x7a, 0xe7, 0xfa, 0xfa, 0x26, 0x89, 0x6e, 0xd3, 0x70, 0xdf, 0x74, 0xf7, 0x1c, 0x3f,
	0x30, 0xdf, 0x57, 0x10, 0xe2, 0xdd, 0xd0, 0xc8, 0x8b, 0xdf, 0x24, 0xaf, 0xfc, 0x17, 0x00, 0x00,
	0xff, 0xff, 0x01, 0x21, 0xab, 0xbd, 0x5e, 0x0d, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// QueryFundersClient is the client API for QueryFunders service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type QueryFundersClient interface {
	// Funders queries all funders.
	Funders(ctx context.Context, in *QueryFundersRequest, opts ...grpc.CallOption) (*QueryFundersResponse, error)
	// Funder queries a funder by address.
	Funder(ctx context.Context, in *QueryFunderRequest, opts ...grpc.CallOption) (*QueryFunderResponse, error)
	// FundingsByFunder queries all fundings of a funder by address.
	FundingsByFunder(ctx context.Context, in *QueryFundingsByFunderRequest, opts ...grpc.CallOption) (*QueryFundingsByFunderResponse, error)
	// FundingsByPool queries all fundings of a pool by id.
	FundingsByPool(ctx context.Context, in *QueryFundingsByPoolRequest, opts ...grpc.CallOption) (*QueryFundingsByPoolResponse, error)
}

type queryFundersClient struct {
	cc grpc1.ClientConn
}

func NewQueryFundersClient(cc grpc1.ClientConn) QueryFundersClient {
	return &queryFundersClient{cc}
}

func (c *queryFundersClient) Funders(ctx context.Context, in *QueryFundersRequest, opts ...grpc.CallOption) (*QueryFundersResponse, error) {
	out := new(QueryFundersResponse)
	err := c.cc.Invoke(ctx, "/kyve.query.v1beta1.QueryFunders/Funders", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryFundersClient) Funder(ctx context.Context, in *QueryFunderRequest, opts ...grpc.CallOption) (*QueryFunderResponse, error) {
	out := new(QueryFunderResponse)
	err := c.cc.Invoke(ctx, "/kyve.query.v1beta1.QueryFunders/Funder", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryFundersClient) FundingsByFunder(ctx context.Context, in *QueryFundingsByFunderRequest, opts ...grpc.CallOption) (*QueryFundingsByFunderResponse, error) {
	out := new(QueryFundingsByFunderResponse)
	err := c.cc.Invoke(ctx, "/kyve.query.v1beta1.QueryFunders/FundingsByFunder", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryFundersClient) FundingsByPool(ctx context.Context, in *QueryFundingsByPoolRequest, opts ...grpc.CallOption) (*QueryFundingsByPoolResponse, error) {
	out := new(QueryFundingsByPoolResponse)
	err := c.cc.Invoke(ctx, "/kyve.query.v1beta1.QueryFunders/FundingsByPool", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// QueryFundersServer is the server API for QueryFunders service.
type QueryFundersServer interface {
	// Funders queries all funders.
	Funders(context.Context, *QueryFundersRequest) (*QueryFundersResponse, error)
	// Funder queries a funder by address.
	Funder(context.Context, *QueryFunderRequest) (*QueryFunderResponse, error)
	// FundingsByFunder queries all fundings of a funder by address.
	FundingsByFunder(context.Context, *QueryFundingsByFunderRequest) (*QueryFundingsByFunderResponse, error)
	// FundingsByPool queries all fundings of a pool by id.
	FundingsByPool(context.Context, *QueryFundingsByPoolRequest) (*QueryFundingsByPoolResponse, error)
}

// UnimplementedQueryFundersServer can be embedded to have forward compatible implementations.
type UnimplementedQueryFundersServer struct {
}

func (*UnimplementedQueryFundersServer) Funders(ctx context.Context, req *QueryFundersRequest) (*QueryFundersResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Funders not implemented")
}
func (*UnimplementedQueryFundersServer) Funder(ctx context.Context, req *QueryFunderRequest) (*QueryFunderResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Funder not implemented")
}
func (*UnimplementedQueryFundersServer) FundingsByFunder(ctx context.Context, req *QueryFundingsByFunderRequest) (*QueryFundingsByFunderResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FundingsByFunder not implemented")
}
func (*UnimplementedQueryFundersServer) FundingsByPool(ctx context.Context, req *QueryFundingsByPoolRequest) (*QueryFundingsByPoolResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FundingsByPool not implemented")
}

func RegisterQueryFundersServer(s grpc1.Server, srv QueryFundersServer) {
	s.RegisterService(&_QueryFunders_serviceDesc, srv)
}

func _QueryFunders_Funders_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryFundersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryFundersServer).Funders(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kyve.query.v1beta1.QueryFunders/Funders",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryFundersServer).Funders(ctx, req.(*QueryFundersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _QueryFunders_Funder_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryFunderRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryFundersServer).Funder(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kyve.query.v1beta1.QueryFunders/Funder",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryFundersServer).Funder(ctx, req.(*QueryFunderRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _QueryFunders_FundingsByFunder_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryFundingsByFunderRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryFundersServer).FundingsByFunder(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kyve.query.v1beta1.QueryFunders/FundingsByFunder",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryFundersServer).FundingsByFunder(ctx, req.(*QueryFundingsByFunderRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _QueryFunders_FundingsByPool_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryFundingsByPoolRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryFundersServer).FundingsByPool(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kyve.query.v1beta1.QueryFunders/FundingsByPool",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryFundersServer).FundingsByPool(ctx, req.(*QueryFundingsByPoolRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var QueryFunders_serviceDesc = _QueryFunders_serviceDesc
var _QueryFunders_serviceDesc = grpc.ServiceDesc{
	ServiceName: "kyve.query.v1beta1.QueryFunders",
	HandlerType: (*QueryFundersServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Funders",
			Handler:    _QueryFunders_Funders_Handler,
		},
		{
			MethodName: "Funder",
			Handler:    _QueryFunders_Funder_Handler,
		},
		{
			MethodName: "FundingsByFunder",
			Handler:    _QueryFunders_FundingsByFunder_Handler,
		},
		{
			MethodName: "FundingsByPool",
			Handler:    _QueryFunders_FundingsByPool_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "kyve/query/v1beta1/funders.proto",
}

func (m *Funder) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Funder) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Funder) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Stats != nil {
		{
			size, err := m.Stats.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFunders(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintFunders(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Contact) > 0 {
		i -= len(m.Contact)
		copy(dAtA[i:], m.Contact)
		i = encodeVarintFunders(dAtA, i, uint64(len(m.Contact)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Website) > 0 {
		i -= len(m.Website)
		copy(dAtA[i:], m.Website)
		i = encodeVarintFunders(dAtA, i, uint64(len(m.Website)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Identity) > 0 {
		i -= len(m.Identity)
		copy(dAtA[i:], m.Identity)
		i = encodeVarintFunders(dAtA, i, uint64(len(m.Identity)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Moniker) > 0 {
		i -= len(m.Moniker)
		copy(dAtA[i:], m.Moniker)
		i = encodeVarintFunders(dAtA, i, uint64(len(m.Moniker)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintFunders(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *FundingStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FundingStats) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FundingStats) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Score != 0 {
		i = encodeVarintFunders(dAtA, i, uint64(m.Score))
		i--
		dAtA[i] = 0x28
	}
	if len(m.PoolsFunded) > 0 {
		dAtA3 := make([]byte, len(m.PoolsFunded)*10)
		var j2 int
		for _, num := range m.PoolsFunded {
			for num >= 1<<7 {
				dAtA3[j2] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j2++
			}
			dAtA3[j2] = uint8(num)
			j2++
		}
		i -= j2
		copy(dAtA[i:], dAtA3[:j2])
		i = encodeVarintFunders(dAtA, i, uint64(j2))
		i--
		dAtA[i] = 0x22
	}
	if len(m.TotalAmountPerBundle) > 0 {
		for iNdEx := len(m.TotalAmountPerBundle) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.TotalAmountPerBundle[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintFunders(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.TotalAllocatedFunds) > 0 {
		for iNdEx := len(m.TotalAllocatedFunds) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.TotalAllocatedFunds[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintFunders(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.TotalUsedFunds) > 0 {
		for iNdEx := len(m.TotalUsedFunds) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.TotalUsedFunds[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintFunders(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Funding) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Funding) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Funding) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Score != 0 {
		i = encodeVarintFunders(dAtA, i, uint64(m.Score))
		i--
		dAtA[i] = 0x30
	}
	if len(m.TotalFunded) > 0 {
		for iNdEx := len(m.TotalFunded) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.TotalFunded[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintFunders(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.AmountsPerBundle) > 0 {
		for iNdEx := len(m.AmountsPerBundle) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.AmountsPerBundle[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintFunders(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Amounts) > 0 {
		for iNdEx := len(m.Amounts) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Amounts[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintFunders(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.PoolId != 0 {
		i = encodeVarintFunders(dAtA, i, uint64(m.PoolId))
		i--
		dAtA[i] = 0x10
	}
	if len(m.FunderAddress) > 0 {
		i -= len(m.FunderAddress)
		copy(dAtA[i:], m.FunderAddress)
		i = encodeVarintFunders(dAtA, i, uint64(len(m.FunderAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryFundersRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryFundersRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryFundersRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Search) > 0 {
		i -= len(m.Search)
		copy(dAtA[i:], m.Search)
		i = encodeVarintFunders(dAtA, i, uint64(len(m.Search)))
		i--
		dAtA[i] = 0x12
	}
	if m.Pagination != nil {
		{
			size, err := m.Pagination.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFunders(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryFundersResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryFundersResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryFundersResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Funders) > 0 {
		for iNdEx := len(m.Funders) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Funders[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintFunders(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Pagination != nil {
		{
			size, err := m.Pagination.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFunders(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryFunderRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryFunderRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryFunderRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Status != 0 {
		i = encodeVarintFunders(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintFunders(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryFunderResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryFunderResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryFunderResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Fundings) > 0 {
		for iNdEx := len(m.Fundings) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Fundings[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintFunders(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Funder != nil {
		{
			size, err := m.Funder.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFunders(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryFundingsByFunderRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryFundingsByFunderRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryFundingsByFunderRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Status != 0 {
		i = encodeVarintFunders(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintFunders(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0x12
	}
	if m.Pagination != nil {
		{
			size, err := m.Pagination.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFunders(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryFundingsByFunderResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryFundingsByFunderResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryFundingsByFunderResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Fundings) > 0 {
		for iNdEx := len(m.Fundings) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Fundings[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintFunders(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Pagination != nil {
		{
			size, err := m.Pagination.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFunders(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryFundingsByPoolRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryFundingsByPoolRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryFundingsByPoolRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Status != 0 {
		i = encodeVarintFunders(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x18
	}
	if m.PoolId != 0 {
		i = encodeVarintFunders(dAtA, i, uint64(m.PoolId))
		i--
		dAtA[i] = 0x10
	}
	if m.Pagination != nil {
		{
			size, err := m.Pagination.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFunders(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryFundingsByPoolResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryFundingsByPoolResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryFundingsByPoolResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Fundings) > 0 {
		for iNdEx := len(m.Fundings) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Fundings[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintFunders(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Pagination != nil {
		{
			size, err := m.Pagination.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFunders(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintFunders(dAtA []byte, offset int, v uint64) int {
	offset -= sovFunders(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Funder) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovFunders(uint64(l))
	}
	l = len(m.Moniker)
	if l > 0 {
		n += 1 + l + sovFunders(uint64(l))
	}
	l = len(m.Identity)
	if l > 0 {
		n += 1 + l + sovFunders(uint64(l))
	}
	l = len(m.Website)
	if l > 0 {
		n += 1 + l + sovFunders(uint64(l))
	}
	l = len(m.Contact)
	if l > 0 {
		n += 1 + l + sovFunders(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovFunders(uint64(l))
	}
	if m.Stats != nil {
		l = m.Stats.Size()
		n += 1 + l + sovFunders(uint64(l))
	}
	return n
}

func (m *FundingStats) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.TotalUsedFunds) > 0 {
		for _, e := range m.TotalUsedFunds {
			l = e.Size()
			n += 1 + l + sovFunders(uint64(l))
		}
	}
	if len(m.TotalAllocatedFunds) > 0 {
		for _, e := range m.TotalAllocatedFunds {
			l = e.Size()
			n += 1 + l + sovFunders(uint64(l))
		}
	}
	if len(m.TotalAmountPerBundle) > 0 {
		for _, e := range m.TotalAmountPerBundle {
			l = e.Size()
			n += 1 + l + sovFunders(uint64(l))
		}
	}
	if len(m.PoolsFunded) > 0 {
		l = 0
		for _, e := range m.PoolsFunded {
			l += sovFunders(uint64(e))
		}
		n += 1 + sovFunders(uint64(l)) + l
	}
	if m.Score != 0 {
		n += 1 + sovFunders(uint64(m.Score))
	}
	return n
}

func (m *Funding) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.FunderAddress)
	if l > 0 {
		n += 1 + l + sovFunders(uint64(l))
	}
	if m.PoolId != 0 {
		n += 1 + sovFunders(uint64(m.PoolId))
	}
	if len(m.Amounts) > 0 {
		for _, e := range m.Amounts {
			l = e.Size()
			n += 1 + l + sovFunders(uint64(l))
		}
	}
	if len(m.AmountsPerBundle) > 0 {
		for _, e := range m.AmountsPerBundle {
			l = e.Size()
			n += 1 + l + sovFunders(uint64(l))
		}
	}
	if len(m.TotalFunded) > 0 {
		for _, e := range m.TotalFunded {
			l = e.Size()
			n += 1 + l + sovFunders(uint64(l))
		}
	}
	if m.Score != 0 {
		n += 1 + sovFunders(uint64(m.Score))
	}
	return n
}

func (m *QueryFundersRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Pagination != nil {
		l = m.Pagination.Size()
		n += 1 + l + sovFunders(uint64(l))
	}
	l = len(m.Search)
	if l > 0 {
		n += 1 + l + sovFunders(uint64(l))
	}
	return n
}

func (m *QueryFundersResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Pagination != nil {
		l = m.Pagination.Size()
		n += 1 + l + sovFunders(uint64(l))
	}
	if len(m.Funders) > 0 {
		for _, e := range m.Funders {
			l = e.Size()
			n += 1 + l + sovFunders(uint64(l))
		}
	}
	return n
}

func (m *QueryFunderRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovFunders(uint64(l))
	}
	if m.Status != 0 {
		n += 1 + sovFunders(uint64(m.Status))
	}
	return n
}

func (m *QueryFunderResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Funder != nil {
		l = m.Funder.Size()
		n += 1 + l + sovFunders(uint64(l))
	}
	if len(m.Fundings) > 0 {
		for _, e := range m.Fundings {
			l = e.Size()
			n += 1 + l + sovFunders(uint64(l))
		}
	}
	return n
}

func (m *QueryFundingsByFunderRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Pagination != nil {
		l = m.Pagination.Size()
		n += 1 + l + sovFunders(uint64(l))
	}
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovFunders(uint64(l))
	}
	if m.Status != 0 {
		n += 1 + sovFunders(uint64(m.Status))
	}
	return n
}

func (m *QueryFundingsByFunderResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Pagination != nil {
		l = m.Pagination.Size()
		n += 1 + l + sovFunders(uint64(l))
	}
	if len(m.Fundings) > 0 {
		for _, e := range m.Fundings {
			l = e.Size()
			n += 1 + l + sovFunders(uint64(l))
		}
	}
	return n
}

func (m *QueryFundingsByPoolRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Pagination != nil {
		l = m.Pagination.Size()
		n += 1 + l + sovFunders(uint64(l))
	}
	if m.PoolId != 0 {
		n += 1 + sovFunders(uint64(m.PoolId))
	}
	if m.Status != 0 {
		n += 1 + sovFunders(uint64(m.Status))
	}
	return n
}

func (m *QueryFundingsByPoolResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Pagination != nil {
		l = m.Pagination.Size()
		n += 1 + l + sovFunders(uint64(l))
	}
	if len(m.Fundings) > 0 {
		for _, e := range m.Fundings {
			l = e.Size()
			n += 1 + l + sovFunders(uint64(l))
		}
	}
	return n
}

func sovFunders(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozFunders(x uint64) (n int) {
	return sovFunders(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Funder) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFunders
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Funder: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Funder: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFunders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFunders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFunders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Moniker", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFunders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFunders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFunders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Moniker = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Identity", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFunders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFunders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFunders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Identity = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Website", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFunders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFunders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFunders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Website = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Contact", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFunders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFunders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFunders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Contact = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFunders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFunders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFunders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFunders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFunders
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFunders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Stats == nil {
				m.Stats = &FundingStats{}
			}
			if err := m.Stats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFunders(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFunders
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FundingStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFunders
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FundingStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FundingStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalUsedFunds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFunders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFunders
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFunders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TotalUsedFunds = append(m.TotalUsedFunds, types.Coin{})
			if err := m.TotalUsedFunds[len(m.TotalUsedFunds)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalAllocatedFunds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFunders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFunders
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFunders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TotalAllocatedFunds = append(m.TotalAllocatedFunds, types.Coin{})
			if err := m.TotalAllocatedFunds[len(m.TotalAllocatedFunds)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalAmountPerBundle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFunders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFunders
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFunders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TotalAmountPerBundle = append(m.TotalAmountPerBundle, types.Coin{})
			if err := m.TotalAmountPerBundle[len(m.TotalAmountPerBundle)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFunders
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.PoolsFunded = append(m.PoolsFunded, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFunders
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthFunders
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthFunders
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.PoolsFunded) == 0 {
					m.PoolsFunded = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFunders
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.PoolsFunded = append(m.PoolsFunded, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field PoolsFunded", wireType)
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Score", wireType)
			}
			m.Score = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFunders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Score |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFunders(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFunders
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Funding) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFunders
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Funding: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Funding: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FunderAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFunders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFunders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFunders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FunderAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PoolId", wireType)
			}
			m.PoolId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFunders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PoolId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amounts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFunders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFunders
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFunders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Amounts = append(m.Amounts, types.Coin{})
			if err := m.Amounts[len(m.Amounts)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AmountsPerBundle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFunders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFunders
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFunders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AmountsPerBundle = append(m.AmountsPerBundle, types.Coin{})
			if err := m.AmountsPerBundle[len(m.AmountsPerBundle)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalFunded", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFunders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFunders
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFunders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TotalFunded = append(m.TotalFunded, types.Coin{})
			if err := m.TotalFunded[len(m.TotalFunded)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Score", wireType)
			}
			m.Score = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFunders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Score |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFunders(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFunders
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryFundersRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFunders
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryFundersRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryFundersRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pagination", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFunders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFunders
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFunders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pagination == nil {
				m.Pagination = &query.PageRequest{}
			}
			if err := m.Pagination.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Search", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFunders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFunders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFunders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Search = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFunders(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFunders
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryFundersResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFunders
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryFundersResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryFundersResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pagination", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFunders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFunders
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFunders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pagination == nil {
				m.Pagination = &query.PageResponse{}
			}
			if err := m.Pagination.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Funders", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFunders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFunders
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFunders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Funders = append(m.Funders, Funder{})
			if err := m.Funders[len(m.Funders)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFunders(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFunders
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryFunderRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFunders
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryFunderRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryFunderRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFunders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFunders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFunders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFunders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= FundingStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFunders(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFunders
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryFunderResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFunders
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryFunderResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryFunderResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Funder", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFunders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFunders
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFunders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Funder == nil {
				m.Funder = &Funder{}
			}
			if err := m.Funder.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fundings", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFunders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFunders
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFunders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fundings = append(m.Fundings, Funding{})
			if err := m.Fundings[len(m.Fundings)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFunders(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFunders
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryFundingsByFunderRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFunders
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryFundingsByFunderRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryFundingsByFunderRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pagination", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFunders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFunders
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFunders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pagination == nil {
				m.Pagination = &query.PageRequest{}
			}
			if err := m.Pagination.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFunders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFunders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFunders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFunders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= FundingStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFunders(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFunders
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryFundingsByFunderResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFunders
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryFundingsByFunderResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryFundingsByFunderResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pagination", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFunders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFunders
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFunders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pagination == nil {
				m.Pagination = &query.PageResponse{}
			}
			if err := m.Pagination.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fundings", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFunders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFunders
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFunders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fundings = append(m.Fundings, Funding{})
			if err := m.Fundings[len(m.Fundings)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFunders(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFunders
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryFundingsByPoolRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFunders
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryFundingsByPoolRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryFundingsByPoolRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pagination", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFunders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFunders
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFunders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pagination == nil {
				m.Pagination = &query.PageRequest{}
			}
			if err := m.Pagination.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PoolId", wireType)
			}
			m.PoolId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFunders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PoolId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFunders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= FundingStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFunders(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFunders
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryFundingsByPoolResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFunders
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryFundingsByPoolResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryFundingsByPoolResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pagination", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFunders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFunders
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFunders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pagination == nil {
				m.Pagination = &query.PageResponse{}
			}
			if err := m.Pagination.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fundings", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFunders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFunders
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFunders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fundings = append(m.Fundings, Funding{})
			if err := m.Fundings[len(m.Fundings)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFunders(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFunders
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipFunders(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowFunders
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowFunders
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowFunders
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthFunders
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupFunders
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthFunders
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthFunders        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowFunders          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupFunders = fmt.Errorf("proto: unexpected end of group")
)
